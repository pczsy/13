<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C#深入浅出之更多数据类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C#深入浅出之更多数据类型</center></div><div class='banquan'>原文出处:本文由博客园博主Lehanbal提供。<br/>
原文连接:https://www.cnblogs.com/lehanbal/p/11846313.html</div><br>
    <h2 id="类型的划分">类型的划分</h2>
<p>       <strong>一个类型，要么是值类型，要么是引用类型</strong>。区别在于拷贝方式：值类型拷贝值，引用类型拷贝引用</p>
<h3 id="值类型">值类型</h3>
<p>       值类型直接包含值。相当于每一个值类型都有自己单独的值：</p>
<pre><code><code>int a = 10;
int b = a;</code></pre>
<p>a和b都有着自己的值，修改a并不会影响b，反过来一样，互不影响。</p>
<p>       即使是将实例传给Console.WriteLine()这样的方法也会产生内存拷贝。由于值内存需要创建内存拷贝，因此定义的时候不要让它们占用太多内存。</p>
<h3 id="引用类型">引用类型</h3>
<p>       引用类型的变量存储对数据存储位置的引用，而不是直接存储数据。也就是说，要到对应的位置才能找到真正的数据。因此为了访问数据，“运行时”要先从变量中读取内存位置，再“跳转”到包含数据的内存位置。引用类型指向的内存区为成为堆。</p>
<p>       正如前面所说，引用类型拷贝引用，它不包含值，每次引用变量的赋值都是引用的拷贝，并不需要拷贝数据。</p>
<p>       值得注意的一点，引用类型只复制对数据的引用，所以两个不同的变量可引用相同的数据。在这种情况下，只要数据发生了改变，就会影响到所引用到他的变量的值，毕竟都是引用同一个数据。</p>
<h2 id="可空修饰符">可空修饰符</h2>
<p>       我之前提到过null值，它是给引用变量表示为空的值，一般不能将它赋值给值类型。根据定义，值类型不能包含引用。但是有的时候我们的确又有这一方面的需求，所以为了声明能存储null变量，要使用可空修饰符&quot;？&quot;。示例：</p>
<pre><code><code>int? cnt = null;</code></pre>
<h2 id="隐式类型的局部变量">隐式类型的局部变量</h2>
<p>    <strong>关键字：var</strong>，用于声明隐式类型的局部变量。示例：</p>
<pre><code><code>var text = Console.WriteLine();</code></pre>
<p>这么做最终的CIL代码并没有区别，但var告诉编译器根据声明时所赋的值来推断数据类型。</p>
<p>    虽然允许用var取代像是数据类型，但是在已知数据类型的情况下还是不要这么做，明确的声明数据类型不仅能够增加可读性，还相当于亲自确认了等号右边返回的是你所需要的数据类型。</p>
<p>    匿名类型能够在方法内部动态声明数据类型，并不需要通过显式的类定义来声明，示例：</p>
<pre><code><code>var people1 = new { Name = &quot;Van&quot;, Say = &quot;啊？&quot; };
var people2 = new { Name = &quot;Bili&quot;, Say = &quot;乖乖站好&quot; };
System.Console.WriteLine( $&quot;{people1.Name} {people1.Say}&quot;);
System.Console.WriteLine( $&quot;{people2.Name} {people2.Say}&quot;);</code></pre>
<h2 id="元组">元组</h2>
<p>    有时候需要合并数据元素。<strong>元组</strong>正好可以解决这个问题，它允许在一个语句内完成所有变量的赋值。</p>
<p>    以下是它的语法形式：</p>
<p>    将元组赋给单独声明的变量：</p>
<pre><code><code>(string power, string name, int weight) = (&quot;超高校的幸运&quot;, &quot;脖子直抖&quot;, 65);</code></pre>
<p>    将元组赋给预声明的变量:</p>
<pre><code><code>string power, name;
int weight;
(power, name, weight) = (&quot;超高校的幸运&quot;, &quot;脖子直抖&quot;, 65);</code></pre>
<p>    将元组赋给隐式类型的变量：</p>
<pre><code><code>var (power,name,weight) = (&quot;超高校的幸运&quot;, &quot;脖子直抖&quot;, 65);</code></pre>
<p><strong>注意</strong>：此处以及下面包含的 var 绝不能如果替换成显示类型（如string或int）。因为元组宗旨是允许每一项都有不同的数据类型，所以每一项都指定同一个显示类型名称和这个宗旨冲突，即便是真的一样，编译器也不允许指定显示类型。</p>
<p>    声明具名元组，将元组值赋给它。</p>
<pre><code><code>(string power, string name, int weight) people = (&quot;超高校的幸运&quot;, &quot;脖子直抖&quot;, 65);</code></pre>
<p>    声明包含具名元组项的元组，将其赋给隐式类型的变量。</p>
<pre><code><code>var people = (power:&quot;超高校的幸运&quot;, name:&quot;脖子直抖&quot;, weight:65);</code></pre>
<p>    将元组项未具名的元组赋给隐式类型的变量，再通过向编号属性访问单独的元素。</p>
<pre><code><code>var people = (&quot;超高校的幸运&quot;, &quot;脖子直抖&quot;, 65);
people.Item1;//people.Item2;</code></pre>
<p>若是具名元组还是可以通过项目编号属性访问单独的元素。</p>
<p>    赋值时用下划线丢弃元组的一部分数据（弃元）。</p>
<pre><code><code>(string power, _, int weigth) people = (&quot;超高校的幸运&quot;, &quot;脖子直抖&quot;, 65);</code></pre>
<h2 id="数组">数组</h2>
<p>    数组能够在单个变量中存储同一种类型的多个数据项，并且可以通过索引来单独访问这些数据项。数组的数据线索引从0开始，最大索引值总是比数组中的数据项少1。但是现在大多数程序都使用泛型集合类型而非数组来存储数据集合。</p>
<h3 id="数组声明">数组声明</h3>
<p>    数组声明，直接上代码：</p>
<pre><code><code>string[] arr1;</code></pre>
<p>方括号在数据类型之后，变量名之前。</p>
<p>    声明二维数组的方法，代码：</p>
<pre><code><code>string[,] arr2;</code></pre>
<p>在用逗号进行多维数组的声明，总共维数等于逗号加一。</p>
<h3 id="数组的实例化和赋值">数组的实例化和赋值</h3>
<p>    数组可在声明的同时初始化，例如：</p>
<pre><code><code>string[] arr3 = {&quot;1&quot;,&quot;1&quot;,&quot;4&quot;,&quot;5&quot;,&quot;1&quot;,&quot;4&quot;};</code></pre>
<p>元素的下标对应就是对应元素的位置，依次排列。</p>
<p>    也可以先声明数组再进行赋值，如下:</p>
<pre><code><code>string[] arr4;
arr4 = new string[]{&quot;1&quot;,&quot;1&quot;,&quot;4&quot;,&quot;5&quot;,&quot;1&quot;,&quot;4&quot;};</code></pre>
<p>但是从C#3.0开始就不必在new之后指定数组类型。编译器能根据初始化列表中的数据类型推断数组类型。如下：</p>
<pre><code><code>arr4 = new []{&quot;1&quot;,&quot;1&quot;,&quot;4&quot;,&quot;5&quot;,&quot;1&quot;,&quot;4&quot;};</code></pre>
<p>上面使用了<strong>new</strong>关键字，它指示“运行时”为数据库类型分配内存，也就是实例化数据类型。</p>
<p>    我们也可以给数组分配固定大小但不提供初始化，也可以指定大小并赋值，如下：</p>
<pre><code><code>string[] arr5 = new string[6]{&quot;1&quot;,&quot;1&quot;,&quot;4&quot;,&quot;5&quot;,&quot;1&quot;,&quot;4&quot;};</code></pre>
<p>    数组在没有被初始化的时候，“运行时”会给每个元素初始化为他们的默认值：</p>
<ul>
<li>引用类型会被初始化为null。</li>
<li>数字类型会被初始化为0。</li>
<li>bool初始化为false。</li>
<li>char类型初始化为\0。</li>
</ul>
<p>    多位数组注意不要超出对应的声明范围，这里不再讨论。</p>
<h3 id="数组的使用">数组的使用</h3>
<p>    可以用方括号表示法（数组访问符）来访问数组中一个特定的数据项。注意下标是从0开始的，最大下标是数组内容减一。</p>
<pre><code><code>arr1[1];//表示arr1数组中第二个元素的内容</code></pre>
<p>    二维数组同理。</p>
<p>    <strong>交错数组</strong>，也就是数组数组，用数组来存储数组，声明方式如下：</p>
<pre><code><code>int[][] arr6 = {
    new int[]{1,1,1};
    new int[]{2,2,2};
    new int[]{3,3,3};
}</code></pre>
<p>    当然数组也有一些方法，下面进行举例：</p>
<ul>
<li>arr.Length:获取数组的长度，只读。</li>
</ul>
<p>我们在访问数组的边界元素时，一般会采取Length-1这样的方式来访问数组边界成员。</p>
<ul>
<li>System.Array.Sort()：对数组内容进行排序。</li>
<li>System.Array.BinarySearch(var[] arr, var searchString):返回搜索值的索引，不存在就返回-1。前提是按升序排序。</li>
<li>System.Array.Clear(intArray, 0, intArray.Length):清空第0到第intArray.Length个索引的元素（置零）。</li>
<li>System.Array.Reverse(arr):反转数组顺序。</li>
</ul>
<p>还有众多方法，这里不一一列举，看个乐呵。</p>
<h3 id="字符串作为数组使用">字符串作为数组使用</h3>
<p>    我们需要注意的是，字符串是不可变的，字符串作为数组使用时，我们访问到的成员变量都是char类型的变量。为此将字符串作为数组使用时要注意不能去修改成员变量的内容。</p>
<h2 id="小结">小结</h2>
<p>    本次博文的内容介绍了更多的数据结构，但是这也只是开始，介绍了值类型，引用类型，隐式类型，元组以及数组，这些内容都会贯彻到我们今后的项目之中，一定要打好坚实的基础，当然不是说要背下来，理解到位才是我们应该去做的。</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>