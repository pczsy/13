<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修.NET架构师知识普及' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>.NET架构师知识普及</center></div><div class='banquan'>原文出处:本文由博客园博主lingfeng95提供。<br/>
原文连接:https://www.cnblogs.com/zhao123/p/11104207.html</div><br>
    <p>今天看到一篇漫画，[3年.NET开发应聘大厂惨遭淘汰，如何翻身打脸面试官？]，好多问题，一下子还真的回答不了，这里对这些问题进行了整理，增加下脑容量，哈哈。俗话说不想当将军的士兵不是好士兵，不想当架构师的程序员，不是一个努力要进步的程序员，努力加油，不断学习。有人说架构师都是一批秃顶的人，程序员都是一群XX，其实现实是，架构师好多不是秃顶，不用担心自己成了架构师变成秃顶，那都是吓人的。程序员也是懂得浪漫的，要不然那么多浪漫的程序，那么多酷炫的技巧都是怎么实现的。</p>
<h2>1.C#中的委托是什么？事件是不是一种委托？</h2>
<p>委托是一种引用类型，表示对具有特定参数列表和返回类型的方法的引用。委托用于将方法作为参数传递给其他方法。事件就是通过委托调用的方法。<br />例如：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> DelegateTest
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">int</span> AddDelegate(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b); <span style="color: #008000;">//</span><span style="color: #008000;">定义委托类型</span>
    <span style="color: #0000ff;">public</span> AddDelegate addDelegate; <span style="color: #008000;">//</span><span style="color: #008000;">定义委托</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">event</span> AddDelegate AddDelegateForEvent; <span style="color: #008000;">//</span><span style="color: #008000;">定义事件</span>

    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">a:{a},b:{b}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">委托和事件的使用</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Test() {
        DelegateTest text </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> DelegateTest();
        text.addDelegate </span>=<span style="color: #000000;"> text.Add; ;
        text.addDelegate(</span><span style="color: #800080;">1</span>, <span style="color: #800080;">2</span><span style="color: #000000;">);

        text.AddDelegateForEvent </span>+=<span style="color: #000000;"> text.addDelegate;
        text.AddDelegateForEvent </span>+=<span style="color: #000000;"> text.addDelegate;
        text.AddDelegateForEvent(</span><span style="color: #800080;">10</span>, <span style="color: #800080;">20</span>);<span style="color: #008000;">//</span><span style="color: #008000;">或者下面的使用
        </span><span style="color: #008000;">//</span><span style="color: #008000;">AddDelegate d = text.AddDelegateForEvent;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">d(10, 20);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">结果
        </span><span style="color: #008000;">//</span><span style="color: #008000;">a: 1,b: 2
        </span><span style="color: #008000;">//</span><span style="color: #008000;">a: 10,b: 20
        </span><span style="color: #008000;">//</span><span style="color: #008000;">a: 10,b: 20</span>
<span style="color: #000000;">    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Func和Action的使用</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Test2() {
        Func</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; add = (<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) =&gt; { <span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b; };
        Action</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; addVoid = (<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) =&gt; { <span style="color: #0000ff;">int</span> c = a +<span style="color: #000000;"> b; };
    }
}</span></pre>
</div>
<p><a href="https://www.cnblogs.com/zhao123/p/4170691.html" target="_blank">C#中委托</a>这篇文章，对委托有更多的介绍。Fun和Action是微软封装的委托，一个有返回值，一个没有，<a href="https://www.cnblogs.com/zhao123/p/5639082.html" target="_blank">C#高级功能（三）Action、Func，Tuple</a>这篇文章介绍的比较详细。</p>
<h2>2.聊聊.NET的管道和.NET Core的中间件</h2>
<p>.NET的管道：在管道模型运行开始前，首先HTTP的请求被被传递到HttpRuntime类的一个实例中，然后这个实例对象检测请求并找到被接受的那个应用程序，接下来管道模型就使用HttpApplicationFactory对象来创建一个HttpApplication对象来处理这个请求（在此同时也将创建HttpContext，HttpRequest和HttpResponse），一个HttpApplication可以包含一系列HttpModule对象。</p>
<h3>ASP.NET MVC请求生命周期</h3>
<p>URL Routing Module &rarr;&rarr; Matching Route Entry &rarr;&rarr; Route Handle &rarr;&rarr; Http Handle &rarr;&rarr; Controller Factory &rarr;&rarr; Controller &rarr;&rarr; Action Invoker &rarr;&rarr; Module Binders &rarr;&rarr; Authentication Filter &rarr;&rarr; Authorization Filter &rarr;&rarr; Action Filter &rarr;&rarr; Action Execution &rarr;&rarr; Action Filter &rarr;&rarr; Action Result<br />简单就是：Url &rarr;&rarr; Route &rarr;&rarr; Controller &rarr;&rarr; Action &rarr;&rarr; View</p>
<p>其他的ASP.NET生命周期的文章，<a href="https://www.cnblogs.com/zhao123/p/3363868.html" target="_blank">ASP.NET生命周期</a>&nbsp;，&nbsp;<a href="https://www.cnblogs.com/zhao123/p/3360369.html" target="_blank">WebForm页面运行周期--页面关系</a></p>
<h3>.NET Core的中间件</h3>
<p>中间件是一种装配到应用管道中以处理请求和响应的程序，使用Run、Map和Use扩展方法来配置请求委托。请求委托用于构建请求管道，处理每个HTTP请求。每个委托可以在下一个委托之前和之后执行操作。委托还可以决定不将请求传递给下一个委托，这称为请求管道的短路。短路通常是可取的，因为它避免了不必要的工作。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Startup
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">此处省略部分代码，创建一个新的Core web项目，可以自行查看</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
        {
            app.UseExceptionHandler(</span><span style="color: #800000;">"</span><span style="color: #800000;">/Home/Error</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseStaticFiles();
        app.UseCookiePolicy();

        app.UseMvc(routes </span>=&gt;<span style="color: #000000;">
        {
            routes.MapRoute(
                name: </span><span style="color: #800000;">"</span><span style="color: #800000;">default</span><span style="color: #800000;">"</span><span style="color: #000000;">,
                template: </span><span style="color: #800000;">"</span><span style="color: #800000;">{controller=Home}/{action=Index}/{id?}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        });
    }
}</span></pre>
</div>
<p>Configure方法中的就是中间件，中间件组件的顺序定义了在请求上调用它们的顺序，以及响应的相反顺序，此排序对于安全性，性能和功能至关重要。<br />常用的中间件顺序<br />1. 异常/错误处理<br />2. HTTP 严格传输安全协议，<a href="https://www.cnblogs.com/zhao123/p/5655357.html" target="_blank">HTTP协议介绍</a><br />3. HTTPS 重定向<br />4. 静态文件服务器<br />5. Cookie 策略实施<br />6. 身份验证<br />7. 会话<br />8.MVC</p>
<p>中间件例子：</p>
<div class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> LogMiddleware
{
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">readonly</span><span style="color: #000000;"> RequestDelegate _next;
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> LogMiddleware(RequestDelegate next)
    {
        _next </span>=<span style="color: #000000;"> next;
    }

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">async</span><span style="color: #000000;"> Task Invoke(HttpContext context)
    {
        Debug.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">程序运行 开始。</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">await</span><span style="color: #000000;"> _next(context);
        Debug.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">程序运行 结束。</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    }
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> LogMiddlewareExtensions {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> IApplicationBuilder UseLog(<span style="color: #0000ff;">this</span><span style="color: #000000;"> IApplicationBuilder app) {
        </span><span style="color: #0000ff;">return</span> app.UseMiddleware&lt;LogMiddleware&gt;<span style="color: #000000;">();
    }
}</span></pre>
</div>
<p>在Configure中 app.UseLog();就可，程序运行，会在VS调试输出的地方显示<br />程序运行 开始。<br />Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker:Information: Route matched with {action = "Index", controller = "Home"}. Executing action ----此处省略部分输出<br />Microsoft.AspNetCore.Mvc.Internal.ControllerActionInvoker:Information: Executed action WebCore.Controllers.HomeController.Index (WebCore) in 13.9555ms<br />程序运行 结束。</p>
<h2>3.说说数据库的隔离级别，数据库有哪些锁</h2>
<p>数据库事物的四大特性：原子性、一致性、隔离性、持续性（永久性）。原子性：要么全做，要么全不做；一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的；隔离性：一个事务的执行不能被其他事务干扰；永久性：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。<br />事务的隔离性：未提交读（Read uncommitted），已提交读（Read committed），可重复读（Repeatable read），可串行化（Serializable ）。未提交读：最低级别，任何情况都无法保证；已提交读：可避免脏读的发生；可重复读：可避免脏读、不可重复读的发生；串行化：可避免脏读、不可重复读、幻读的发生。举例：未提交读：A更新了数据没有提交B可以看到；已提交读：A更新了数据没有提交B看不到，提交之后可以看到；可重复读：A插入一条数据，提交之后，B看不到，B事物结束之后，在查询可以看到；可串行化：A执行完之后B才可执行。（所有的一切操作都是并行操作）<br />数据库中的锁：分为独占锁（即排它锁），共享锁和更新锁，细分又可分为表锁、行锁、页锁等。<br />为什么需要所？当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。<br />共享锁表示对数据进行select操作，多个事务可以同时为一个对象加共享锁。排他锁也叫写锁，排他锁表示对数据进行insert、update或delete操作，如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。更新锁在的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。</p>
<h2>4.口述下如何设计一个SOA框架</h2>
<p>SOA的全称是Service Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对应用组件进行分布式部署、组合和使用，服务层是SOA的基础，可以直接被应用调用，从而有效控制系统松耦合。简单来说就是A功能布置在A服务器，B功能布置在B服务器，他们都开放出接口供C。。等访问，C不用知道A，B是如何实现的，只管用就可以了。简单的例子webservice、WCF、web api等等。</p>
<p>SOA框架的文章，<a href="https://www.cnblogs.com/zhao123/p/5599096.html" target="_blank">Web Service 和WCF的比较</a></p>
<h2>5.SOA和微服务架构之间的主要区别是什么？</h2>
<p>我的理解是：SOA和微服务是一脉相承的，两者都是中立性，语言无关，协议跨平台。微服务的目的是有效的拆分应用，服务的细粒度，重用组合，甚至是每个操作（或方法）都是独立开发的服务，足够小到不能再进行拆分。SOA更适合大型企业中的业务过程编排、应用集成。</p>
<h2>6.了解各个framework的底层不？</h2>
<p>C#源码文件 &rarr;&rarr; C#编译器 &rarr;&rarr; 程序集 &rarr;&rarr; 本机语言<br />底层的库：CLR（Common Language Runtime）公共语言运行时，CTS（Common Type System）通用类型系统，CLS（Common Language Specfication）公共语言规范，CIL（Common Intermediate Language）公共中间语言，CLI（Common Language Infrastructure）公共语言基础结构</p>
<h2>7.说说浏览器页面的渲染过程</h2>
<p>DNS查询 &rarr;&rarr; TCP链接 &rarr;&rarr; HTTP请求 &rarr; 服务器响应 &rarr;&rarr; 客户端渲染（HTML，CSS，JS）</p>
<h2>8.说说中介模式的设计原理和应用场景</h2>
<p>中介者模式是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，只要修改一个对象，其它关联的对象都得进行修改，如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行。房产中介、QQ游戏平台、聊天室、QQ群和短信平台</p>
<h2>9.请问如何构架一个高负载的系统？</h2>
<p>应用服务和数据服务分离，使用缓存改善网站性能，使用应用服务器集群改善网站的并发处理能力，数据库读写分离，使用反向代理和CDN加速网站响应，使用分布式文件系统和分布式数据库系统，使用NoSQL和搜索引擎，对业务拆分，建立分布式服务。</p>
<h2>10..NET系统如何实现水平扩展、如何解决高并发问题</h2>
<p>水平扩展：利用Nginx建立分布式系统，增加服务器，增加CPU<br />解决高并发问题:增加缓存、禁止用户重复操作、建立请求队列</p>
<h2>11.说说IIS的工作原理？</h2>
<p>对比IIS来说，它依赖HTTP.SYS的内置程序来监听外部的HTTP请求，如果请求的是一个可访问的URL，HTTP.SYS会将这个请求交给IIS工作进程，把信息保存到HttpWorkRequest中，在相互隔离的应用程序域AppDomain中加载HttpRuntime，调用HttpRuntime的ProcessRequest方法，之后就是我们的程序操作，最后返回数据流，并重新返回到HTTP.SYS,HTTP.SYS在将数据返回给客户端浏览器。</p>
<p><a href="https://www.cnblogs.com/zhao123/p/5588888.html" target="_blank">Win10下IIS配置图解</a>、<a href="https://www.cnblogs.com/zhao123/p/5588888.html" target="_blank">MVC项目发布图解</a>、<a href="https://www.cnblogs.com/zhao123/p/5588888.html" target="_blank">IIS添加网站图解</a>。</p>
<h2>12.手写一个千万并发的商品秒杀功能</h2>
<p>Redis缓存秒杀的商品ID，数量，一个请求数量减少一个，数量等于0的时候，直接返回失败，成功的数据保存到消息队列中，之后保存到数据库，秒杀的商品比较少的，直接用一个线程安全的列表就可以了。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>