<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修泛型实现常用算法' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>泛型实现常用算法</center></div><div class='banquan'>原文出处:本文由博客园博主lingfeng95提供。<br/>
原文连接:https://www.cnblogs.com/zhao123/p/9947940.html</div><br>
    <h2>1.冒泡排序（o(n2)）</h2>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢&ldquo;浮&rdquo;到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名&ldquo;冒泡排序&rdquo;。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 交换数据
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="i"&gt;&lt;/param&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="j"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Swap&lt;T&gt;(IList&lt;T&gt; data, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T:IComparable{
    T temp </span>=<span style="color: #000000;"> data[i];
    data[i] </span>=<span style="color: #000000;"> data[j];
    data[j] </span>=<span style="color: #000000;"> temp;
}

</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 冒泡排序(有哨兵)
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> BubbleSortWithSentry&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> flag;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = data.Count - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; i--<span style="color: #000000;">)
    {
        flag </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; j++<span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">if</span> (data[j].CompareTo(data[j + <span style="color: #800080;">1</span>]) &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)
            {
                Swap(data, j, j </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
                flag </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }

        </span><span style="color: #0000ff;">if</span> (flag) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
    }
}

</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 冒泡排序
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> BubbleSort&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = data.Count - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; i--<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; j++<span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">if</span> (data[j].CompareTo(data[j + <span style="color: #800080;">1</span>]) &gt; <span style="color: #800080;">0</span>) Swap(data, j, j + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
    }
}</span></pre>
</div>
<p>冒泡排序过程分析：把最大的放到最后</p>
<div class="cnblogs_code">
<pre><code>///运行测试<br />Stopwatch watch = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Stopwatch();
</span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; <span style="color: #800080;">100</span>; k++<span style="color: #000000;">)
{
    Random rd </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Random();
    List</span>&lt;<span style="color: #0000ff;">int</span>&gt; bubbleSortData = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
    List</span>&lt;<span style="color: #0000ff;">int</span>&gt; bubbleSortWithSentryData = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">100</span>; i++<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">int</span> d = rd.Next(<span style="color: #800080;">1000</span><span style="color: #000000;">);
        bubbleSortData.Add(d);
        bubbleSortWithSentryData.Add(d);
    }

    watch.Restart();
    SuanFa.BubbleSort(bubbleSortData);
    watch.Stop();
    </span><span style="color: #0000ff;">long</span> bubbleSortTime =<span style="color: #000000;"> watch.ElapsedTicks;

    watch.Restart();
    SuanFa.BubbleSortWithSentry(bubbleSortWithSentryData);
    watch.Stop();
    </span><span style="color: #0000ff;">long</span> bubbleSortWithSentryTime =<span style="color: #000000;"> watch.ElapsedTicks;

    Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">时间差: {bubbleSortWithSentryTime - bubbleSortTime}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}</span></pre>
</div>
<p>有哨兵和没有哨兵的运行结果分析，并不是每次有哨兵的都小于没有哨兵的，相反有哨兵的运行时间与没有哨兵的运行时间差小于0的次数比小于50%。if运行是需要花费时间的，基本上在2个运行周期。</p>
<h2>2.选择排序（o(n2)）</h2>
<h4 id="选择排序算法的原理如下">选择排序算法的原理如下：</h4>
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 选择排序
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> SelectSort&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> min;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; data.Count - <span style="color: #800080;">1</span>; i++<span style="color: #000000;">)
    {
        min </span>=<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; data.Count; j++<span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">if</span> (data[j].CompareTo(data[min]) &lt; <span style="color: #800080;">0</span>) min =<span style="color: #000000;"> j;
        }

        </span><span style="color: #0000ff;">if</span> (min !=<span style="color: #000000;"> i) Swap(data, i, min);
    }
}</span></pre>
</div>
<p>选择排序分析：把最小的放到最前面</p>
<h2>3.插入排序（o(n2)）</h2>
<p>插入排序有以下几种：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）</p>
<h4 id="直接插入排序算法的原理如下">直接插入排序算法的原理如下：</h4>
<p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 直接插入排序
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> InsertSort&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> min;
    T temp;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; data.Count; i++<span style="color: #000000;">)
    {
        temp </span>=<span style="color: #000000;"> data[i];
        min </span>=<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; j--<span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">if</span> (temp.CompareTo(data[j]) &gt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;

            data[j </span>+ <span style="color: #800080;">1</span>] =<span style="color: #000000;"> data[j];
            min </span>=<span style="color: #000000;"> j;
        }

        </span><span style="color: #0000ff;">if</span> (min != i) data[min] =<span style="color: #000000;"> temp;
    }
}</span></pre>
</div>
<p>插入排序分析：把一个数与一个已经排好的序的最大值比较，如果比最大值大直接插入，否则最大值依次后移，把索引保存，最后插入要插入的数据。</p>
<h4 id="折半插入二分插入排序的原理如下">折半插入/二分插入排序的原理如下：</h4>
<p>折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 折半插入/二分插入排序
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> BinaryInsertSort&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> pre, end, mid;
    T temp;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; data.Count; i++<span style="color: #000000;">)
    {
        temp </span>=<span style="color: #000000;"> data[i];
        pre </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        end </span>= i - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (pre &lt;=<span style="color: #000000;"> end)
        {
            mid </span>= (pre + end) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (temp.CompareTo(data[mid]) &gt;= <span style="color: #800080;">0</span>) pre = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> end = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }

        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &gt; pre; j--<span style="color: #000000;">)
            data[j] </span>= data[j - <span style="color: #800080;">1</span><span style="color: #000000;">];

        </span><span style="color: #0000ff;">if</span> (pre != i) data[pre] =<span style="color: #000000;"> temp;
    }
}</span></pre>
</div>
<p>折半插入排序：折半插入排序,使用使用折半查找的方式寻找插入点的位置, 可以减少比较的次数,但移动的次数不变, 时间复杂度和空间复杂度和直接插入排序一样，在元素较多的情况下能提高查找性能。折半插入的关键点在于找到插入的位置。</p>
<h2>4.快速排序（o(nlogn)）</h2>
<h4 id="快速排序算法的原理如下">快速排序算法的原理如下：</h4>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 快速排序
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> QuickSort&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable {
    QuickSort(data, </span><span style="color: #800080;">0</span>, data.Count - <span style="color: #800080;">1</span><span style="color: #000000;">);
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> QuickSort&lt;T&gt;(IList&lt;T&gt; data, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">if</span> (left &lt;<span style="color: #000000;"> right)
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">取中间的元素作为比较基准，小于他的往左边移，大于他的往右边移 　　</span>
        T middle = data[(left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> l = left - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> r = right + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">while</span> (data[++l].CompareTo(middle) &lt; <span style="color: #800080;">0</span> &amp;&amp; l &lt;<span style="color: #000000;"> right) ;
            </span><span style="color: #0000ff;">while</span> (data[--r].CompareTo(middle) &gt; <span style="color: #800080;">0</span> &amp;&amp; r &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) ;
            </span><span style="color: #0000ff;">if</span> (l &gt;= r) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            Swap(data, l, r);
        }
        QuickSort(data, left, l </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
        QuickSort(data, r </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, right);
    }
}</span></pre>
</div>
<p>快速排序分析：注意基准数据永远不变，永远是和基准数据进行比较，无论在什么位置，最后的目的就是把基准数据放在中间，小的放左边大的放右边</p>
<h2>5.归并排序</h2>
<h4 id="归并排序算法的原理如下">归并排序算法的原理如下：</h4>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #808080;">///</span><span style="color: #008000;"> 归并排序
</span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
<span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="data"&gt;&lt;/param&gt;</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> MergeSort&lt;T&gt;(IList&lt;T&gt; data) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    MergeSort(data, </span><span style="color: #800080;">0</span>, data.Count - <span style="color: #800080;">1</span><span style="color: #000000;">);
}

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> MergeSort&lt;T&gt;(IList&lt;T&gt; data, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    </span><span style="color: #0000ff;">if</span> (left &lt;<span style="color: #000000;"> right)
    {
        </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        MergeSort(data, left, mid);
        MergeSort(data, mid </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, right);
        Merge(data, left, mid, right);
    }
}

</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Merge&lt;T&gt;(IList&lt;T&gt; data, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> mid, <span style="color: #0000ff;">int</span> right) <span style="color: #0000ff;">where</span><span style="color: #000000;"> T : IComparable
{
    T[] temp </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> T[data.Count];
    </span><span style="color: #0000ff;">int</span> l =<span style="color: #000000;"> left;
    </span><span style="color: #0000ff;">int</span> m = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> l;

    </span><span style="color: #0000ff;">while</span> (l &lt;= mid &amp;&amp; m &lt;=<span style="color: #000000;"> right)
    {
        </span><span style="color: #0000ff;">if</span> (data[l].CompareTo(data[m]) &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">)
            temp[t</span>++] = data[l++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
            temp[t</span>++] = data[m++<span style="color: #000000;">];
    }

    </span><span style="color: #0000ff;">while</span> (l &lt;= mid) temp[t++] = data[l++<span style="color: #000000;">];

    </span><span style="color: #0000ff;">while</span> (m &lt;= right) temp[t++] = data[m++<span style="color: #000000;">];

    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left; i &lt;= right; i++) data[i] =<span style="color: #000000;"> temp[i];
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>