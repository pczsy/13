<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C#的一些小知识' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C#的一些小知识</center></div><div class='banquan'>原文出处:本文由博客园博主Ligo丶提供。<br/>
原文连接:https://www.cnblogs.com/Ligo-Z/p/11256405.html</div><br>
    <h3 id="var关键字">1.var关键字</h3>
<p>var是一个弱类型,可以替代任何类型</p>
<h4 id="有以下四个特点">有以下四个特点</h4>
<p>1.必须在定义时初始化</p>
<pre><code><code>var s=&quot;adcd&quot;;  //可以
var s;
s=&quot;abcd&quot;;  //不可以
</code></pre>
<p>2.初始化完成吼,不能给其赋类型不同的值</p>
<p>3.var要求是局部变量</p>
<p>4.使用var定义变量和object不同，它在效率上和使用强类型方式定义变量完全一样。</p>
<h3 id="ref和out的区别">2.ref和out的区别</h3>
<h4 id="注在c中方法的参数传递有四种类型传值by-value传址by-reference输出参数by-output数组参数by-array传值参数无需额外的修饰符传址参数需要修饰符ref输出参数需要修饰符out数组参数需要修饰符params">注:在C#中，方法的参数传递有四种类型：传值（by value），传址（by reference），输出参数（by output），数组参数（by array）。传值参数无需额外的修饰符，传址参数需要修饰符ref，输出参数需要修饰符out，数组参数需要修饰符params。</h4>
<p>1、使用ref型参数时，传入的参数必须先被初始化。对out而言，必须在方法中对其完成初始化。</p>
<p>2、使用ref和out时，在方法的参数和执行方法时，都要加Ref或Out关键字。以满足匹配。</p>
<p>3、out适合用在需要retrun多个返回值的地方，而ref则用在需要被调用的方法修改调用者的引用的时候。</p>
<p><strong>两个的区别：ref是有进有出，out是只出不进。</strong></p>
<h3 id="委托">3.委托</h3>
<p>声明委托</p>
<pre><code><code>//delegate &lt;return type&gt; &lt;delegate-name&gt;&lt;parameter list&gt;
public delegate int MyDelegate (string s);</code></pre>
<p>实例化委托</p>
<pre><code><code>public delegate void printString(string s);
...
printString ps1 = new printString(WriteToScreen);
printString ps2 = new printString(WriteToFile);</code></pre>
<p>委托的多播</p>
<p>使用&quot;+&quot;运算符进行合并 <strong>一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并</strong></p>
<pre><code><code> // 创建委托实例
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         // 调用多播
         nc(5);
   //调用nc时会同时调用nc1和nc2</code></pre>
<h3 id="foreach不支持在循环中添加删除操作">4.foreach不支持在循环中添加删除操作</h3>
<p><strong>作者：<a href="https://www.cnblogs.com/Ligo-Z">Ligo丶</a></strong></p>
<p><strong>出处：<a href="https://www.cnblogs.com/Ligo-Z/" class="uri">https://www.cnblogs.com/Ligo-Z/</a></strong></p>
<p><strong>本文版权归作者和博客园共有，欢迎转载，但必须给出原文链接，并保留此段声明，否则保留追究法律责任的权利。</strong></p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>