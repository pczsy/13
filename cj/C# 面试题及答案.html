<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C# 面试题及答案' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C# 面试题及答案</center></div><div class='banquan'>原文出处:本文由博客园博主周小杰提供。<br/>
原文连接:https://www.cnblogs.com/zhouxiaojie/p/10708193.html</div><br>
    <ol>
<li></li>
<li>分析以下代码</li>
</ol>
<p align="left">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span>  <span style="color: #0000ff;">string</span> str = <span style="color: #800000;">"</span><span style="color: #800000;">abc123中文汉字</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;">2</span> 
<span style="color: #008080;">3</span>             <span style="color: #0000ff;">int</span> i =<span style="color: #000000;"> System.Text.Encoding.Default.GetBytes(str).Length;
</span><span style="color: #008080;">4</span> 
<span style="color: #008080;">5</span>             <span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> str.Length;
</span><span style="color: #008080;">6</span> 
<span style="color: #008080;">7</span> <span style="color: #000000;">            Console.WriteLine(i);
</span><span style="color: #008080;">8</span> 
<span style="color: #008080;">9</span>         Console.WriteLine(j);</pre>
</div>
<p>&nbsp;</p>
<p><strong>答案：i=14;i=10;</strong></p>
<p>2.请输出B.test()的输出结果</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> A
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> M1()
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span> Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;"> i am A </span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> M2()
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">{
</span><span style="color: #008080;">10</span> Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;"> i ={0} </span><span style="color: #800000;">"</span><span style="color: #000000;">,i);
</span><span style="color: #008080;">11</span> <span style="color: #000000;">}
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> B:A
</span><span style="color: #008080;">15</span> <span style="color: #000000;">{
</span><span style="color: #008080;">16</span> <span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span><span style="color: #000000;">;
</span><span style="color: #008080;">17</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> M1()
</span><span style="color: #008080;">18</span> <span style="color: #000000;">{
</span><span style="color: #008080;">19</span> Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;"> i am B </span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">20</span> <span style="color: #000000;">}
</span><span style="color: #008080;">21</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> M2()
</span><span style="color: #008080;">22</span> <span style="color: #000000;">{
</span><span style="color: #008080;">23</span> Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;"> i ={0} </span><span style="color: #800000;">"</span><span style="color: #000000;">, i);
</span><span style="color: #008080;">24</span> <span style="color: #000000;">}
</span><span style="color: #008080;">25</span> <span style="color: #000000;">}
</span><span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span> <span style="color: #000000;">{
</span><span style="color: #008080;">30</span> 
<span style="color: #008080;">31</span> B b = <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
</span><span style="color: #008080;">32</span> A a =<span style="color: #000000;"> b;
</span><span style="color: #008080;">33</span> <span style="color: #000000;">a.M1();
</span><span style="color: #008080;">34</span> <span style="color: #000000;">b.M1();
</span><span style="color: #008080;">35</span> <span style="color: #000000;">a.M2();
</span><span style="color: #008080;">36</span> <span style="color: #000000;">b.M2();
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> }</pre>
</div>
<p>&nbsp;</p>
<p style="margin-left: 30px;"><strong>答案： i am B;</strong></p>
<p style="margin-left: 30px;"><strong>i am B;</strong></p>
<p style="margin-left: 30px;"><strong>1;</strong></p>
<p style="margin-left: 30px;"><strong>2;</strong></p>
<p>3.有序集合seqList{1,1,2,3,5,8,13,21,34.........}请查找集合中第一个大于2147483647的数。</p>
<p><strong>答案：此函数是有名的斐波那契数。实现此函数的方法为</strong></p>
<div class="cnblogs_code">
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">递归写法</span>
<span style="color: #008080;"> 2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> foo(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n)
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">if</span>(n&lt;<span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 5</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> foo(n-<span style="color: #800080;">2</span>)+foo(n-<span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #008000;">//</span><span style="color: #008000;">循环写法</span>
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] foo2(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n)
</span><span style="color: #008080;">10</span> <span style="color: #000000;">{
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>{<span style="color: #800080;">1</span><span style="color: #000000;">};
</span><span style="color: #008080;">12</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(n==<span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>{<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span><span style="color: #000000;">};
</span><span style="color: #008080;">13</span> <span style="color: #0000ff;">else</span>
<span style="color: #008080;">14</span> <span style="color: #000000;">{
</span><span style="color: #008080;">15</span> <span style="color: #0000ff;">int</span> rel[]=<span style="color: #0000ff;">new</span><span style="color: #000000;"> rel[n];
</span><span style="color: #008080;">16</span> rel[<span style="color: #800080;">0</span>]=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">17</span> rel[<span style="color: #800080;">1</span>]=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">18</span> <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;n;i++<span style="color: #000000;">)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">{
</span><span style="color: #008080;">20</span>     rel[i]=rel[i-<span style="color: #800080;">2</span>]+rel[i-<span style="color: #800080;">1</span><span style="color: #000000;">];
</span><span style="color: #008080;">21</span> <span style="color: #000000;">}
</span><span style="color: #008080;">22</span> <span style="color: #000000;">}
</span><span style="color: #008080;">23</span> }</pre>
</div>
<p>&nbsp;</p>
</div>
<p>查找大于2147483647的数用二分法查找。</p>
<div class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> FibonacciSearch(<span style="color: #0000ff;">int</span>[] array, <span style="color: #0000ff;">int</span><span style="color: #000000;"> key) {
        </span><span style="color: #0000ff;">int</span> length =<span style="color: #000000;"> array.Length;
        </span><span style="color: #0000ff;">int</span> low = <span style="color: #800080;">0</span>, high = length - <span style="color: #800080;">1</span>, mid, k = <span style="color: #800080;">0</span><span style="color: #000000;">;
        mid</span>=(low+high )/<span style="color: #800080;">2</span>
        <span style="color: #0000ff;">while</span>(mid&lt;<span style="color: #000000;">high)
{
   </span><span style="color: #0000ff;">if</span>(array[mid]==key){<span style="color: #0000ff;">return</span> mid;<span style="color: #0000ff;">break</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(array[mid]&gt;key){high=mid;mid=(low+high )/<span style="color: #800080;">2</span><span style="color: #000000;">;}
</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(array[mid]&lt;key){low=mid;mid=(low+high )/<span style="color: #800080;">2</span><span style="color: #000000;">;}
}
}</span></pre>
</div>
<p>4.简述以下词在C#语言中的作用</p>
<p><strong><span style="color: #000000;">volatile</span></strong>:（创建单例模式时会使用，懒汉模式）就像大家更熟悉的const一样，volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。如果不加入volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值.,简单地说就是防止编译器对代码进行优化.比如如下程序：</p>
<div>
<div id="highlighter_190955" class="syntaxhighlighter  cpp">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code>XBYTE[2]=0x55;</code></div>
<div class="line number2 index1 alt1"><code>XBYTE[2]=0x56;</code></div>
<div class="line number3 index2 alt2"><code>XBYTE[2]=0x57;</code></div>
<div class="line number4 index3 alt1"><code>XBYTE[2]=0x58;</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="para">对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，认为只有XBYTE[2]=0x58（即忽略前三条语句，只产生一条机器代码）。如果键入volatile，则编译器会逐一的进行编译并产生相应的机器代码（产生四条代码）.<strong>原文引用</strong><a title="volatile" href="https://www.cnblogs.com/lvdongjie/p/5469246.html" target="_blank">https://www.cnblogs.com/lvdongjie/p/5469246.html</a></div>
<div class="para"><span style="color: #000000;"><strong>interlocked</strong></span>:为多个线程共享的变量提供原子操作(仅限int类型)。<strong>微软原文<a title="interlocked" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.interlocked?view=netframework-4.7.2" target="_blank">https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.interlocked?view=netframework-4.7.2</a>&nbsp; &nbsp; 个人微博原文：<a title="interlocked" href="https://www.cnblogs.com/Zachary-Fan/p/interlocked.html" target="_blank">https://www.cnblogs.com/Zachary-Fan/p/interlocked.html</a></strong></div>
<div class="para"><strong>monitor:lock:<strong>(lock是一种混合锁，相当于Monitor.Enter(object)方法是获取锁，Monitor.Exit(object)方法是释放锁的组合)</strong>详见原文<a title="lock&amp;&amp;monitor" href="https://www.cnblogs.com/chengxingliang/p/3150731.html" target="_blank">https://www.cnblogs.com/chengxingliang/p/3150731.html</a></strong></div>
<div class="para">&nbsp;</div>
<div class="para"><strong>ReaderWriterLock:字面意思，读写锁，分为读锁和写锁，多个线程读一个对象, 而只有一个线程要写这个对象. 那么对于读线程来说, 它不改变对象的内容, 我们就应该允许多个线程同时读, 只有在写的时候才要给锁住对象. 这样可以提高读线程的吞吐量。详见原文&nbsp;<a title="readerwriterlock" href="https://blog.csdn.net/changtianshuiyue/article/details/16943499" target="_blank">https://blog.csdn.net/changtianshuiyue/article/details/16943499</a></strong></div>
<div class="para">&nbsp;</div>
<div class="para"><strong>AutoResetEvent|&nbsp; &nbsp;ManualResetEvent&nbsp; 字面意思为自动重置事件和手动重置事件，这两个类可以理解为设置信号，来进行阻塞线程或者让线程重新启动。上原文<a href="https://www.cnblogs.com/fangyz/p/5040206.html" target="_blank">https://www.cnblogs.com/fangyz/p/5040206.html</a></strong></div>
<div class="para">&nbsp;</div>
<div class="para"><strong>Semaphore 信号量，通过计数器设置可以访问的线程数目例如设置为10，则可以同时有10个线程访问此资源，每当有一个线程访问此资源，则信号量减1，访问完成之后释放则加1，当信号量=0时禁止访问，阻塞线程，当信号量&gt;0时，可以访问。原文<a href="https://www.cnblogs.com/tianzhiliang/archive/2010/08/31/1813635.html" target="_blank">https://www.cnblogs.com/tianzhiliang/archive/2010/08/31/1813635.html</a></strong></div>
<div class="para">&nbsp;</div>
<div class="para"><strong>Mutex&nbsp; &nbsp;互斥量，嗯。。。说起来挺麻烦，还是看原文吧。<a href="https://www.cnblogs.com/suntp/p/8258488.html" target="_blank">https://www.cnblogs.com/suntp/p/8258488.html</a></strong></div>
<div class="para">&nbsp;</div>
<div class="para">5.MVC平台，网页设计textbox控件时，编辑代码有四种形式，以下已经写出了第一种，请写出后三种。</div>
<div class="para">@using MvcViewModelTest.Models</div>
<div class="para">
<div class="cnblogs_code" style="text-align: left;">
<pre><code><span style="color: #008080;">1</span> <span style="color: #000000;">//第一种 
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="tea_Name"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="tea.Name"</span><span style="color: #ff0000;"> type</span><span style="color: #0000ff;">="text"</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">="马老师"</span><span style="color: #0000ff;">/&gt;</span>
<span style="color: #008080;">3</span> <span style="color: #000000;">//第二种
</span><span style="color: #008080;">4</span> <span style="color: #000000;">@Html.TextBox("tea.Name",Model.tea.Name)
</span><span style="color: #008080;">5</span> <span style="color: #000000;">//第三种
</span><span style="color: #008080;">6</span> <span style="color: #000000;">@Html.TextBoxFor(m=&gt;m.tea.Name)
</span><span style="color: #008080;">7</span> <span style="color: #000000;">//第四种
</span><span style="color: #008080;">8</span> @Html.TextEditorFor(m=&gt;m.tea.Name)</pre>
</div>
<p style="text-align: left;">6.用一条SQL语句 查询出每门功课都大于80分的学生姓名，表结构如下</p>
<table style="height: 230px; float: left; width: 428px;" border="0">
<tbody>
<tr>
<td>姓名　　</td>
<td>课程　　</td>
<td>分数　　</td>
</tr>
<tr>
<td>张三</td>
<td>语文</td>
<td>81</td>
</tr>
<tr>
<td>张三</td>
<td>数学</td>
<td>75</td>
</tr>
<tr>
<td>张三</td>
<td>英语</td>
<td>82</td>
</tr>
<tr>
<td>李四</td>
<td>语文</td>
<td>76</td>
</tr>
<tr>
<td>李四</td>
<td>数学</td>
<td>90</td>
</tr>
<tr>
<td>李四</td>
<td>英语</td>
<td>82</td>
</tr>
<tr>
<td>王五</td>
<td>语文</td>
<td>81</td>
</tr>
<tr>
<td>王五</td>
<td>数学</td>
<td>100</td>
</tr>
<tr>
<td>王五</td>
<td>英语</td>
<td>92</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>答案一：select 姓名 from 表 where 姓名 not in (select 姓名 from 表 where 分数&lt;=80)</p>
<p>答案二（推荐）：select 姓名 from 表&nbsp; group by 姓名 having min(分数）&gt;80</p>
<p>7.简述Vue中methods、computed以及watch的用法及区别。</p>
<p>1#computed：计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p>2#methods：methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<p>3#watch：是一种更通用的方式来观察和响应 Vue 实例上的数据变动。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。<br />&nbsp;<strong>官方API地址</strong>：<a href="https://cn.vuejs.org/v2/api/#computed" rel="nofollow" target="_blank">https://cn.vuejs.org/v2/api/#computed</a></p>
<p><strong>个人博客：<a title="Vue" href="https://blog.csdn.net/smartdt/article/details/75557369" target="_blank">https://blog.csdn.net/smartdt/article/details/75557369</a></strong></p>
<p>8.现有一个业务系统有4万用户，所有用户每天产生6千万数据，系统要求快速查询60天数据，请给出你的实现方案。</p>
<p>9.描述你曾经或者正在使用的大型项目解决方案。</p>
<p>10.何时必须声明一个类为抽象类？</p>
<p>答案：当这个类中包含抽象方法时，或是该类并没有完全实现父类的抽象方法时。</p>
<p>11.MVC框架中，ActionResult，JsonResult,ContentResult哪个可以return view()?</p>
<p>答案：ActionResult。</p>
<p>12.Aspx页面中，updatepanel的作用是什么？</p>
<p>答案：UpdatePanel控制页面的局部更新。（局部更新控件）、</p>
<p>13.MVC框架中，当使用Get方法访问JsonResult时，能否直接采用以下写法：return json(obj).为什么？</p>
<p>答案：不能，要使用&nbsp;<span class="attribute">res.JsonRequestBehavior&nbsp;=&nbsp;<span class="attribute-value">JsonRequestBehavior.AllowGet;//允许使用GET方式获取，否则用GET获取是会报错。&nbsp;</span></span></p>
<p>14.可以采用foreach迭代的类的对象必须满足什么条件？</p>
<p>答案：需要实现IEnumerable接口或声明GetEnumerator方法的类型。注：不一定要实现IEnumerable接口，但一定要实现GetEnumrator方法。</p>
<p>15.在dotnet环境下，如何把数据库数据转换为XML格式输出？</p>
<p>将数据库的内容读取到dataTable或dataSet中，dataTable或dataSet转为xml。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">string</span> ConvertDataTableToXML(DataTable xmlDS) <span style="color: #008000;">//</span><span style="color: #008000;">DataTable可改用dataset</span>
<span style="color: #000000;">    {
        MemoryStream stream </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        XmlTextWriter writer </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">
        {
            stream </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MemoryStream();
            writer </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> XmlTextWriter(stream, Encoding.Default);
            xmlDS.WriteXml(writer);
            </span><span style="color: #0000ff;">int</span> count = (<span style="color: #0000ff;">int</span><span style="color: #000000;">)stream.Length;
            </span><span style="color: #0000ff;">byte</span>[] arr = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span><span style="color: #000000;">[count];
            stream.Seek(</span><span style="color: #800080;">0</span><span style="color: #000000;">, SeekOrigin.Begin);
            stream.Read(arr, </span><span style="color: #800080;">0</span><span style="color: #000000;">, count);
            UTF8Encoding utf </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> UTF8Encoding();
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> utf.GetString(arr).Trim();
        }
        </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">
        {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> String.Empty;
        }
        </span><span style="color: #0000ff;">finally</span><span style="color: #000000;">
        {
            </span><span style="color: #0000ff;">if</span> (writer != <span style="color: #0000ff;">null</span><span style="color: #000000;">) writer.Close();
        }
    }</span></pre>
</div>
<p>&nbsp;</p>
<p>16.Html页面上，有如下代码&lt;input type="button"&nbsp; name ="btndel" onclick="Del()"/&gt;.现在要求用户点击删除后，弹出删除确认的对话框，并在点击确定后弹出对话框&ldquo;&rdquo;&ldquo;删除完毕&rdquo;，用JS如何实现。</p>
<p>答案：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">function</span><span style="color: #000000;"> Del()
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span> <span style="color: #0000ff;">if</span>(confirm("确定删除"<span style="color: #000000;">))
</span><span style="color: #008080;">4</span>       alert("删除成功"<span style="color: #000000;">)
</span><span style="color: #008080;">5</span> }</pre>
</div>
<p>17.请写出一个json的例子。</p>
<p>答案：[{"id":"123","name":"huawei"}]</p>
<p>18.List&lt;Domain1&gt; Alist 中有100个Domain1元素，且每个Domain1元素都有属性string&nbsp; typStr,现在需要取出AList中所有typeStr="Atype"的元素，并组成新的List,该如何实现。</p>
<p>答案：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> List&lt;<span style="color: #0000ff;">string</span>&gt; BList=<span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">foreach</span>(<span style="color: #0000ff;">var</span> a <span style="color: #0000ff;">in</span><span style="color: #000000;"> AList)
</span><span style="color: #008080;">3</span> <span style="color: #000000;">{
</span><span style="color: #008080;">4</span> <span style="color: #0000ff;">if</span>(a.typeStr==<span style="color: #800000;">"</span><span style="color: #800000;">Atype</span><span style="color: #800000;">"</span><span style="color: #000000;">)
</span><span style="color: #008080;">5</span> <span style="color: #000000;">    Blist.add(a.typeStr);
</span><span style="color: #008080;">6</span> }</pre>
</div>
<p>19.EF框架中，使用DBFirst时数据库中的表A没有主键，能否通过&ldquo;从数据库更新模型&ldquo;操作，将表A导入到EF框架中。</p>
<p>答案：不能，表必须要有主键，否则会报错。</p>
<p>savechange（）方法返回0，而不是正常的大于0的书。切记设置主键。</p>
<p>返回错误InnerException = {"无法更新 EntitySet&ldquo;t_Customer&rdquo;，因为它有一个 DefiningQuery，而 &lt;ModificationFunctionMapping&gt; 元素中没有支持当前操作的 &lt;InsertFunction&gt; 元素。"}。</p>
<p>在发现错误后要吧原有的数据库的表删除，重新更新。如果不删除的话，无法更新，并且要重新生成解决方案。<br />20.foreach和for循环谁的效率高？switch和if呢？</p>
<p>答案：foreach高，for 循环每次都要进行判断i的大小，foreach 依赖 IEnumerable.第一次 var a in GetList() 时 调用 GetEnumerator 返回第一个对象 并 赋给a,以后每次再执&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 行 var a in GetList() 的时候 调用 MoveNext.直到循环结束。期间GetList()方法只执行一次.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 同样的道理：当有多个判断时，switch更快。</p>
<p>21.WebService基于什么协议？</p>
<p>&nbsp;答案：soap协议，而Soap建立在http上的。</p>
<p>22.WebService和WebAPI 有什么不同。<em>&nbsp; &nbsp;</em></p>
<p>1、webservice是基于SOAP协议的，数据格式是XML，webapi遵循的http协议，它的Response可以被而Web API的MediaTypeFormatter转换成Json、XML 或者任何你想转换的格式。<br />2、webservice它只能部署在IIS上，而webapi可以寄宿在不同的宿主上（寄宿的本质就是利用一个具体的应用程序为Web Api提供一个运行的环境，并解决请求的接收和响应的回复），如Web Host，Self Host方式<br />3、webservice 也可以通过ajax访问。</p>
<p>4、webapi无状态，相对webservice更轻量级。webapi支持如get,post等http操作，并且对限制带宽的设备，比如智能手机等支持的很好。</p>
<p><strong>这样对比的话webservice貌似并不好用。但是我们为什么要用它呢，理由如下：</strong></p>
<p>1、很好的跨编程语言和跨操作系统<br />2、可移植性：传统的WebService只是利用了HTTP通道，进行独立的交互，但是这个交互协议可以移植到其他协议下运作</p>
<p>&nbsp;</p>
<p>23.C#是否支持多重继承？</p>
<p>答案：不支持。<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" target="_blank">多重继承</a>指的是一个类可以同时继承多个类，比如A类继承自B类和C类，这就是<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/8372262" target="_blank" data-lemmaid="8372262">多重继承</a>。C#只能继承一个类，但是可以继承多个接口。</p>
<p>24.修饰符protected internal 的意思？</p>
<p>internal修饰的b在同一个项目中哪里都可以访问，而在另外一个项目中就不能访问，说明&ldquo;同一程序集&rdquo;指的是同一个项目；对于protected internal修饰的a在同一项目中哪里都可以访问，而在其它项目中只有在<a class="baidu-highlight" href="https://www.baidu.com/s?wd=%E6%B4%BE%E7%94%9F%E7%B1%BB&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank">派生类</a>可以访问，所以protected internal 修饰的成员变量是同一程序集或者<a class="baidu-highlight" href="https://www.baidu.com/s?wd=%E6%B4%BE%E7%94%9F%E7%B1%BB&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank">派生类</a>可以访问，也就是protected跟internal的并集，而不是交集。（<strong>被protected internal修饰的属性/方法只能在它的在同一个程序集（Assembly）中的子类被访问</strong>）查资料找到了两种说法，不知道哪种是对的，个人以为是第一种是对的。</p>
<p>25.bs架构下，可否声明一个静态的数据库连接对象，所有的业务类都引用该静态连接对象去访问数据库？</p>
<p>答案：一个静态的Sqlconnection来管理项目内所有的数据库连接在绝大部分场景是不合理的<br />(没说绝对不可行,在winform单线程项目中,这样做是没有问题的,因为操作者是一个用户,每个用户都有一份程序副本)<br />如果是多个用户提交的请求是<br />同一个AppDomain中的函数,方法(这种说话不严谨,不过我暂时找不到更好的表达方式)<br />来处理时.都是用同一个静态的Sqlconnection对象是不行的.<br />会引起并发问题,会引起相互干扰.还需要加锁lock才能操作.</p>
<p>26.C#提供了一个默认的无参数构造函数，当我实现了另外一个有一个参数的构造函数的时候，还想保留这个无参数的构造函数。这样我应该写几个构造函数？</p>
<p>答案：两个。</p>
<p>27.能够阻止某一个类被其他类继承么？能够实现允许某个类被继承，但不允许其中某个方法被覆写吗？</p>
<p>答案：（1）当对一个类应用 sealed 修饰符时，此修饰符会阻止其他类从该类继承，（2）可以，标记这个类为public，并标记这个方法为sealed.</p>
<p>28.什么是强类型？C#是强类型吗，JS呢？</p>
<p>答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343" target="_blank" data-lemmaid="1258343">编译</a>时刻确定。常见的强类型语言有<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank">C++</a>、<a href="https://baike.baidu.com/item/Java/85979" target="_blank" data-lemmaid="85979">Java</a>、<a href="https://baike.baidu.com/item/Apex" target="_blank">Apex</a>和<a href="https://baike.baidu.com/item/Python" target="_blank">Python</a>等，C#是强类型，JS不是。</p>
<p>29.金额等精确的数值声明为什么类型？</p>
<p>答案：float，double,decimal</p>
<p>30.读写数据库都需要哪些对象，简要说明其作用。</p>
<p>答案1、 Connection：与数据源建立连接。<br />2、 Command：对数据源执行SQL命令并返回结果。<br />3、 DataReader：读取数据源的数据，只允许对将数据源以只读、顺向的方式查看其中所存储的数据。其常用于检索大量数据，DataReader对象还是一种非常节省资源的<a class="baidu-highlight" href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank">数据对象</a>。<br />4、 DataAdapter：对数据源执行操作并返回结果，在DataSet与数据源之间建立通信，将数据源中的数据写入DataSet中，或根据DataSet中的<a class="baidu-highlight" href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank">数据绑定</a>数据源。<br />5、 DataSet：内存中的数据库，是<a class="baidu-highlight" href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E8%A1%A8&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank">数据表</a>的集合，它可以包含任意多个<a class="baidu-highlight" href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E8%A1%A8&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank">数据表</a>。</p>
<p>31.通过程序控制GC的强制回收是否可以提高效率？</p>
<p>答案：个人以为是可以的（在网上没找到答案），GC是循环遍历所有资源的，如果你已经强制回收了，那么遍历的就会少，从而提高效率。</p>
<p>32.int?和int的区别。</p>
<p>答案：int?为可空类型，可以是null,他是通过把int装箱为引用类型实现的。</p>
<p>33.求数列（1,1,2,3,5,8,13。。。。）的和。</p>
<p>答案：见第三题的循环写法，定义一个变量为sum,sum+=arr[I]</p>
<p>34.BS架构下，在session中存储了一个datatable的对象y,y在什么时候会被GC回收？这种存储数据的方式是否合理？如果Application增加了对y的引用，什么时候会被GC回收？</p>
<p>答案：在session的生命周期结束之后回收，不合理，每个session储存在服务器端的内存里，每个用户都会有一个独立的session，如果session的内容过于复杂，当大量的用户访问的时候会导致内存溢出。<strong>Application是所有用户共有的，所以应该不会被回收（个人理解）</strong>。</p>
<p>35.string和stringbuilder的区别。</p>
<p>答案：System.String是不可变的字符串。System.StringBuilder存放了一个可变的字符串，并提供一些对这个字符串修改的方法</p>
<p>36.举例写一个单例模式</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Singleton
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> Singleton _Singleton = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>         <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">object</span> Singleton_Lock = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">();
</span><span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Singleton CreateInstance()
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 7</span>             <span style="color: #0000ff;">if</span> (_Singleton == <span style="color: #0000ff;">null</span>) <span style="color: #008000;">//</span><span style="color: #008000;">双if +lock</span>
<span style="color: #008080;"> 8</span> <span style="color: #000000;">            {
</span><span style="color: #008080;"> 9</span>                 <span style="color: #0000ff;">lock</span><span style="color: #000000;"> (Singleton_Lock)
</span><span style="color: #008080;">10</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">11</span>                     Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">路过。</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">12</span>                     <span style="color: #0000ff;">if</span> (_Singleton == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">13</span> <span style="color: #000000;">                    {
</span><span style="color: #008080;">14</span>                         Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">被创建。</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>                         _Singleton = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Singleton();
</span><span style="color: #008080;">16</span> <span style="color: #000000;">                    }
</span><span style="color: #008080;">17</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">18</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">19</span>             <span style="color: #0000ff;">return</span><span style="color: #000000;"> _Singleton;
</span><span style="color: #008080;">20</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">21</span>     }</pre>
</div>
<p>37.描述一下<strong>virtual、sealed、override和abstract的区别。</strong></p>
<p><strong>答案：</strong></p>
<p>virtual申明虚方法的关键字，说明该方法可以被重写</p>
<p>sealed说明该类不可被继承</p>
<p>override重写基类的方法</p>
<p>abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化。</p>
<p>38.List&lt;int&gt; listNumber,其中存储了从1到100的数字，现需要将ListNumber按照形如&ldquo;1,2,3,4.。。&rdquo;输出，请写出相应的代码。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">foreach</span>(<span style="color: #0000ff;">var</span> a <span style="color: #0000ff;">in</span><span style="color: #000000;"> listNumber.sort())
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span> <span style="color: #000000;">  Console.WriteLine(a);
</span><span style="color: #008080;">4</span> }</pre>
</div>
<p>39.int,string,hashtable,datetime,datatable中哪些是引用类型？</p>
<p>答案：string，hashtable，datatable</p>
<p>40.一棵二叉查找树（Binary Seach Tree）具有以下特点，树中的任一节点，如果左子树不为空，则左子树的所有节点的值都小于该节点的值，如果右子树不为空，那么右子树所有节点的值都大于该节点的值；任一个节点的左右子树都是二叉查找树，示意图如下</p>
<p><img src="./images/C# 面试题及答案0.png" alt="" /></p>
<p>假设二叉查找树的节点定义如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #000000;">Class BSTreeNode{
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> value;
</span><span style="color: #008080;">3</span> <span style="color: #000000;">BSTreeNode leftChild;
</span><span style="color: #008080;">4</span> <span style="color: #000000;">BSTreeNode rightChild;
</span><span style="color: #008080;">5</span> }</pre>
</div>
<p>要实现一个方法printRang:按从小到大的顺序输出范围在【min,max】之间的所有值。请写出你认为最高效的代码。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">void</span> printRang(BSTreeNode btsnode,<span style="color: #0000ff;">int</span> min,<span style="color: #0000ff;">int</span><span style="color: #000000;"> max)
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">//</span><span style="color: #008000;">中序遍历，大于min的输出，小于max的不输出
</span><span style="color: #008080;"> 5</span> <span style="color: #008000;">//</span><span style="color: #008000;">循环这里使用栈辅助进行遍历</span>
<span style="color: #008080;"> 6</span> System.Collections.Generic.Stack&lt;Tree&gt; stack = <span style="color: #0000ff;">new</span> System.Collections.Generic.Stack&lt;Tree&gt;<span style="color: #000000;">();
</span><span style="color: #008080;"> 7</span> <span style="color: #0000ff;">while</span>(btsnode != <span style="color: #0000ff;">null</span> ||<span style="color: #000000;"> stack.Any())
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">if</span>(btsnode.value&gt;max)<span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (btsnode != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">12</span> <span style="color: #000000;">                     stack.Push(btsnode);
</span><span style="color: #008080;">13</span>                     btsnode =<span style="color: #000000;"> btsnode.Left;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">15</span>                 <span style="color: #0000ff;">else</span>
<span style="color: #008080;">16</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">17</span>                     <span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> stack.Pop();
</span><span style="color: #008080;">18</span>                     <span style="color: #0000ff;">if</span>(item.Value&gt;=min&amp;&amp;item.Value&lt;=<span style="color: #000000;">max)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">                          Console.WriteLine(item.Value);
</span><span style="color: #008080;">20</span>                     btsnode =<span style="color: #000000;"> item.Right;
</span><span style="color: #008080;">21</span> <span style="color: #000000;">                }</span> 
<span style="color: #008080;">23</span> <span style="color: #000000;">}
</span><span style="color: #008080;">24</span> }</pre>
</div>
<p>41.请写出一段在多线程运行时有可能产生死锁（不需要一定产生）的代码。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">int</span> <span style="color: #0000ff;">string</span> a=<span style="color: #800000;">"</span><span style="color: #800000;">aaaa</span><span style="color: #800000;">"</span>,b=<span style="color: #800000;">"</span><span style="color: #800000;">bbbb</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Seta(){
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;">(b)
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span> a=<span style="color: #800000;">"</span><span style="color: #800000;">bbbb</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Setb(){
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">lock</span><span style="color: #000000;">(a)
</span><span style="color: #008080;">10</span> <span style="color: #000000;">{
</span><span style="color: #008080;">11</span> b=<span style="color: #800000;">"</span><span style="color: #800000;">aaaa</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span> <span style="color: #000000;">}
</span><span style="color: #008080;">13</span> <span style="color: #000000;">}
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>   Thread t = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(Seta);  
</span><span style="color: #008080;">16</span>   Thread.Sleep(<span style="color: #800080;">5000</span><span style="color: #000000;">);
</span><span style="color: #008080;">17</span> <span style="color: #000000;">  t.Start();  
</span><span style="color: #008080;">18</span>   Thread t2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Thread(Setb);  
</span><span style="color: #008080;">19</span>   Thread.Sleep(<span style="color: #800080;">5000</span><span style="color: #000000;">);
</span><span style="color: #008080;">20</span>   t2.Start();  </pre>
</div>
<p>42.假设你的编程语言提供这样的异步机制，把一个任务放在一个线程池中执行，当前线程继续执行，直到调用这个任务取返回值的方法时才阻塞并等待任务完成拿到返回值。</p>
<p>现在有这样一个场景，收到一个客户端的订单请求要检查商品的库存能否满足，查询该客户按照当前的价格策略能否享受订单的折扣才能接受订单，而这两个检查都是非常耗时的操作。原来的代码是这样的：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">public</span><span style="color: #000000;"> booleanprocessOrder(Order order)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span> <span style="color: #0000ff;">if</span>(!<span style="color: #000000;">checkCustomerprice(order))
</span><span style="color: #008080;">4</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">5</span> <span style="color: #0000ff;">if</span>(!<span style="color: #000000;">checkInventory(order))
</span><span style="color: #008080;">6</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">7</span> <span style="color: #008000;">//</span><span style="color: #008000;">订单逻辑代码不需要关注</span>
<span style="color: #008080;">8</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
</span><span style="color: #008080;">9</span> }</pre>
</div>
<p>请用上述的异步机制改写这段代码，减小这个方法的响应延迟。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">//</span><span style="color: #008000;">这里使用task</span>
<span style="color: #008080;"> 2</span> Task&lt;<span style="color: #0000ff;">bool</span>&gt; task = <span style="color: #0000ff;">new</span> Task&lt;<span style="color: #0000ff;">bool</span>&gt;(() =&gt;<span style="color: #000000;"> checkCustomerprice());
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">task.Start();
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">bool</span> result =<span style="color: #000000;"> task.Result;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> Task&lt;<span style="color: #0000ff;">bool</span>&gt; task2 = <span style="color: #0000ff;">new</span> Task&lt;<span style="color: #0000ff;">bool</span>&gt;(() =&gt;<span style="color: #000000;"> checkInventory());
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">task2.Start();
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">bool</span> result2 =<span style="color: #000000;"> task2.Result;
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #0000ff;">if</span>(result&amp;&amp;<span style="color: #000000;">result2)
</span><span style="color: #008080;">11</span>    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span> <span style="color: #0000ff;">else</span> 
<span style="color: #008080;">13</span>    <span style="color: #0000ff;">return</span>  <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> <span style="color: #008000;">//</span><span style="color: #008000;">自己研究写的，不知道对不对，仅供参考</span></pre>
</div>
<p>43.简述private,protected,public,internal修饰符的访问权限。</p>
<p>&nbsp; &nbsp;public(公共的) 完全公开，访问不受限制。</p>
<p>&nbsp;&nbsp; protected(保护的) 访问仅限于包含类或从包含类派生的类型。该类内部和继承类中可以访问。</p>
<p>&nbsp;&nbsp; internal(内部的) 访问仅限于当前程序集。在同一命名空间内可以访问。</p>
<p>&nbsp;&nbsp; protected internal(内部保护的) 访问仅限于从包含类派生的当前程序集或类型（<strong>待确定</strong>）。</p>
<p>&nbsp; &nbsp;private(私有的) 访问仅限于包含类型。在类的内部才可以访问</p>
<p>44.ado.net的五个主要对象。答案见第30题。</p>
<p>45.列举asp.net页面之间传值的几种方式。</p>
<p>答案：</p>
<pre><code>Request.Form["SourceData2"].ToString()；</pre>
<pre><code>Request.QueryString["parameter1"].ToString();</pre>
<pre><code> Context.Items["value"].ToString();还有cookie，session，application<br />46.C#中委托是什么？事件是不是一种委托？事件和委托的关系。<br />答案：委托是指向事件的一种函数指针，把事件转换为了一种引用类型的变量，可以让其他函数调用。（纯纯的个人理解，网上有不同答案，我也不知道哪个是对的，建议找出版的资料。）<br />47.override(重写)与重载overload的区别。<br />答案：override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法，<br />重载，一般是用于在一个类内实现若干重载的方法，这些方法的名称相同而参数形式不同。<br />48.MVC模式。（我并没有完全GET到这个考点）<br />答案：MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。<br />49.什么是装箱和拆箱？<br />答案：值类型转换为引用类型是装箱，引用类型装换为值类型是拆箱。<br />50.什么叫应用程序域AppDomain。<br />答案：&nbsp;"域",就是范围,环境,边界的意思,那么什么是应用程序域,官方给出的是这样的解释:操作系统和运行库环境通常会</pre>
<p>在应用程序间提供某种形式的隔离.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库宿主创建，</p>
<p>运行库宿主负责在运行应用程序之前引导公共语言运行库。</p>
<p>&nbsp; 应用程序域本质上就就是一种隔离,目的也就是使应用程序中运行的代码不能直接访问其他应用程序中的代码或资</p>
<p>源如果你需要访问其他应用程序中的对象时你就可以复制这些对象，或通过代理访问这些对象.</p>
<p>51.堆和栈的区别。</p>
<p>答案：heap：是由malloc之类函数分配的空间所在地。地址是由低向高增长的，引用类型储存在这。<br />stack：是自动分配变量，以及函数调用的时候所使用的一些空间。地址是由高向低减少的，值类型存储在这。<br />52.GC是什么，为什么要有GC？</p>
<p>答案;垃圾回收器，如果没有GC，那么一个系统随着运行时间的增长，占用内存会越来越大，如果我们没有主动释放的话。</p>
<p>53。值类型和引用类型的区别。</p>
<p>答案：</p>
<p style="margin-left: 30px;">1.&nbsp;&nbsp;&nbsp; 值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的<br />地址。</p>
<p style="margin-left: 30px;">2.&nbsp;&nbsp;&nbsp;&nbsp; 值类型存取速度快，引用类型存取速度慢。</p>
<p style="margin-left: 30px;">3.&nbsp;&nbsp;&nbsp;&nbsp; 值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用</p>
<p style="margin-left: 30px;">4.&nbsp;&nbsp;&nbsp;&nbsp; 值类型继承自System.ValueType，引用类型继承自System.Object</p>
<p style="margin-left: 30px;">5.&nbsp;&nbsp;&nbsp;&nbsp; 栈的内存分配是自动释放；而堆在.NET中会有GC来释放&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 值类型的变量直接存放实际的数据，而引用类型的变量存放的则是数据的地址，即对象的引用。<br />7.　值类型变量直接把变量的值保存在堆栈中，引用类型的变量把实际数据的地址保存在堆栈中，而实际数据则保存在堆中。</p>
<p>54.C#中的接口和类有什么异同。</p>
<p style="margin-left: 30px;">不同点：</p>
<p style="margin-left: 30px;">不能直接实例化接口。</p>
<p style="margin-left: 30px;">接口不包含方法的实现。</p>
<p style="margin-left: 30px;">接口可以多继承，类只能单继承。</p>
<p style="margin-left: 30px;">类定义可以在不同的源文件之间进行拆分。</p>
<p style="margin-left: 30px;">相同点：</p>
<p style="margin-left: 30px;">接口、类和结构都可以从多个接口继承。</p>
<p style="margin-left: 30px;">接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。</p>
<p style="margin-left: 30px;">接口和类都可以包含事件、索引器、属性。</p>
<p>54.try{}里有一个return语句，那么紧跟在这个try后面的finally{}里的code会不会被执行。什么时候执行？</p>
<p>答案；会，在return 之前执行。</p>
<p>55.描述线程与进程的区别。</p>
<p style="margin-left: 30px;">1.进程有自己独立的地址空间;而线程共享进程的地址空间；<br />2.一个程序至少有一个进程,一个进程至少有一个线程；<br /><br />3.线程是处理器调度的基本单位,但进程不是；<br /><br />4.二者均可并发执行</p>
<p>56.什么是反射？</p>
<p>答案：动态获取程序集信息，动态获取类的属性和方法。</p>
<p>57.什么是匿名方法？请写一段代码。</p>
<pre><code>delegate(int i) { return i &gt; 0; }</pre>
<p>58.写出几种工作流产品或框架，并简要的对比他们的差异。</p>
<p>59.写出你所了解的设计模式，说一说使用设计模式带来的好处，并尝试用代码写出一个例子。</p>
<p>60.接受一个数组，找出两个数的索引，这两个数组相加之和等于指定的数字。找出一组即可，同一元素不可使用两次。</p>
<p>比如：nums=[2,7,11,15],目标数字是9，因为nums【0】+nums【1】=9，所以返回【0,1】</p>
<p>答案：最简单的方法是使用两个for循环，此种方法不给出代码了，下面是第二种算法，需要先进行排序，排序算法略。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">int</span>[] getindex(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n)
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>,j=nums.length-<span style="color: #800080;">1</span>
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">while</span>(i&gt;<span style="color: #000000;">j)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">if</span>(nums[i]+nums[j]==n)<span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(nums[i]+nums[j]&gt;n)j--<span style="color: #000000;">;
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">else</span> i++<span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">}
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">int</span>[] a=<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[]{i,j}
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
</span><span style="color: #008080;">12</span> }</pre>
</div>
<p>61.<img src="./images/C# 面试题及答案1.png" alt="" /></p>
<pre><code>SELECT * FROM 表 /*数据源*/
AS P
PIVOT 
(
    SUM(Amount/*行转列后 列的值*/) FOR 
    p.Month/*需要行转列的列*/ IN (1,2,3,4/*列的值*/)
) AS T</pre>
<p>附注：列转行语句。测试语句</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">CREATE</span> <span style="color: #0000ff;">TABLE</span><span style="color: #000000;"> ProgrectDetail
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">(
</span><span style="color: #008080;"> 3</span>     ProgrectName         <span style="color: #0000ff;">NVARCHAR</span>(<span style="color: #800000; font-weight: bold;">20</span>), <span style="color: #008080;">--</span><span style="color: #008080;">工程名称</span>
<span style="color: #008080;"> 4</span>     OverseaSupply        <span style="color: #0000ff;">INT</span>,          <span style="color: #008080;">--</span><span style="color: #008080;">海外供应商供给数量</span>
<span style="color: #008080;"> 5</span>     NativeSupply         <span style="color: #0000ff;">INT</span>,          <span style="color: #008080;">--</span><span style="color: #008080;">国内供应商供给数量</span>
<span style="color: #008080;"> 6</span>     SouthSupply          <span style="color: #0000ff;">INT</span>,          <span style="color: #008080;">--</span><span style="color: #008080;">南方供应商供给数量</span>
<span style="color: #008080;"> 7</span>     NorthSupply          <span style="color: #0000ff;">INT</span>           <span style="color: #008080;">--</span><span style="color: #008080;">北方供应商供给数量</span>
<span style="color: #008080;"> 8</span> <span style="color: #000000;">)
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> <span style="color: #0000ff;">INSERT</span> <span style="color: #0000ff;">INTO</span><span style="color: #000000;"> ProgrectDetail
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">SELECT</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">A</span><span style="color: #ff0000;">'</span>, <span style="color: #800000; font-weight: bold;">100</span>, <span style="color: #800000; font-weight: bold;">200</span>, <span style="color: #800000; font-weight: bold;">50</span>, <span style="color: #800000; font-weight: bold;">50</span>
<span style="color: #008080;">12</span> <span style="color: #0000ff;">UNION</span> <span style="color: #808080;">ALL</span>
<span style="color: #008080;">13</span> <span style="color: #0000ff;">SELECT</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">B</span><span style="color: #ff0000;">'</span>, <span style="color: #800000; font-weight: bold;">200</span>, <span style="color: #800000; font-weight: bold;">300</span>, <span style="color: #800000; font-weight: bold;">150</span>, <span style="color: #800000; font-weight: bold;">150</span>
<span style="color: #008080;">14</span> <span style="color: #0000ff;">UNION</span> <span style="color: #808080;">ALL</span>
<span style="color: #008080;">15</span> <span style="color: #0000ff;">SELECT</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">C</span><span style="color: #ff0000;">'</span>, <span style="color: #800000; font-weight: bold;">159</span>, <span style="color: #800000; font-weight: bold;">400</span>, <span style="color: #800000; font-weight: bold;">20</span>, <span style="color: #800000; font-weight: bold;">320</span>
<span style="color: #008080;">16</span> <span style="color: #0000ff;">UNION</span> <span style="color: #808080;">ALL</span></pre>
</div>
<p><img src="./images/C# 面试题及答案2.png" alt="" /></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">SELECT</span><span style="color: #000000;"> P.ProgrectName,P.Supplier,P.SupplyNum
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">FROM</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;">(
</span><span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">SELECT</span><span style="color: #000000;"> ProgrectName, OverseaSupply, NativeSupply,
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">           SouthSupply, NorthSupply
</span><span style="color: #008080;"> 6</span>      <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> ProgrectDetail
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">)T
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">UNPIVOT 
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">(
</span><span style="color: #008080;">10</span>     SupplyNum <span style="color: #0000ff;">FOR</span> Supplier <span style="color: #808080;">IN</span>
<span style="color: #008080;">11</span> <span style="color: #000000;">    (OverseaSupply, NativeSupply, SouthSupply, NorthSupply )
</span><span style="color: #008080;">12</span> ) P</pre>
</div>
<p>执行结果：</p>
<p><img src="./images/C# 面试题及答案3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;62.<strong>描述new有两种用法</strong></p>
<p align="left">第一种:new Class():创建对象</p>
<p align="left">第二种:覆盖方法</p>
<p align="left">public new XXXX(){}</p>
<p align="left">63.<strong>传入某个属性的set方法的隐含参数的名称是什么？</strong></p>
<p align="left">value，它的类型和属性所声名的类型相同。</p>
<p align="left">64.<strong>下面的代码中有什么错误吗？<span lang="EN-US">_______</span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">using</span><span style="color: #000000;"> System;
</span><span style="color: #008080;"> 2</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> A
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 4</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> F(){
</span><span style="color: #008080;"> 5</span> Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">A.F</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> B:A
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">{
</span><span style="color: #008080;">10</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> F();
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span> <span style="color: #008000;">//</span><span style="color: #008000;">答：abstract override 是不可以一起修饰. </span>
<span style="color: #008080;">13</span> } <span style="color: #008000;">//</span><span style="color: #008000;"> new public abstract void F();</span></pre>
</div>
<p>65.<strong><span lang="EN-US">net的错误处理机制是什么？</span></strong><span lang="EN-US"><br />
答：<span lang="EN-US">.net错误处理机制采用<span lang="EN-US">try-&gt;catch-&gt;finally结构，发生错误时，层层上抛，直到找到匹配的<span lang="EN-US">Catch为止。</span></span></span></span></p>
<p>66.<strong>如何在C#中实现继承？也就是继承的格式</strong></p>
<p>在类名后加上一个冒号，再加上基类的名称。</p>
<p>67.<strong>描述一下<span lang="EN-US">C#中索引器的实现过程，是否只能根据数字进行索引？</span></strong><span lang="EN-US"> <br />
答：不是。可以用任意类型.<a href="https://www.cnblogs.com/yaoxiaodan/p/5295132.html" target="_blank">https://www.cnblogs.com/yaoxiaodan/p/5295132.html</a></span></p>
<p><span lang="EN-US">68.</span><strong>私有成员会被继承么？</strong></p>
<p><span lang="EN-US">会，但是不能被访问。所以看上去他们似乎是不能被继承的，但实际上确实被继承了.</span></p>
<p><span lang="EN-US">69.</span><strong>C#</strong><strong>中所有对象共同的基类是什么？</strong></p>
<p><span lang="EN-US">System.Object</span></p>
<p><span lang="EN-US">70.</span><strong>在方法定义中，virtual有什么含意？</strong></p>
<p><span lang="EN-US">被virtual修饰的方法可以被子类覆写.</span></p>
<p><span lang="EN-US">71.</span><strong>能够将非静态的方法覆写成静态方法么？</strong></p>
<p><span lang="EN-US">不能，覆写方法的签名必须与被覆写方法的签名保持一致，除了将virtual改为override</span></p>
<p><span lang="EN-US">72.</span><strong>可以覆写私有的虚方法么？</strong></p>
<p><span lang="EN-US">不可以，甚至子类中无法访问父类中的私有方法</span></p>
<p><span lang="EN-US">73.</span><strong>什么是抽象类（abstract class）？</strong></p>
<p><span lang="EN-US">一种不可以被实例化的类。抽象类中一般含有抽象方法，当然也可有具体实现。继承类只有实现过所有抽象类的抽象方法后才能被实例化.</span></p>
<p><span lang="EN-US">74.</span><strong>接口（interface）是什么？</strong></p>
<p><span lang="EN-US">只含有公有抽象方法（public abstract method）的类。这些方法必须在子类中被实现.</span></p>
<p><span lang="EN-US">75.<strong>接口是否可继承接口<span lang="EN-US">? 抽象类是否可实现<span lang="EN-US">(implements)接口<span lang="EN-US">? 抽象类是否可继承实体类<span lang="EN-US">(concrete class)?</span></span></span></span></strong><span lang="EN-US"><br />
答：接口可以继承接口。抽象类可以实现<span lang="EN-US">(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。</span></span></span></p>
<p><span lang="EN-US">76.<strong>构造器<span lang="EN-US">Constructor是否可被<span lang="EN-US">override?</span></span></strong><span lang="EN-US"><br />
答：构造器<span lang="EN-US">Constructor不能被继承，因此不能重写<span lang="EN-US">Overriding，但可以被重载<span lang="EN-US">Overloading。</span></span></span></span></span></p>
<p><span lang="EN-US">77.<strong>是否可以继承<span lang="EN-US">String类<span lang="EN-US">?</span></span></strong><span lang="EN-US"><br />
答：<span lang="EN-US">String类是<span lang="EN-US">final类故不可以继承.</span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">78.<strong>数组有没有<span lang="EN-US">length()这个方法<span lang="EN-US">? String有没有<span lang="EN-US">length()这个方法？</span></span></span></strong><span lang="EN-US"><br />
答：数组没有<span lang="EN-US">length()这个方法，有<span lang="EN-US">length的属性。<span lang="EN-US">String有<span lang="EN-US">length()这个方法（查网上资料说有个方法，但个人实验了一下是没有的，只有Length属性）.</span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">79.<strong>成员变量和成员函数前加<span lang="EN-US">static的作用？</span></strong><span lang="EN-US"><br />
答：它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。</span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">80.<strong>在<span lang="EN-US">c#中<span lang="EN-US">using和<span lang="EN-US">new这两个关键字有什么意义，请写出你所知道的意义？<span lang="EN-US">using 指令 和语句<span lang="EN-US"> new 创建实例<span lang="EN-US"> new 隐藏基类中方法。</span></span></span></span></span></span></strong><span lang="EN-US"><br />
答：<span lang="EN-US">using 引入名称空间或者使用非托管资源<span lang="EN-US"><br />
new 新建实例或者隐藏父类方法</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">81.<strong>什么是虚函数？什么是抽象函数？</strong><span lang="EN-US"><br />
答：虚函数：没有实现的，可由子类继承并重写的函数。抽象函数：规定其非虚子类必须实现的函数，必须被重写。</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">82.<strong><span lang="EN-US">c#中的三元运算符是？</span></strong><span lang="EN-US"><br />
答：？：</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">83.<strong><span lang="EN-US">public static const int A=1;这段代码有错误么？是什么？</span></strong><span lang="EN-US"><br />
答：<span lang="EN-US">const不能用<span lang="EN-US">static修饰。</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">84.Ref参数是引用调用，out参数是输入调用。</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">85.</span></span></span></span></span></span></span></span></span></span></span></span></span><strong>const</strong><strong>和</strong><strong>readonly</strong><strong>有什么区别？</strong></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">const可以用于局部常量，而readonly实际是类的initonly字段，显然不能是局部的，const是编译时常量，readonly是运行时常量。</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">86.</span></span></span></span></span></span></span></span></span></span></span></span></span><strong>虚函数的用法：</strong></p>
<p>答：<span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">1)virtual指明一成员函数为虚函数,而virtual仅用于类的定义里,在类外可不加此关键字.&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">
2)</span></span></span></span></span></span></span></span></span></span></span></span></span><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">一个类的成员函数被定义为虚函数时,子类该函数仍保持虚函数特征. </span></span></span></span></span></span></span></span></span></span></span></span></span><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><br />
3)子类覆盖此函数时,定义里可不加virtual关键字,但函数声明要和基类的完全一致!且此声明是必须的. <br />
4)不是纯虚函数时,父类的虚函数必须要实现; 而若将父类的虚函数设定为纯虚函数时,子类必需要覆盖之而且必须要实现之!</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><em><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">87.</span></span></span></span></span></span></span></span></span></span></span></span></span></em><strong>解释</strong><strong>virtual</strong><strong>、</strong><strong>sealed</strong><strong>、</strong><strong>override</strong><strong>和</strong><strong>abstract</strong><strong>的区别</strong></p>
<p>virtual申明虚方法的关键字，说明该方法可以被重写</p>
<p>sealed说明该类不可被继承</p>
<p>override重写基类的方法</p>
<p><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">abstract申明</span></span></span></span></span></span></span></span></span></span></span></span></span><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化</span></span></span></span></span></span></span></span></span></span></span></span></span><em><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">。</span></span></span></span></span></span></span></span></span></span></span></span></span></em></p>
<p><em><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US"><span lang="EN-US">88.</span></span></span></span></span></span></span></span></span></span></span></span></span></em>对象和类的区别是什么？</p>
<p>答：&ldquo;类&rdquo;（Class）具有相同属性和方法的一组对象的集合. 类是抽象的概念，仅仅是模板</p>
<p>对象是一个你能够看得到、摸得着的具体实体。</p>
<p>89.什么是局部变量，什么是成员变量？</p>
<p>答：局部变量是指一个方法中定义的变量；成员变量是指在类范围里定义的变量，也就是之前讲过的属性。</p>
<p>90.静态成员和实例成员的区别？</p>
<p>答：使用static修饰的成员称为静态成员，使用实例对象调用的成员称为实例成员</p>
<p>&nbsp;<img src="./images/C# 面试题及答案4.png" alt="" /></p>
<p>91.概述序列化</p>
<p>答: 序列化是将对象的状态存储到特定存储介质中的过程。</p>
<p>反序列化则是从特定存储介质中的数据重新构建对象的过程</p>
<p>&nbsp;92.对象能否调用静态方法 ？</p>
<p>答：不能。对于类内部定义的静态变量及静态方法，该类的对象均不能调用。</p>
<p>93为什么不能指定接口中方法的修饰符？</p>
<p>答：接口中的方法用来定义对象之间通信的契约，指定接口中的方法为私有或保护没有意义。他们默认为公有方法。</p>
<p>94.请详述在.net中类(class)与结构(struct)的异同：</p>
<p>答：Class可以被实例化,属于引用类型,是分配在内存的堆上的,Struct属于值类型,是分配在内存的栈上的</p>
<p>95.接口和抽象类具有什么区别?</p>
<p>答：含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型</p>
<p>下面比较一下两者的语法区别：</p>
<p>1. 抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>2. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
<p>3. 抽象类中抽象方法可以指定为public，接口中抽象方法不能指定任何修饰符，默认就是public</p>
<p>4. 一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p>96.base关键字的作用是什么？</p>
<p>答：子类继承父类的过程中，可能需要在子类中调用父类中的成员，如属性、方法或者构造方法。这个时候，可以使用base关键字来完成。base的作用是用于引用父类的成员，如属性、方法或者是构造方法</p>
<p>97.什么是抽象类？</p>
<p>答：抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。</p>
<p>98.接口和抽象类两者在应用上的区别：</p>
<p>答：接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用</p>
<p>99.面向对象的特征有哪些方面？</p>
<p>答：面向对象的编程语言有封装、继承 、抽象、多态等4个主要的特征。</p>
<p>封装：</p>
<p>封装的目标就是要实现软件部件的&ldquo;高内聚、低耦合&rdquo;，防止程序相互依赖性而带来的变动影响。</p>
<p>抽象：</p>
<p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类</p>
<p>继承：</p>
<p>子类继承父类成员，实现代码复用，提高了软件的可重用性和可扩展性。</p>
<p>多态：</p>
<p>不同子类对同一个消息作出不同的反映,提高软件灵活性</p>
<p>100.在C＃中，string str=null string str= string.Empty与string str=&ldquo;&rdquo;请尽量使用文字或图象说明其中的区别。</p>
<p>答: string.Empty：不分配存储空间。""：分配一个长度为空的存储空间，""和String.Empty，这两个都是表示空字符串，空字符串是一个特殊的字符串，只不过这个字符串的值为空，在内存中是有准确的指向的。</p>
<p>101.Params是什么含义？</p>
<p>答：Params是C#中的关键字,采用此关键字可以指定参数数目为可变；在方法声明中的params关键字之后不允许任何其他参数，并且在方法声明中只允许一个params关键字。</p>
<p>102.float f=-123.567F; int i=(int)f;i的值现在是_____? 答：-123</p>
<p>103.C#中 property(属性) 与 attribute(特性)的区别，他们各有什么用处，这种机制的好处在哪里？</p>
<p>答：属性：用于存取类的字段。特性：用来标识类，方法等的附加性质。</p>
<p>attribute:自定义属性的基类;property :类中的属性。</p>
<p>104.</p>



</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>