<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修.Neter所应该彻底了解的委托' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>.Neter所应该彻底了解的委托</center></div><div class='banquan'>原文出处:本文由博客园博主RyzenAdorer提供。<br/>
原文连接:https://www.cnblogs.com/ryzen/p/12009602.html</div><br>
    <p>&nbsp;</p>
<p>本文将通过引出几个问题来,并且通过例子来剖析C#中的委托以及用法，做抛砖引玉的作用</p>
<p>对于委托我发现大部分人都有以下问题，或者可能在面试中遇过这样的：</p>
<ul>
<li><strong>委托是不是相当于C/C++的函数指针?</strong></li>
<li><strong>委托究竟是什么？</strong></li>
<li><strong>委托究竟是用来干嘛的？</strong></li>
<li><strong>委托跟匿名函数的区别？</strong></li>
<li><strong>委托与事件的关系?</strong></li>
</ul>
<p><br />我们先来声明和使用C++的函数指针：<br />代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 16px;">#include &lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

typedef </span><span style="color: #0000ff;">int</span> (*Foohandle)(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b);

</span><span style="color: #0000ff;">int</span> fooMenthod(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> (*foohandle1)(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b)) <span style="color: #008000;">//</span><span style="color: #008000;">回调函数</span>
<span style="color: #000000;">{
</span><span style="color: #0000ff;">  return</span> a + (*foohandle1)(<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>);<span style="color: #008000;">//</span><span style="color: #008000;">也可以写成foohandle1(2,3)</span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">int</span> add(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
</span><span style="color: #0000ff;">  return</span> a +<span style="color: #000000;"> b;
}

</span><span style="color: #0000ff;">int</span> multiply(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
</span><span style="color: #0000ff;">  return</span> a *<span style="color: #000000;"> b;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
 Foohandle foohandle </span>=<span style="color: #000000;"> add;
</span><span style="color: #0000ff;"> int</span> (*foohandle1)(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) = &amp;<span style="color: #000000;">add;
 cout </span>&lt;&lt; foohandle(<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>)&lt;&lt;<span style="color: #000000;">endl;
 cout </span>&lt;&lt; foohandle1(<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>) &lt;&lt;<span style="color: #000000;"> endl;
 cout </span>&lt;&lt; typeid(Foohandle).name() &lt;&lt;<span style="color: #000000;"> endl;
 cout </span>&lt;&lt; typeid(foohandle).name()&lt;&lt;<span style="color: #000000;">endl;
 cout </span>&lt;&lt; typeid(foohandle1).name() &lt;&lt;<span style="color: #000000;"> endl;
 cout </span>&lt;&lt; fooMenthod(<span style="color: #800080;">2</span>, add)&lt;&lt;<span style="color: #000000;">endl;
 cout </span>&lt;&lt; fooMenthod(<span style="color: #800080;">2</span><span style="color: #000000;">, multiply);
}</span></span></pre>
</div>
<p>输出结果如下：</p>
<p><img style="float: left;" src="./images/.Neter所应该彻底了解的委托0.png" alt="" width="250" height="150" /></p>
<p style="text-align: left;">&nbsp; &nbsp; &nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp; &nbsp; 在代码中，我声明定义了两个函数add和multiply，然后用typedef方式声明了函数指针，接着我分别将add赋值给<strong>Foohandle</strong>这种<strong>函数指针类型</strong>的<strong>foohandle</strong>变量，然后用&amp;add这种解地址的方式赋值给一个返回值为int，且带有两个参数的函数指针<strong>foohandle1</strong>，其中<strong>(*foohandle1)</strong>是函数名，最后我输出发现它们类型和输出都是一致的，再后面，我们定义了一个fooMenthod函数，返回值是int，且其中一个参数是函数指针，那么我再最后调用两次，分别将add和multiply函数，赋值给它，这时候add和multiply就是fooMenthod函数的回调函数，且此时输出结果会被两个函数内部不同实现所影响<br />那么我们可以做个总结：</p>
<ul>
<li>首先函数指针就是一个内存地址，指向函数的入口内存地址</li>
<li>当函数指针做一个函数的参数时，确实会起到一定解耦作用</li>
<li>函数指针很明显是类型不安全的</li>



















</ul>
<p>我们再来声明和使用委托：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">int</span> Foohandle(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
{
</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
{
 Foohandle foohandle </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Foohandle(add);
 Console.WriteLine(foohandle(</span><span style="color: #800080;">2</span>, <span style="color: #800080;">3</span><span style="color: #000000;">));
 Console.WriteLine(foohandle.GetType().Name);
 Console.WriteLine(fooMenthod(</span><span style="color: #800080;">2</span><span style="color: #000000;">, add));
 Console.WriteLine(fooMenthod(</span><span style="color: #800080;">2</span><span style="color: #000000;">, multiply));
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">foohandle所调用函数函数名:{foohandle.Method.Name}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">foohandle所调用函数的返回值类型{foohandle.Method.ReturnType.ToString()}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">foohandle所调用函数参数类型以及参数名分别为:</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Type:{foohandle.Method.GetParameters()[0].ParameterType},Name:{foohandle.Method.GetParameters()[0].Name}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Type:{foohandle.Method.GetParameters()[1].ParameterType},Name:{foohandle.Method.GetParameters()[1].Name}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.Read();
}

</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> fooMenthod(<span style="color: #0000ff;">int</span> a, Foohandle foohandle) <span style="color: #008000;">//</span><span style="color: #008000;">传给参数函数的就是回调函数</span>
<span style="color: #000000;">{
</span><span style="color: #0000ff;"> return</span> a + foohandle(<span style="color: #800080;">2</span>, <span style="color: #800080;">3</span><span style="color: #000000;">);
}

</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
{
</span><span style="color: #0000ff;"> return</span> a +<span style="color: #000000;"> b;
}

</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> multiply(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
{
</span><span style="color: #0000ff;"> return</span> a *<span style="color: #000000;"> b;
}
}</span></pre>
</div>
<p>输出结果：</p>
<p><img style="float: left;" src="./images/.Neter所应该彻底了解的委托1.png" alt="" /></p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; 很明显，不管是声明和使用方式，都和c++那边一样，就连输出结果也差不多，但是很有意思的是，foohandle的类型是Foohandle，且我居然能从foohandle输出所调函数的一切信息，包括函数名，返回值，参数类型和参数名，而且和c++那边不同的是，我们没有直接操作内存地址，好像看起来是安全的？那么Foohandle类型又是什么？</p>
<h2>委托是啥？</h2>
<p>先来个例子：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> DelegateSample
{

</span><span style="color: #0000ff;">  public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> FooHandle(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value);<br />
</span><span style="color: #0000ff;">  class</span><span style="color: #000000;"> Program
  {
</span><span style="color: #0000ff;">     static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
     {
        FooHandle fooHandle </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FooHandle(multiply);
        fooHandle(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
        Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">fooHandle.Target:{fooHandle.Target},fooHandle.Method:{fooHandle.Method},fooHandle.InvocationListCount:{fooHandle.GetInvocationList().Count()}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">-----------------------------------------------------------------------------------------------------------------------------------</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        FooHandle fooHandle1 </span>= <span style="color: #0000ff;">new</span> FooHandle(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Foo().Add);
        fooHandle1.Invoke(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
        Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">fooHandle1.Target:{fooHandle1.Target},fooHandle1.Method:{fooHandle1.Method},fooHandle1.InvocationListCount:{fooHandle1.GetInvocationList().Count()}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Console.Read();
     }

</span><span style="color: #0000ff;">     static</span> <span style="color: #0000ff;">void</span> multiply(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a)
     {
        Console.WriteLine(a</span>*<span style="color: #800080;">2</span><span style="color: #000000;">);
     }
    }

</span><span style="color: #0000ff;">   public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Foo
   {
</span><span style="color: #0000ff;">      public</span> <span style="color: #0000ff;">void</span> Add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value)
      {  
        Console.WriteLine(value </span>+ <span style="color: #800080;">2</span><span style="color: #000000;">);
      }
   }
}</span></pre>
</div>
<p>我们看看输出的结果：</p>
<p><img src="./images/.Neter所应该彻底了解的委托2.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp;很明显，这里是一个最简单的委托声明，实例化初始化一个委托对象，然后调用的最简单的场景<br />&nbsp; &nbsp; &nbsp;我们不关注输出的第一行，很明显，对象实例化后，可以访问其中的三个公开public的函数成员，<br />分别是Target(object类型),Method(MethodInfo类型)，而GetInvocationList函数是一个返回值为一个Delegate[]的无参函数<br />&nbsp; &nbsp; &nbsp;在上面代码，其实我还特地将委托FooHandle声明在Program类外面，其实在这里我们已经知道委托是什么了，实例化对象，且能够声明在类外面，其实它本质就是一个类，我们通过反编译来验证：</p>
<p><img style="float: left;" src="./images/.Neter所应该彻底了解的委托3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>大概是这样，伪代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> FooHandle: MulticastDelegate
{
</span><span style="color: #0000ff;">  public</span> FooHandle(<span style="color: #0000ff;">object</span> @object,IntPtr menthod);<span style="color: #008000;">//</span><span style="color: #008000;">构造方法</span>

<span style="color: #0000ff;">  void</span> Invoke(<span style="color: #0000ff;">int</span> value)<span style="color: #008000;">//</span><span style="color: #008000;">调用委托，编译后公共语言运行时给delegate提供的特殊方法</span>

<span style="color: #0000ff;">  void</span> EndInvoke(System.IAsyncResult asyncResult)<span style="color: #008000;">//</span><span style="color: #008000;"> 编译后公共语言运行时给MulticastDelegate提供的特殊方法

</span><span style="color: #008000;">  //</span><span style="color: #008000;"> 编译后公共语言运行时给MulticastDelegate提供的特殊方法</span>
<span style="color: #0000ff;">  void</span> BeginInvoke(<span style="color: #0000ff;">int</span> value,System.AsyncCallback callback, <span style="color: #0000ff;">object</span><span style="color: #000000;"> obj) 
}</span></span></pre>
</div>
<p>&nbsp;</p>
<p>我们可以看编译后FooHandle就是一个类，且继承MulticastDelegate，且继承链关系在msdn是这样的：</p>
<p><img style="float: left;" src="./images/.Neter所应该彻底了解的委托4.png" alt="" /><br /><br />&nbsp; &nbsp; </p>
<p>&nbsp; &nbsp; </p>
<p>&nbsp; &nbsp; 且我们发现上面公开的三个函数成员都来自于Delegate类，且编译后生成了几个公共运行时提供的特殊方法，Invoke方法我们很清楚，是来调用委托的，我们先来看看委托初始化后的情况，通过查看Delegate的源码，我们发现Delegate有两个构造函数：</p>
<p>1.委托对象初始化构造函数是实例函数：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #000000;">[SecuritySafeCritical]
</span><span style="color: #0000ff;">protected</span> Delegate(<span style="color: #0000ff;">object</span> target, <span style="color: #0000ff;">string</span><span style="color: #000000;"> method)
{
</span><span style="color: #0000ff;">  if</span> (target == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentNullException(<span style="color: #800000;">"</span><span style="color: #800000;">target</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  }
</span><span style="color: #0000ff;">  if</span> (method == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentNullException(<span style="color: #800000;">"</span><span style="color: #800000;">method</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  }
</span><span style="color: #0000ff;">  if</span> (!BindToMethodName(target, (RuntimeType)target.GetType(), method, (DelegateBindingFlags)<span style="color: #800080;">10</span><span style="color: #000000;">))
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentException(Environment.GetResourceString(<span style="color: #800000;">"</span><span style="color: #800000;">Arg_DlgtTargMeth</span><span style="color: #800000;">"</span></span><span style="color: #000000;"><span style="font-size: 14px;">));
  }
}</span> </span></pre>
</div>
<p>&nbsp;</p>
<p>2.委托对象初始化构造函数是静态函数：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #000000;">[SecuritySafeCritical]
</span><span style="color: #0000ff;">protected</span> Delegate(Type target, <span style="color: #0000ff;">string</span><span style="color: #000000;"> method)
{
</span><span style="color: #0000ff;">  if</span> (target == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentNullException(<span style="color: #800000;">"</span><span style="color: #800000;">target</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  }
</span><span style="color: #0000ff;">  if</span> (target.IsGenericType &amp;&amp;<span style="color: #000000;"> target.ContainsGenericParameters)
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentException(Environment.GetResourceString(<span style="color: #800000;">"</span><span style="color: #800000;">Arg_UnboundGenParam</span><span style="color: #800000;">"</span>), <span style="color: #800000;">"</span><span style="color: #800000;">target</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  }
</span><span style="color: #0000ff;">  if</span> (method == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentNullException(<span style="color: #800000;">"</span><span style="color: #800000;">method</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  }
  RuntimeType runtimeType </span>= target <span style="color: #0000ff;">as</span><span style="color: #000000;"> RuntimeType;
</span><span style="color: #0000ff;">  if</span> (runtimeType == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
  {
</span><span style="color: #0000ff;">    throw</span> <span style="color: #0000ff;">new</span> ArgumentException(Environment.GetResourceString(<span style="color: #800000;">"</span><span style="color: #800000;">Argument_MustBeRuntimeType</span><span style="color: #800000;">"</span>), <span style="color: #800000;">"</span><span style="color: #800000;">target</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  }
  BindToMethodName(</span><span style="color: #0000ff;">null</span>, runtimeType, method, (DelegateBindingFlags)<span style="color: #800080;">37</span><span style="color: #000000;">);
}</span></span></pre>
</div>
<p>最后共同调用的方法：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008000;">//</span><span style="color: #008000;">调用CLR的内部代码</span>
<span style="color: #000000;">[MethodImpl(MethodImplOptions.InternalCall)]
[SecurityCritical]
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">bool</span> BindToMethodName(<span style="color: #0000ff;">object</span> target, RuntimeType methodType, <span style="color: #0000ff;">string</span> method, DelegateBindingFlags flags);</span></pre>
</div>
<p>&nbsp; &nbsp; 虽然我们看不到BindToMethodName方法的实现，已经很明显了，委托对象初始化构造函数是静态函数传参进去BindToMethodName的第一个object的target参数为null，那我们大概把之前的伪代码的构造函数这么实现了：</p>
<p>伪代码部分：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #0000ff;">internal</span> <span style="color: #0000ff;">object</span> _target<span style="color: #008000;">//</span><span style="color: #008000;">目标对象;</span>
<span style="color: #0000ff;">internal</span> IntPtr _methodPtr<span style="color: #008000;">//</span><span style="color: #008000;">目标方法;</span>
<span style="color: #0000ff;">internal</span> IntPtr _methodPtrAux<span style="color: #008000;">//</span><span style="color: #008000;">用来判断Target是否为空;

</span><span style="color: #008000;">//</span><span style="color: #008000;">foolHandle的构造方法实现：</span>
<span style="color: #0000ff;">public</span> FooHandle(<span style="color: #0000ff;">object</span><span style="color: #000000;"> @object,IntPtr menthod)
{
  _methodPtr</span>=menthod;<span style="color: #008000;">//</span><span style="color: #008000;">multiply</span>
  _methodPtrAux=<span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">只要不等于nul</span>
<span style="color: #000000;">
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">foolHandle1的构造方法实现：</span>
<span style="color: #0000ff;">public</span> FooHandle(<span style="color: #0000ff;">object</span><span style="color: #000000;"> @object,IntPtr menthod)
{
  _methodPtr</span>=menthod<span style="color: #008000;">//</span><span style="color: #008000;">Add</span>
  _methodPtrAux=<span style="color: #800080;">0</span><span style="color: #008000;">//</span><span style="color: #008000;">为null</span>
  _target=<span style="color: #000000;">foo;

}</span></span></pre>
</div>
<p>&nbsp;</p>
<p>Delegate Target属性源代码部分：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #000000;">[__DynamicallyInvokable]
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">object</span><span style="color: #000000;"> Target
{
  [__DynamicallyInvokable]
</span><span style="color: #0000ff;">  get</span><span style="color: #000000;">
  {
</span><span style="color: #0000ff;">    return</span><span style="color: #000000;"> GetTarget();
  }
}

[SecuritySafeCritical]
</span><span style="color: #0000ff;">internal</span> <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">object</span><span style="color: #000000;"> GetTarget()
{
</span><span style="color: #0000ff;">  if</span> (!<span style="color: #000000;">_methodPtrAux.IsNull())
  {
</span><span style="color: #0000ff;">    return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
  }
</span><span style="color: #0000ff;">  return</span><span style="color: #000000;"> _target;
}</span></span></pre>
</div>
<p>&nbsp; &nbsp; 而获取Method的方法就不展开了，就是通过反射来获取，那我们已经知道Target和Method属性究竟是怎么回事了，我们还发现没讲到GetInvocationList方法是怎么回事？我们知道委托是支持多播委托的，也就是大概这样，修改上述代码为：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #0000ff;">namespace</span><span style="color: #000000;"> DelegateSample
{
</span><span style="color: #0000ff;">   public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> FooHandle(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value);<br />
</span><span style="color: #0000ff;">   class</span><span style="color: #000000;"> Program
   {
</span><span style="color: #0000ff;">      static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
      {
        FooHandle fooHandle </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> FooHandle(multiply);
        fooHandle(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
        Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">fooHandle.Target:{fooHandle.Target},fooHandle.Method:{fooHandle.Method},fooHandle.InvocationListCount:{fooHandle.GetInvocationList().Count()}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">----------------------------------------------------------------------------------------------------------------</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        FooHandle fooHandle1 </span>= <span style="color: #0000ff;">new</span> FooHandle(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Foo().Add);
        fooHandle1.Invoke(</span><span style="color: #800080;">3</span><span style="color: #000000;">);
        Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">fooHandle1.Target:{fooHandle1.Target},fooHandle1.Method:{fooHandle1.Method},fooHandle1.InvocationListCount:{fooHandle1.GetInvocationList().Count()}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        Console.WriteLine();

</span>
    <span style="color: #ff0000;">    <strong>Console.WriteLine("--------------------------------------------------新增代码------------------------------------------------------");
        FooHandle fooHandle2 = new FooHandle(new Program().Minus);
        Console.WriteLine($"fooHandle2.Target:{fooHandle2.Target},fooHandle1.Method:{fooHandle2.Method},fooHandle1.InvocationListCount:{fooHandle2.GetInvocationList().Count()}");
        fooHandle2(2);
        Console.WriteLine("----------------------------------------------------------------------------------------------------------------");
        FooHandle fooHandle3 = null;
        fooHandle3 += fooHandle;
        fooHandle3 =(FooHandle)Delegate.Combine(fooHandle3,fooHandle1);//相当于fooHandle3+=fooHandle1；
        fooHandle3 += new Program().Minus;
        Console.WriteLine($"fooHandle3.Target:{fooHandle3.Target},fooHandle3.Method:{fooHandle3.Method},fooHandle3.InvocationListCount:{fooHandle3.GetInvocationList().Count()}");
        fooHandle3(2);
        foreach (var result in fooHandle3.GetInvocationList())
        {
           Console.WriteLine($"result.Target:{result.Target},result.Method:{result.Method},result.InvocationListCount:{result.GetInvocationList().Count()}"</strong></span><span style="color: #000000;"><span style="color: #ff0000;"><strong>);
        } 
        Console.Read();</strong></span>
    }

</span>
<strong><span style="color: #ff0000;">   private void Minus(int a)
   {
     Console.WriteLine(a-1);
   }

</span></strong><span style="color: #0000ff;">   static</span> <span style="color: #0000ff;">void</span> multiply(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a)
   {
     Console.WriteLine(a </span>* <span style="color: #800080;">2</span><span style="color: #000000;">);
   }
 }

</span><span style="color: #0000ff;"> public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Foo
 {
</span><span style="color: #0000ff;">    public</span> <span style="color: #0000ff;">void</span> Add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value)
    {
       Console.WriteLine(value </span>+ <span style="color: #800080;">2</span><span style="color: #000000;">);
    }
 }
}</span></span></pre>
</div>
<p>输出结果是：</p>
<p><img src="./images/.Neter所应该彻底了解的委托5.png" alt="" /></p>
<p>&nbsp; &nbsp; 上面新增的代码，我声明了一个新的委托变量fooHandle3初始化为null，接着分别用三种不同的方式将委托或者函数加给fooHandle，之后输出后相当于分别按序调用输出了三个方法，而我们遍历其中的fooHandle3.GetInvocationList()委托数组，输出的也确实三个方法，但是注意到了没，我在<strong>fooHandle3 += new Program().Minus</strong>这段确实没有声明一个委托变量，我们可以注意到其中的<strong>(FooHandle)Delegate.Combine(fooHandle3,fooHandle1)</strong>这句，Combine很明显是需要两个委托变量的，查看编译后的代码我们可以得知到底发生了啥？<br />Il关键代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #008000;">//</span><span style="color: #008000;">fooHandle3 += fooHandle</span>
IL_00f7: call <span style="color: #0000ff;">class</span> [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(<span style="color: #0000ff;">class</span><span style="color: #000000;"> [mscorlib]System.Delegate,
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> [mscorlib]System.Delegate)
IL_00fc: castclass DelegateSample.FooHandle
IL_0101: stloc.</span><span style="color: #800080;">3</span><span style="color: #000000;">
IL_0102: ldloc.</span><span style="color: #800080;">3</span><span style="color: #000000;">
IL_0103: ldloc.</span><span style="color: #800080;">1</span>
<span style="color: #008000;">//</span><span style="color: #008000;">fooHandle3 =(FooHandle)Delegate.Combine(fooHandle3,fooHandle1)</span>
IL_0104: call <span style="color: #0000ff;">class</span> [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(<span style="color: #0000ff;">class</span><span style="color: #000000;"> [mscorlib]System.Delegate,
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> [mscorlib]System.Delegate)
IL_0109: castclass DelegateSample.FooHandle
IL_010e: stloc.</span><span style="color: #800080;">3</span><span style="color: #000000;">
IL_010f: ldloc.</span><span style="color: #800080;">3</span>
<span style="color: #008000;">//</span><span style="color: #008000;">new Program()</span>
IL_0110: newobj instance <span style="color: #0000ff;">void</span><span style="color: #000000;"> DelegateSample.Program::.ctor()
IL_0115: ldftn instance </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> DelegateSample.Program::Minus(int32)
</span><span style="color: #008000;">//</span><span style="color: #008000;">new FooHandle()新增了一个FooHandle委托变量</span>
IL_011b: newobj instance <span style="color: #0000ff;">void</span> DelegateSample.FooHandle::.ctor(<span style="color: #0000ff;">object</span><span style="color: #000000;">,
native </span><span style="color: #0000ff;">int</span><span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">fooHandle3 += new Program().Minus </span>
IL_0120: call <span style="color: #0000ff;">class</span> [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(<span style="color: #0000ff;">class</span><span style="color: #000000;"> [mscorlib]System.Delegate,
</span><span style="color: #0000ff;">class</span> [mscorlib]System.Delegate)</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp;也就是三种不同方式都会被翻译为Combine方法，如果是直接+=函数这种情况,后台也会new一个委托变量，将方法赋值给该变量再加到fooHandle3，那么我们可以知道，最关键的核心代码就应该是Delegate.combine这个静态方法了，我们来看看源码是怎么回事：<br />Delegate类的：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #000000;">[__DynamicallyInvokable]
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Delegate Combine(Delegate a, Delegate b)
{
</span><span style="color: #0000ff;">   if</span> ((<span style="color: #0000ff;">object</span>)a == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
</span><span style="color: #0000ff;">     return</span><span style="color: #000000;"> b;
   }
</span><span style="color: #0000ff;">   return</span><span style="color: #000000;"> a.CombineImpl(b);
}

</span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> Delegate CombineImpl(Delegate d)
{
</span><span style="color: #0000ff;">   throw</span> <span style="color: #0000ff;">new</span> MulticastNotSupportedException(Environment.GetResourceString(<span style="color: #800000;">"</span><span style="color: #800000;">Multicast_Combine</span><span style="color: #800000;">"</span><span style="color: #000000;">));
}</span></span></pre>
</div>
<p>&nbsp;</p>
<p>MulticastDelegate类的：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 14px;"><span style="color: #000000;">[SecurityCritical]
</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">object</span> _invocationList;<span style="color: #008000;">//</span><span style="color: #008000;">委托链表</span>
<span style="color: #000000;">
[SecurityCritical]
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> IntPtr _invocationCount;

[SecuritySafeCritical]
</span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">sealed</span> <span style="color: #0000ff;">override</span><span style="color: #000000;"> Delegate CombineImpl(Delegate follow)
{
</span><span style="color: #0000ff;">   if</span> ((<span style="color: #0000ff;">object</span>)follow == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
</span><span style="color: #0000ff;">      return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">;
   }
</span><span style="color: #0000ff;">   if</span> (!Delegate.InternalEqualTypes(<span style="color: #0000ff;">this</span><span style="color: #000000;">, follow))
   {
</span><span style="color: #0000ff;">     throw</span> <span style="color: #0000ff;">new</span> ArgumentException(Environment.GetResourceString(<span style="color: #800000;">"</span><span style="color: #800000;">Arg_DlgtTypeMis</span><span style="color: #800000;">"</span><span style="color: #000000;">));
   }
   MulticastDelegate multicastDelegate </span>=<span style="color: #000000;"> (MulticastDelegate)follow;
</span><span style="color: #0000ff;">   int</span> num = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">   object</span>[] array = multicastDelegate._invocationList <span style="color: #0000ff;">as</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">[];
</span><span style="color: #0000ff;">   if</span> (array != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
       num </span>= (<span style="color: #0000ff;">int</span><span style="color: #000000;">)multicastDelegate._invocationCount;
   }
</span><span style="color: #0000ff;">   object</span>[] array2 = _invocationList <span style="color: #0000ff;">as</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">[];
</span><span style="color: #0000ff;">   int</span><span style="color: #000000;"> num2;
</span><span style="color: #0000ff;">   object</span><span style="color: #000000;">[] array3;
</span><span style="color: #0000ff;">   if</span> (array2 == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
     num2 </span>= <span style="color: #800080;">1</span> +<span style="color: #000000;"> num;
     array3 </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">[num2];
     array3[</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">     if</span> (array == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
     {
        array3[</span><span style="color: #800080;">1</span>] =<span style="color: #000000;"> multicastDelegate;
     }
</span><span style="color: #0000ff;">     else</span><span style="color: #000000;">
     {
</span><span style="color: #0000ff;">       for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; num; i++<span style="color: #000000;">)
       {
         array3[</span><span style="color: #800080;">1</span> + i] =<span style="color: #000000;"> array[i];
       }
     }
</span><span style="color: #0000ff;">     return</span><span style="color: #000000;"> NewMulticastDelegate(array3, num2);
    }
</span><span style="color: #0000ff;">    int</span> num3 = (<span style="color: #0000ff;">int</span><span style="color: #000000;">)_invocationCount;
    num2 </span>= num3 +<span style="color: #000000;"> num;
    array3 </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">    if</span> (num2 &lt;=<span style="color: #000000;"> array2.Length)
    {
       array3 </span>=<span style="color: #000000;"> array2;
</span><span style="color: #0000ff;">       if</span> (array == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
       {
</span><span style="color: #0000ff;">           if</span> (!<span style="color: #000000;">TrySetSlot(array3, num3, multicastDelegate))
           {
             array3 </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
           }
       }
</span><span style="color: #0000ff;">       else</span><span style="color: #000000;">
       {
</span><span style="color: #0000ff;">         for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; num; j++<span style="color: #000000;">)
         {
</span><span style="color: #0000ff;">            if</span> (!TrySetSlot(array3, num3 +<span style="color: #000000;"> j, array[j]))
            {
               array3 </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">               break</span><span style="color: #000000;">;
            }
         }
       }
    }
</span><span style="color: #0000ff;">    if</span> (array3 == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
    {
</span><span style="color: #0000ff;">       int</span><span style="color: #000000;"> num4;
</span><span style="color: #0000ff;">       for</span> (num4 = array2.Length; num4 &lt; num2; num4 *= <span style="color: #800080;">2</span><span style="color: #000000;">)
       {
       }
       array3 </span>= <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">[num4];
</span><span style="color: #0000ff;">       for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; num3; k++<span style="color: #000000;">)
       {
          array3[k] </span>=<span style="color: #000000;"> array2[k];
       }
</span><span style="color: #0000ff;">       if</span> (array == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
       {
          array3[num3] </span>=<span style="color: #000000;"> multicastDelegate;
       }
</span><span style="color: #0000ff;">       else</span><span style="color: #000000;">
       {
</span><span style="color: #0000ff;">          for</span> (<span style="color: #0000ff;">int</span> l = <span style="color: #800080;">0</span>; l &lt; num; l++<span style="color: #000000;">)
          {
             array3[num3 </span>+ l] =<span style="color: #000000;"> array[l];
          }
       }
     }
</span><span style="color: #0000ff;">     return</span> NewMulticastDelegate(array3, num2, thisIsMultiCastAlready: <span style="color: #0000ff;">true</span><span style="color: #000000;">);
   }</span></span></pre>
</div>
<p>&nbsp;</p>
<p>GetInvocationList方法的实现：</p>
<div class="cnblogs_code">
<pre><code><span style="font-size: 15px;"><span style="color: #008000;">//</span><span style="color: #008000;">Delgate类的</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> Delegate[] GetInvocationList()
{
</span><span style="color: #0000ff;">   return</span> <span style="color: #0000ff;">new</span> Delegate[<span style="color: #800080;">1</span><span style="color: #000000;">]
   {
</span><span style="color: #0000ff;">     this</span><span style="color: #000000;">
   };
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">MulticastDelegate类的</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">sealed</span> <span style="color: #0000ff;">override</span><span style="color: #000000;"> Delegate[] GetInvocationList()
{
</span><span style="color: #0000ff;">   object</span>[] array = _invocationList <span style="color: #0000ff;">as</span> <span style="color: #0000ff;">object</span><span style="color: #000000;">[];
   Delegate[] array2;
</span><span style="color: #0000ff;">   if</span> (array == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
     array2 </span>= <span style="color: #0000ff;">new</span> Delegate[<span style="color: #800080;">1</span><span style="color: #000000;">]
     {
</span><span style="color: #0000ff;">       this</span><span style="color: #000000;">
     };
   }
</span><span style="color: #0000ff;">   else</span><span style="color: #000000;">
   {
</span><span style="color: #0000ff;">     int</span> num = (<span style="color: #0000ff;">int</span><span style="color: #000000;">)_invocationCount;
     array2 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Delegate[num];
</span><span style="color: #0000ff;">     for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; num; i++<span style="color: #000000;">)
     {
        array2[i] </span>=<span style="color: #000000;"> (Delegate)array[i];
     }
   }
</span><span style="color: #0000ff;">   return</span><span style="color: #000000;"> array2;
}</span></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 其实我们看到这里，就可以知道其中的一个最主要就是<strong>_invocationList</strong>变量，也就是当调用<strong>Combine</strong>的时候，会判断左边委托变量是否为空，如果为空，会返回右边的委托变量，不为空就会调用<strong>CombineImpl</strong>方法，以上面那个例子来说<strong>fooHandle3</strong>的<strong>_invocationList</strong>存储着所有附加到委托变量，包含对象本身，也就是为啥遍历<strong>fooHandle3.GetInvocationList</strong>，输出了三个附加到<strong>fooHandle3</strong>变量的委托变量，这里例子<strong>fooHandle3</strong>初始化为null，还有意思的是fooHandle3的Targt和Menthod属性是最后附加的那个委托变量的Target和Menthod，而当委托由返回值，也同理返回最后一个函数的返回值，那么<strong>fooHandle3</strong>大概的结构如下图：</p>
<p><img src="./images/.Neter所应该彻底了解的委托6.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;我们到现在只用到+=，其实-=就是调用其Delegate.Remove方法，跟Combine方法作用相反，具体就不多概述<br />看到这里我们终于可以回答一开头抛出的几个问题？</p>
<ul>
<li>
<h2><strong>委托是不是相当于C/C++的函数指针?</strong></h2>
</li>



















</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 很明显，不是的，从数据结构来说，c++函数指针表示一块指向函数的内存地址，它其实和直接写函数名没啥区别，因为我们调用函数时的函数名，也是函数入口地址，而委托却是个类，是一块托管内存，使用Invoke后它就会被clr释放了，它的函数成员能够存储所调函数的所有信息，这是函数指针没做到的,但是在某些特殊情况下，C++的函数指针就和委托一样，有兴趣的朋友可以去看下p/invoke方面知识</p>
<ul>
<li>
<h2><strong>委托是什么？</strong></h2>
</li>



















</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 委托本质是类，且支持多播委托的本质是维护一个私有的_invocationList委托链对象,+=和-=都是调用其静态方法Combine和Remove</p>
<ul>
<li>
<h2><strong>委托是用来做啥的？</strong></h2>
</li>



















</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 委托和c++函数指针一样，都可以作为函数中转器，在调用者和被调用者中起解耦作用，可作为函数的参数，当回调函数</p>
<ul>
<li>
<h2><strong>委托跟匿名函数的区别？</strong></h2>
</li>



















</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我们先来声明和使用匿名函数：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">int</span> Foohandle(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);

Foohandle foohandle </span>= <span style="color: #0000ff;">delegate</span> (<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b) { <span style="color: #0000ff;">return</span> a + b; };<span style="color: #008000;">//</span><span style="color: #008000;">匿名方法方式</span>
Foohandle foohandle1= (a, b)=&gt; a + b;<span style="color: #008000;">//</span><span style="color: #008000;">Lambda 表达式方式</span>
<span style="color: #000000;">
foohandle.Invoke(</span><span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>);<span style="color: #008000;">//</span><span style="color: #008000;">输出4</span>
foohandle1.Invoke(<span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>);<span style="color: #008000;">//</span><span style="color: #008000;">输出4</span></pre>
</div>
<p>&nbsp;</p>
<p>我们来看下msdn是怎么定义匿名函数的：</p>
<p><img src="./images/.Neter所应该彻底了解的委托7.png" alt="" width="854" height="120" /></p>
<p>&nbsp;</p>
<p>很明显，匿名函数只是个表达式，可以用来初始化委托的，而委托是个类，其实通过查看IL，后台都会实例化一个新的委托对象，并把该表达式作为函数赋给它</p>
<ul>
<li>
<h2><strong>委托与事件的关系？</strong></h2>
</li>
</ul>
<p>&nbsp;同样的我们来声明和使用事件：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Foo
{
</span><span style="color: #0000ff;">   public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> Foohandel(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);

</span><span style="color: #0000ff;">   public</span> <span style="color: #0000ff;">event</span><span style="color: #000000;"> Foohandel foohandle;

</span><span style="color: #0000ff;">   public</span><span style="color: #000000;"> Foo()
   {
      foohandle </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Foohandel(add);
      foohandle(</span><span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>);<span style="color: #008000;">//</span><span style="color: #008000;">在Foo里面可以直接调用事件</span>
      Console.WriteLine($<span style="color: #800000;">"</span><span style="color: #800000;">{foohandle.Target},{foohandle.Method}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
   }

</span><span style="color: #0000ff;">   public</span> <span style="color: #0000ff;">void</span> excute(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b)<span style="color: #008000;">//</span><span style="color: #008000;">公开给外部类调用事件的函数</span>
<span style="color: #000000;">   {
      foohandle</span>?<span style="color: #000000;">.Invoke(a,b);
   }

</span><span style="color: #0000ff;">   private</span> <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
   {
      Console.WriteLine(a </span>+<span style="color: #000000;"> b); 
   }
}

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
{
</span><span style="color: #0000ff;">   static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
   {
      Foo foo </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Foo();
</span><span style="color: #008000;">      //</span><span style="color: #008000;">foo.foohandle = new Foo.Foohandel(multiply);编译不过，提示foo.foohandle只能出现再+=和-=左边</span>
      foo.foohandle +=<span style="color: #0000ff;">new</span><span style="color: #000000;"> Foo.Foohandel(multiply);
      foo.excute(</span><span style="color: #800080;">2</span>, <span style="color: #800080;">2</span><span style="color: #000000;">); 
      Console.Read();
   }

</span><span style="color: #0000ff;">   static</span> <span style="color: #0000ff;">void</span> multiply(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
   {
      Console.WriteLine(a </span>*<span style="color: #000000;"> b); 
   }
}</span></pre>
</div>
<p>&nbsp;</p>
<p>输出结果：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #800080;">4</span><span style="color: #000000;">
EventSample.Foo,Void add(Int32, Int32)
</span><span style="color: #800080;">4</span>
<span style="color: #800080;">4</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;我们发现，在Foo类里面，事件foohandle就是相当于委托，但是在外部，我们再program的main函数访问它时候，我们发现foohandle只能做+=或者-=，也不能访问其函数成员Target和Menthod，而我们只能通过调用excute函数去调用，这时候我们可以知道，Event其实是基于委托的，在内部类相当于委托，在外部就只能有委托的多播功能，其余都不能访问，其实我们想到，属性是不是这样。。。有兴趣的朋友可以去了解事件的原理，也是很有趣</p>
<p><br />最后的最后，我们还要谈下委托的一个功能：</p>
<h2><strong>委托的参数逆变和返回值的协变</strong></h2>
<p>由于委托也支持泛型委托，因此我们可以看看微软定义好的</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">void</span> Action&lt;<span style="color: #0000ff;">in</span> T&gt;(T obj);<span style="color: #008000;">//</span><span style="color: #008000;">其中in表示逆变</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> TResult Func&lt;<span style="color: #0000ff;">out</span> TResult&gt;();<span style="color: #008000;">//</span><span style="color: #008000;">其中out表示协变</span>

<span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
{
</span><span style="color: #0000ff;">    static</span> Action&lt;<span style="color: #0000ff;">object</span>&gt;<span style="color: #000000;"> action;
</span><span style="color: #0000ff;">    static</span> Func&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> func;
</span><span style="color: #0000ff;">    static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
    {
       action </span>= (<span style="color: #0000ff;">object</span> a) =&gt;<span style="color: #000000;"> { Console.WriteLine(a.ToString()); };
       Action</span>&lt;<span style="color: #0000ff;">string</span>&gt; action1 = action;<span style="color: #008000;">//</span><span style="color: #008000;">参数逆变</span>
       action(<span style="color: #800000;">"</span><span style="color: #800000;">Hello!</span><span style="color: #800000;">"</span><span style="color: #000000;">);


       func </span>= () =&gt; { <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">I am Func</span><span style="color: #800000;">"</span><span style="color: #000000;">; };
       Func</span>&lt;<span style="color: #0000ff;">object</span>&gt; func1 = func;<span style="color: #008000;">//</span><span style="color: #008000;">返回值协变</span>
<span style="color: #000000;">       Console.WriteLine(func1()); 
       Console.ReadLine();
    }

}</span></pre>
</div>
<p>&nbsp;</p>
<p>输出结果：</p>
<div class="cnblogs_code">
<pre><code>Hello!<span style="color: #000000;">
I am Func</span></pre>
</div>
<p>想要了解更深的朋友可以去了解泛型的协变和逆变，在这里就不深入探讨了</p>
<p>&nbsp;</p>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; left: -1582px; top: 35px; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; left: -116px; top: 11468px; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; left: -1210px; top: 1095px; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; left: -1627px; top: 341px; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; left: -1659px; top: 335px; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; display: none;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">&nbsp;</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
<div id="translate-man-app" class="content-27EWd_0" style="background-color: #ffffff; left: -1096px; top: 14471px;">
<div class="outputBox-mGAYH_0" data-v-14be448c="">
<div class="outputBox-6zQWc_0" data-v-14be448c=""><span class="outputBox-3QF_j_0" data-v-14be448c="">委托的参数逆变和返回值的协变</span></div>
<div class="outputBox-23yoE_0" data-v-14be448c="">
<div class="outputBox-1MfHy_0" data-v-14be448c="">[Wěituō de cānsh&ugrave; n&igrave; bi&agrave;n h&eacute; fǎnhu&iacute; zh&iacute; de xi&eacute; bi&agrave;n]</div>
<div class="outputBox-mOJr9_0" data-v-14be448c=""><img class="icon-2A0TR_0" src="chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg" alt="" /></div>
</div>
<div class="outputBox-2JiL2_0" data-v-14be448c="">
<div class="outputBox-1_--c_0" data-v-14be448c=""><span class="outputBox-3_uDm_0" data-v-14be448c="">Covariant return parameters of the inverter and a delegate value</span></div>
</div>
<div class="outputBox-EXeNH_0" style="display: none;" data-v-14be448c="">&nbsp;</div>
</div>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>