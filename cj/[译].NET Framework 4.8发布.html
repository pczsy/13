<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[译].NET Framework 4.8发布' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[译].NET Framework 4.8发布</center></div><div class='banquan'>原文出处:本文由博客园博主Minotauros提供。<br/>
原文连接:https://www.cnblogs.com/minotauros/p/10736607.html</div><br>
    <p>原文地址：<a href="https://devblogs.microsoft.com/dotnet/announcing-the-net-framework-4-8/">https://devblogs.microsoft.com/dotnet/announcing-the-net-framework-4-8/</a></p>
<p><span><span>我们很高兴地宣布今天发布.NET Framework 4.8。</span><span>它包含在Windows 10 2019 May更新中。</span><span>.NET Framework 4.8也可以在Windows 7+和Windows Server 2008 R2 +上使用。</span></span></p>
<p><span>您可以从我们的</span><a href="https://dotnet.microsoft.com/download/dotnet-framework">&nbsp;.NET下载站点</a><span><span>安装.NET 4.8&nbsp;</span><span>。</span><span>要构建面向.NET Framework 4.8的应用程序，可以下载</span></span><a href="https://go.microsoft.com/fwlink/?linkid=2088517" rel="noopener" target="_blank">.NET 4.8开发人员包</a><span><span>。</span><span>如果您只想要.NET 4.8运行时，可以尝试：</span></span></p>
<ul>
<li><a href="http://go.microsoft.com/fwlink/?LinkId=2085155" rel="noopener" target="_blank">.NET 4.8 Web安装程序</a><span>&nbsp;- 在安装期间需要Internet连接</span></li>
<li><a href="https://go.microsoft.com/fwlink/?linkid=2088631" rel="noopener" target="_blank">.NET 4.8脱机安装程序</a><span>&nbsp;- 可以在以后以断开连接状态下载和安装</span></li>
</ul>
<p><span>.NET Framework 4.8包含更新的工具集以及几个方面的改进：</span></p>
<ul>
<li>[运行时]<span>&nbsp;&nbsp;JIT和NGEN改进</span></li>
<li>[BCL]<span>&nbsp;&nbsp;更新了ZLib</span></li>
<li>[BCL]<span>&nbsp;&nbsp;降低FIPS对密码学的影响</span></li>
<li>[WinForms]<span>&nbsp;&nbsp;辅助功能增强功能</span></li>
<li>[WCF]<span>&nbsp;&nbsp;服务行为增强功能</span></li>
<li>[WPF]<span>&nbsp;&nbsp;高DPI增强，UIAutomation改进</span></li>
</ul>
<p><span>您可以在</span><a href="https://github.com/Microsoft/dotnet/tree/master/releases/net48/README.md">.NET Framework 4.8发行说明中</a><span><span>看到完整的改进列表&nbsp;&nbsp;</span><span>。&nbsp;</span><span>.NET 4.8也更新了</span></span><a href="https://go.microsoft.com/fwlink/?LinkId=2053898">参考源</a><span>。</span></p>
<h3>&nbsp;支持的Windows版本</h3>
<p>Windows客户端版本：<span>&nbsp;Windows 10版本1903，Windows 10版本1809，Windows 10版本1803，Windows 10版本1709，Windows 10版本1703，Windows 10版本1607，Windows 8.1，Windows 7 SP1&nbsp;</span><br />Windows Server版本：<span>&nbsp;Windows Server 2019，Windows Server版本1803，Windows Server 2016，Windows Server 2012，Windows Server 2012 R2，Windows Server 2008 R2 SP1</span></p>
<h3>&nbsp;.NET Framework 4.8中的新功能</h3>
<h4><span>运行时 - JIT改进</span></h4>
<p><span><span>.NET 4.8中的JIT基于.NET Core 2.1。</span><span>现在，.NET Framework中提供了所有错误修复和.NET Core 2.1中许多基于代码生成的性能优化。</span></span></p>
<h4><span>运行时 - NGEN的改进</span></h4>
<p><span><span>.NET Framework中的NGEN映像不再包含可写和可执行部分。</span><span>这减少了可用于通过修改将要执行的内存来执行任意代码的攻击的表面区域。</span></span></p>
<p><span>虽然在运行时内存中仍然存在可写和可执行数据，但此更改会删除从NGEN映像映射的数据，从而允许它们在不允许图像中的可执行/可写部分的受限环境中运行。</span></p>
<h4><span>运行时 - 所有程序集的反恶意软件扫描</span></h4>
<p><span><span>在以前版本的.NET Framework中，Windows Defender或第三方反恶意软件会自动扫描从磁盘加载的所有程序集以查找恶意软件。</span><span>但是，从其他地方加载的程序集（例如使用Assembly.Load（byte []））将不会被扫描，并且可能会检测到未检测到的病毒。</span></span></p>
<p><span>Windows 10上的.NET Framework 4.8会触发Windows Defender和许多其他实现反恶意</span><a href="https://cloudblogs.microsoft.com/microsoftsecure/2015/06/09/windows-10-to-offer-application-developers-new-malware-defenses/">软件扫描接口的</a><span><span>反恶意软件解决方案对这些程序集的</span><a href="https://cloudblogs.microsoft.com/microsoftsecure/2015/06/09/windows-10-to-offer-application-developers-new-malware-defenses/"><span>扫描</span></a><span>。</span><span>我们希望这会使恶意软件更难以在.NET程序中伪装自己。</span></span></p>
<h4><span>BCL - 更新了ZLib</span></h4>
<p><span><span>从.NET Framework 4.5开始，我们使用</span><span>&nbsp;clrcompression.dll中</span></span><a href="http://zlib.net/">http://zlib.net</a><span><span>的ZLib本机版本（用于数据压缩的本机外部压缩库）&nbsp;&nbsp;</span><span>，以便为deflate算法提供实现。</span><span>在.NET Framework 4.8中，我们将clrcompression.dll更新为使用版本1.2.11，其中包括几个</span></span><a href="http://zlib.net/ChangeLog.txt">关键的改进和修复</a><span>。</span></p>
<h4><span>BCL - 降低FIPS对密码学的影响</span></h4>
<p><span><span>.NET Framework 2.0+具有加密提供程序类，例如SHA256Managed，当在&ldquo;FIPS模式&rdquo;下配置系统加密库时会抛出CryptographicException。</span><span>抛出这些异常是因为托管版本未经过FIPS（联邦信息处理标准）140-2认证（JIT和NGEN映像生成都会使证书无效），这与系统加密库不同。</span><span>很少有开发人员将他们的开发机器置于&ldquo;FIPS模式&rdquo;，导致这些异常在生产（或客户系统）中引发。</span><span>.NET Framework还使用&ldquo;FIPS模式&rdquo;设置来阻止加密算法，这些加密算法不被FIPS规则视为已批准的算法。</span></span></p>
<p><span><span>对于为.NET Framework 4.8构建的应用程序，将不再抛出这些异常（默认情况下）。</span><span>相反，SHA256Managed类（以及其他托管加密类）会将加密操作重定向到系统加密库。</span><span>此策略更改有效地消除了开发人员环境与运行代码的生产环境之间可能存在的混淆差异，并使本机组件和托管组件在相同的加密策略下运行。</span></span></p>
<p><span><span>针对.NET Framework 4.8的应用程序将自动切换到较新的宽松策略，并且在&ldquo;FIPS模式&rdquo;下不再会看到从MD5Cng，MD5CryptoServiceProvider，RC2CryptoServiceProvider，RIPEMD160Managed和RijndaelManaged引发的异常。</span><span>依赖于先前版本的异常的应用程序可以通过将AppContext开关&ldquo;Switch.System.Security.Cryptography.UseLegacyFipsThrow&rdquo;设置为&ldquo;true&rdquo;来返回到先前的行为。</span></span></p>
<h4><span>Windows窗体 - 辅助功能增强功能</span></h4>
<p><span><span>在.NET Framework 4.8中，WinForms添加了三个新功能，使开发人员能够编写更易于访问的应用程序。</span><span>添加的功能旨在使视障用户的应用程序数据通信更加健壮。</span><span>当用户通过键盘导航时，我们添加了对ToolTips的支持，我们已将LiveRegions和Notification Events添加到许多常用控件中。</span></span></p>
<p><span>要启用这些功能，您的应用程序需要在App.config文件中启用以下AppContextSwitches：</span></p>
<h4><span>Windows窗体 - UIA LiveRegions支持标签和StatusStrips</span></h4>
<p><span><span>UIA Live Regions允许应用程序开发人员通知屏幕阅读器控件的文本更改，该控件位于用户工作的位置之外。</span><span>这将派上用场的示例可以是显示连接状态的StatusStrip。</span><span>如果删除连接并且状态发生更改，开发人员可能希望通知屏幕阅读器此更改。</span><span>Windows Forms已为Label控件和StatusStrip控件实现了UIA LiveRegions。</span></span></p>
<p><span>在Label控件中使用LiveRegion的示例：</span></p>
<p><span>讲述者现在将宣布&ldquo;准备就绪&rdquo;，无论用户在何处与应用程序进行交互。</span><br /><span>您还可以将UserControl实现为Live区域：</span></p>
<h4><span>Windows窗体 - UIA通知事件</span></h4>
<p><span><span>在Windows 10 Fall Creators Update中，Windows引入了一种新方法，让应用程序通知Narrator内容已更改，而Narrator应该宣布更改。</span><span>UIA通知事件为您的应用程序提供了一种方式来引发UIA事件，这会导致讲述人根据您为事件提供的文本简单地发布通知，而无需在UI中使用相应的控件。</span><span>在某些情况下，这可能是一种直接提高应用程序可访问性的方法。</span><span>有关UIA通知事件的更多信息，请参阅此</span></span><a href="https://blogs.msdn.microsoft.com/winuiautomation/2017/11/08/can-your-desktop-app-leverage-the-new-uia-notification-event-in-order-to-have-narrator-say-exactly-what-your-customers-need/">博客文章</a><span>。</span></p>
<p><span>通知可能派上用场的一个示例是通知可能需要一些时间的某个过程的进度。</span></p>
<p><span>提升通知事件的示例：</span></p>
<h4><span>Windows窗体 - 键盘访问的工具提示</span></h4>
<p><span><span>目前，只能通过将鼠标指针移动到控件中来触发控制工具提示。</span><span>此新功能使键盘用户可以通过使用Tab键或带有或不带修饰键的箭头键来聚焦控件来触发控件的工具提示。</span><span>此特定辅助功能增强需要额外的AppContextSwitch，如以下示例所示：</span></span></p>
<p><span><span>　　1.</span></span>创建一个新的WinForms应用程序。</p>
<p>　　2.将以下XML添加到App.config文件中。</p>
<p>　　3.将几个按钮和一个ToolTip控件添加到应用程序的表单中。</p>
<p>　　4.设置按钮的工具提示。</p>
<p>　　5.运行应用程序并使用键盘在按钮之间导航：</p>
<p><a href="./images/[译].NET Framework 4.8发布0.png" data-featherlight="image"><img class="aligncenter size-full wp-image-22505" src="./images/[译].NET Framework 4.8发布0.png" alt="" width="541" height="216" /></a></p>
<h4><span>Windows窗体 - DataGridView控制可访问的层次结构更改</span></h4>
<p><span><span>目前，可访问的层次结构（UI自动化树）将编辑框树元素显示为当前编辑的单元格的子元素，但不显示为DataGridView的根子元素。</span><span>可以使用Inspect工具观察层次结构树更新：</span></span></p>
<p><a href="./images/[译].NET Framework 4.8发布1.png" data-featherlight="image"><img class="aligncenter wp-image-22502 size-full" src="./images/[译].NET Framework 4.8发布1.png" alt="" width="781" height="316" /></a></p>
<h4><span>&nbsp;WCF - ServiceHealthBehavior</span></h4>
<p><span><span>健康端点具有许多优点，并且编排工具广泛使用它来根据服务健康状况管理服务。</span><span>监控工具还可以使用运行状况检查来跟踪和警告服务的可用性和性能，并将其作为早期问题指标。</span></span></p>
<p><span><span>ServiceHealthBehavior是一种扩展IServiceBehavior的WCF服务行为。</span><span>添加到ServiceDescription.Behaviors集合后，它将启用以下内容：</span></span></p>
<ul>
<li><span>使用HTTP响应代码返回服务运行状况：可以在查询字符串中指定HTTP / GET运行状况探测请求的HTTP状态代码。</span></li>
<li><span><span>发布服务运行状况：使用&ldquo;？运行状况&rdquo;查询字符串，使用HTTP / GET请求显示服务特定的详细信息，包括服务状态和节流计数和容量。</span><span>在故障排除错误行为的WCF服务时，了解并轻松访问所显示的信息非常重要。</span></span></li>




</ul>
<p><span>配置ServiceHealthBehavior：</span></p>
<p><span>有两种方法可以公开运行状况端点并发布WCF服务运行状况信息：使用代码或使用配置文件。</span></p>
<ol>
<li>使用代码启用运行状况端点&nbsp;</li>


</ol><ol start="2">
<li>使用config启用健康端点</li>


</ol>
<p>使用HTTP响应代码返回服务运行状况：</p>
<p><span><span>可以通过查询参数（OnServiceFailure，OnDispatcherFailure，OnListenerFailure，OnThrottlePercentExceeded）查询运行状况。</span><span>可以为每个查询参数指定HTTP响应代码（200 - 599）。</span><span>如果省略查询参数的HTTP响应代码，则默认使用503 HTTP响应代码。</span></span></p>
<p>查询参数和示例：</p>
<ol>
<li>OnServiceFailure<span>：</span></li>




</ol>
<ul>
<li><span>示例：通过查询https：// contoso：81 / Service1？health＆OnServiceFailure = 450，当ServiceHost.State大于CommunicationState.Opened时，将返回450 HTTP响应状态代码。</span></li>




</ul>
<ol start="2">
<li>OnDispatcherFailure<span>：</span></li>




</ol>
<ul>
<li><span>示例：通过查询https：// contoso：81 / Service1？health＆OnDispatcherFailure = 45&nbsp;</span><span style="text-decoration: underline;"><span>5</span></span><span>，当任何通道调度程序的状态大于CommunicationState.Opened时，将返回455 HTTP响应状态代码。</span></li>




</ul>
<ol start="3">
<li>OnListenerFailure<span>：</span></li>




</ol>
<ul>
<li><span>示例：通过查询https：// contoso：81 / Service1？health＆OnListenerFailure = 4&nbsp;</span><span style="text-decoration: underline;"><span>65</span></span><span>，当任何通道侦听器的状态大于CommunicationState.Opened时，将返回465 HTTP响应状态代码。</span></li>




</ul>
<ol start="4">
<li>OnThrottlePercentExceeded<span>：指定触发响应的百分比{1 - 100}及其HTTP响应代码{200 - 599}。</span></li>




</ol>
<ul>
<li><span><span>示例：通过查询https：// contoso：81 / Service1？health＆OnThrottlePercentExceeded = 70：350,95：500，当节流百分比等于或大于95％时，返回500响应代码;&nbsp;</span><span>当百分比等于或大于70％且小于95％时，返回350;&nbsp;</span><span>否则，返回200。</span></span></li>




</ul>
<p>出版服务健康状况：</p>
<p><span><span>启用运行状况端点后，可以在html中显示服务运行状况（通过指定查询字符串：https：// contoso：81 / Service1？运行状况）或xml（通过指定查询字符串：https：// contoso： 81 / Service1？health＆Xml）格式。</span><span>https：// contoso：81 / Service1？health＆NoContent返回空的html页面。</span></span></p>
<p>注意：</p>
<p><span><span>始终限制对服务运行状况终结点的访问是最佳做法。</span><span>您可以使用以下机制限制访问：</span></span></p>
<ol>
<li><span>为健康端点使用不同于其他服务的端口，并使用防火墙规则来控制访问。</span></li>
<li><span>将所需的身份验证和授权添加到运行状况端点绑定。</span></li>




</ol>
<h4><span>WPF - 屏幕旁白者不再宣布具有折叠或隐藏可见性的元素</span></h4>
<p><span><span>屏幕阅读器不再宣布具有折叠或隐藏可见性的元素。</span><span>如果向用户宣布这些元素，则包含具有折叠或隐藏可见性的元素的用户界面可能被屏幕阅读器误传。</span><span>在.NET Framework 4.8中，WPF不再包含UIAutomation树的Control View中的Collapsed或Hidden元素，因此屏幕阅读器无法再宣布这些元素。</span></span></p>
<h4><span>WPF - SelectionTextBrush属性，用于非基于Adorner的文本选择</span></h4>
<p><span>在.NET Framework 4.7.2中，WPF添加了在不使用adorner层的情况下绘制TextBox和PasswordBox文本选择的功能（</span><a href="https://github.com/Microsoft/dotnet/blob/master/Documentation/compatibility/wpf-TextBox-PasswordBox-text-selection-does-not-follow-system-colors.md">参见此处</a><span><span>）。</span><span>此场景中所选文本的前景色由</span></span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.systemcolors.highlighttextbrush?redirectedfrom=MSDN&amp;view=netframework-4.7.2#System_Windows_SystemColors_HighlightTextBrush">SystemColors.HighlightTextBrush</a><span><span>决定</span><span>。</span></span></p>
<p><span>在.NET Framework 4.8中，我们添加了一个新属性SelectionTextBrush，允许开发人员在使用基于非装饰器的文本选择时为所选文本选择特定画笔。</span></p>
<p><span><span>此属性仅适用于启用了基于非装饰器的文本选择的WPF应用程序中的TextBoxBase派生控件和PasswordBox。</span><span>它不适用于RichTextBox。</span><span>如果未启用基于非装饰器的文本选择，则会忽略此属性。</span></span></p>
<p><span>要使用此属性，只需将其添加到XAML代码并使用适当的画笔或绑定。</span></p>
<p><span>生成的文本选择如下所示：</span></p>
<p><a href="./images/[译].NET Framework 4.8发布2.png" data-featherlight="image"><img class="aligncenter wp-image-22507 size-full" src="./images/[译].NET Framework 4.8发布2.png" alt="" width="247" height="78" /></a></p>
<p><span>您可以结合使用SelectionBrush和SelectionTextBrush来生成您认为合适的背景和前景的任何颜色组合。</span></p>
<h4><span>WPF - 高DPI增强功能</span></h4>
<p><span><span>WPF在.NET 4.8中增加了对Per-Monitor V2 DPI感知和混合模式DPI扩展的支持。</span><span>有关这些Windows概念的更多信息，请参见</span></span><a href="https://docs.microsoft.com/en-us/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">此处</a><span>。</span></p>
<p><a href="https://github.com/Microsoft/WPF-Samples/blob/master/PerMonitorDPI/readme.md">WPF中</a><span><span>最新</span><a href="https://github.com/Microsoft/WPF-Samples/blob/master/PerMonitorDPI/readme.md"><span>的Per监视器应用程序开发指南</span></a><span>指出，只有纯WPF应用程序可以在高DPI WPF应用程序中无缝工作，并且不完全支持Hosted HWND和Windows Forms控件。</span></span></p>
<p><span><span>.NET 4.8改进了对支持混合模式DPI扩展的平台上的高DPI WPF应用程序中托管HWND和Windows Forms互操作的支持（Windows 10 v1803）。</span><span>当托管HWND或Windows窗体控件创建为混合模式DPI缩放窗口时（如&ldquo;&nbsp;</span></span><a href="https://docs.microsoft.com/en-us/windows/desktop/hidpi/high-dpi-improvements-for-desktop-applications">混合模式DPI缩放和DPI感知API</a><span><span>&nbsp;&rdquo;文档中所述，通过调用SetThreadDpiHostingBehavior和SetThreadDpiAwarenessContext API），可以托管此类Per-Monitor V2 WPF应用程序中的内容，并对它们进行适当调整大小和缩放。</span><span>此类托管内容不会在本机DPI上呈现 - 相反，操作系统会将托管内容扩展到适当的大小。</span></span></p>
<p><span><span>对Per-Monitor v2 DPI感知模式的支持还允许在高DPI应用程序的本机窗口下托管（即，父级）WPF控件。</span><span>Windows 10 v1607（周年纪念更新）将提供Per-Monitor V2 DPI Awareness支持。</span><span>当通过应用程序清单启用Per-Monitor V2 DPI Awareness模式时，Windows添加了对child-HWND的支持以接收DPI更改通知。</span></span></p>
<p><span><span>WPF利用此支持来确保在本机窗口下托管的控件可以响应DPI更改并自行更新。</span><span>例如，在Windows窗体中托管的WPF控件或表现为Per Monitor V2的Win32应用程序 - 现在能够正确响应DPI更改并自行更新。</span></span></p>
<p><span>请注意，Windows支持Windows 10 v1803上的混合模式DPI扩展，而v1607以上版本支持Per-Monitor V2。</span></p>
<p><span>要试用这些功能，必须启用以下应用程序清单和AppContext标志：</span></p>
<p><span>　　1.</span>在您的应用程序中启用Per-Monitor DPI：在app.manifest中打开Per-Monitor V2</p>
<p>　　2.在WPF中启用高DPI支持：目标.NET Framework 4.6.2或更高版本</p>
<p><span>　　3.在app.config中设置AppContext开关</span></p>
<p><span>　　或者，</span>在App.Config中设置AppContextSwitch Switch.System.Windows.DoNotUsePresentationDpiCapabilityTier2OrGreater = false以启用.NET 4.8中引入的Per-Monitor V2和混合模式DPI支持。</p>
<p><span>最终App.Config中的运行时部分可能如下所示：</span></p>
<p><span><span>AppContext开关也可以在注册表中设置。</span><span>您可以参考</span></span><a href="https://msdn.microsoft.com/en-us/library/system.appcontext(v=vs.110).aspx">AppContext类</a><span>以获取其他文档。</span></p>
<h4><span>WPF - 支持UIAutomation ControllerFor属性</span></h4>
<p><span><span>UIAutomation的ControllerFor属性返回一个自动化元素数组，这些元素由支持该属性的自动化元素操作。</span><span>此属性通常用于自动建议可访问性。</span><span>当自动化元素影响应用程序UI或桌面的一个或多个段时，将使用ControllerFor。</span><span>否则，很难将控制操作的影响与UI元素相关联。</span><span>此功能增加了控件为ControllerFor属性提供值的功能。</span></span></p>
<p><span>AutomationPeer中添加了一个新的虚拟方法：</span></p>
<p><span>要为ControllerFor属性提供值，只需覆盖此方法并返回此AutomationPeer操作的控件的AutomationPeers列表：</span></p>
<h4><span>WPF - 键盘访问的工具提示</span></h4>
<p><span><span>当前工具提示仅在用户将鼠标光标悬停在控件上时显示。</span><span>在.NET Framework 4.8中，WPF添加了一项功能，可以使工具提示在键盘焦点上显示，也可以通过键盘快捷键显示。</span></span></p>
<p><span>要启用此功能，应用程序需要通过AppContext开关&ldquo;Switch.UseLegacyAccessibilityFeatures.3&rdquo;和&ldquo;Switch.UseLegacyToolTipDisplay&rdquo;来定位.NET Framework 4.8或选择加入。</span></p>
<p><span>示例App.config文件：</span></p>
<p><span><span>启用后，包含工具提示的所有控件将在控件接收键盘焦点后开始显示。</span><span>随着时间的推移或键盘焦点发生变化时，工具提示可以被解除。</span><span>用户还可以通过新的键盘快捷键Ctrl + Shift + F10手动关闭工具提示。</span><span>一旦工具提示被解除，它可以通过相同的键盘快捷方式再次显示。</span></span></p>
<p><span>注意：Ribbon控件上的RibbonToolTips不会显示在键盘焦点上 - 它们只会通过键盘快捷键显示。</span></p>
<h4><span>WPF - 添加了对SizeOfSet和PositionInSet UIAutomation属性的支持</span></h4>
<p><span><span>Windows 10引入了新的UIAutomation属性SizeOfSet和PositionInSet，应用程序使用它们来描述集合中项目的数量。</span><span>然后，UIAutomation客户端应用程序（如屏幕阅读器）可以查询应用程序以获取这些属性，并宣布应用程序UI的准确表示。</span></span></p>
<p><span><span>此功能添加了对WPF应用程序的支持，以将这两个属性公开给UIAutomation。</span><span>这可以通过两种方式实现：</span></span></p>
<p>　　1.DependencyProperties&nbsp;</p>
<p><span><span>新的DependencyProperties SizeOfSet和PositionInSet已添加到System.Windows.Automation.AutomationProperties命名空间。</span><span>开发人员可以通过XAML设置其值：</span></span></p>
<p>　　2.AutomationPeer虚拟方法&nbsp;</p>
<p><span><span>虚拟方法GetSizeOfSetCore和GetPositionInSetCore也已添加到AutomationPeer类中。</span><span>开发人员可以通过覆盖这些方法为SizeOfSet和PositionInSet提供值：</span></span></p>
<h4>自动值&nbsp;</h4>
<p><span><span>ItemsControls中的项目将自动为这些属性提供值，而无需开发人员的其他操作。</span><span>如果ItemsControl已分组，则组的集合将表示为一个集合，每个组计为一个单独的集合，该组中的每个项目都提供其在该组内的位置以及该组的大小。</span><span>虚拟化不会影响自动值。</span><span>即使一个项目没有实现，它仍然会计入集合的总大小，并影响它的兄弟项目集合中的位置。</span></span></p>
<p><span>仅当开发人员以.NET Framework 4.8为目标或已将AppContext开关设置为&ldquo;Switch.UseLegacyAccessibilityFeatures.3&rdquo;（例如通过App.config文件）时，才会提供自动值：</span></p>
<h3>结尾</h3>
<p><span>请在.NET Framework 4.8中尝试这些改进，并在下面的评论中或通过</span><a href="https://github.com/Microsoft/dotnet/issues/">GitHub</a><span><span>分享您的反馈</span><span>。</span></span></p>
<p><span>谢谢！</span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>