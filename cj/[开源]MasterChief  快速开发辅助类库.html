<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[开源]MasterChief  快速开发辅助类库' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[开源]MasterChief  快速开发辅助类库</center></div><div class='banquan'>原文出处:本文由博客园博主MeetYan提供。<br/>
原文连接:https://www.cnblogs.com/MeetYan/p/10765721.html</div><br>
    <blockquote>
<p>C# 开发辅助类库，和士官长一样身经百战且越战越勇的战争机器，能力无人能出其右。<br />
GitHub：<a href="https://github.com/YanZhiwei/MasterChief">MasterChief</a> 欢迎Star，欢迎Issues；<br />
项目架构思维导图：</p>
</blockquote>
<p><img src="./images/[开源]MasterChief  快速开发辅助类库0.png" alt="设计" /></p>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE">1. 数据库访问</a></li>
<li><a href="#2-%E6%97%A5%E5%BF%97">2. 日志</a></li>
<li><a href="#3-%E7%BC%93%E5%AD%98">3. 缓存</a></li>
<li><a href="#4-%E9%85%8D%E7%BD%AE">4. 配置</a></li>
<li><a href="#5-%E9%AA%8C%E8%AF%81%E7%A0%81">5. 验证码</a></li>
<li><a href="#6-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">6. 序列化与反序列化</a></li>
<li><a href="#7-excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA">7. EXCEL导入导出</a></li>
<li><a href="#8-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">8. 文件下载</a></li>
</ul>
<h4 id="数据库访问">1. 数据库访问</h4>
<hr />
<p>a. 支持Dapper和Entity Framework 两种ORM框架;</p>
<p>b. 通过IOC可以很少代码在Dapper和Entity Framework切换；</p>
<p>c. 实现Repository和UnitOfWork；</p>
<p>d. CURD以及事务实现简单，很大程度关注业务实现即可；</p>
<p>代码使用说明：</p>
<ol>
<li>Create 添加</li>
</ol>
<pre><code><code>public bool Create(EFSample samle)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.Create&lt;EFSample&gt;(samle);
    }
}</code></pre>
<ol>
<li>Delete 删除</li>
</ol>
<pre class="c#"><code>public bool Delete(EFSample sample)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.Delete(sample);
    }
}</code></pre>
<ol>
<li>Update 修改</li>
</ol>
<pre class="c#"><code>public bool Update(EFSample sample)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.Update(sample);
    }
}</code></pre>
<ol>
<li>GetByKeyID 根据主键查询</li>
</ol>
<pre><code><code>public EFSample GetByKeyID(Guid id)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.GetByKeyID&lt;EFSample&gt;(id);
    }
}</code></pre>
<ol>
<li>GetList 条件查询集合</li>
</ol>
<pre class="c#"><code>public List&lt;EFSample&gt; GetList(Expression&lt;Func&lt;EFSample, bool&gt;&gt; predicate = null)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.GetList&lt;EFSample&gt;(predicate);
    }
}</code></pre>
<ol>
<li>Exist 条件查询是否存在</li>
</ol>
<pre class="c#"><code>public bool Exist(Expression&lt;Func&lt;EFSample, bool&gt;&gt; predicate = null)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.Exist&lt;EFSample&gt;(predicate);
    }
}</code></pre>
<ol>
<li>SqlQuery 执行Sql脚本</li>
</ol>
<pre class="c#"><code>public List&lt;EFSample&gt; SqlQuery(string sql, DbParameter[] parameter)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.SqlQuery&lt;EFSample&gt;(sql, parameter)?.ToList();
    }
}</code></pre>
<ol>
<li>CreateWithTransaction 事务处理</li>
</ol>
<pre class="c#"><code>public bool CreateWithTransaction(EFSample sample, EFSample sample2)
{
    bool result = true;
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        try
        {
            dbcontext.BeginTransaction();//开启事务
            dbcontext.Create(sample);
            dbcontext.Create(sample2);
            dbcontext.Commit();
        }
        catch (Exception)
        {
            dbcontext.Rollback();
            result = false;
        }
    }
 
    return result;
}</code></pre>
<ol>
<li>GetFirstOrDefault 条件查询第一项或默认数据</li>
</ol>
<pre class="c#"><code>public EFSample GetFirstOrDefault(Expression&lt;Func&lt;EFSample, bool&gt;&gt; predicate = null)
{
    using (IDbContext dbcontext = _contextFactory.Create())
    {
        return dbcontext.GetFirstOrDefault&lt;EFSample&gt;(predicate);
    }
}</code></pre>
<ol>
<li>单元测试以及Sql Server脚本</li>
</ol>
<pre><code><code>using MasterChief.DotNet.Core.DapperTests;
using MasterChief.DotNet.Core.DapperTests.Model;
using MasterChief.DotNet.Core.DapperTests.Service;
using MasterChief.DotNet4.Utilities.Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Ninject;
using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Data.SqlClient;
using System.Threading.Tasks;
 
namespace MasterChief.DotNet.Core.Dapper.Tests
{
    [TestClass()]
    public class SampleServiceTests
    {
        private IKernel _kernel = null;
        private ISampleService _sampleService = null;
        private readonly Guid _testID = &quot;2F6D3C43-C2C7-4398-AD2B-ED5E82D78888&quot;.ToGuidOrDefault(Guid.Empty);
        private readonly string _testName = &quot;DapperSample&quot;;
 
        [TestInitialize]
        public void SetUp()
        {
            _kernel = new StandardKernel(new ServiceModule());
            Assert.IsNotNull(_kernel);
 
            _sampleService = _kernel.Get&lt;ISampleService&gt;();
            if (!_sampleService.Exist(ent =&gt; ent.ID == _testID))
            {
                _sampleService.Create(new EFSample() { UserName = _testName, ID = _testID });
            }
        }
 
        /// &lt;summary&gt;
        /// 创建测试
        /// &lt;/summary&gt;
        [TestMethod()]
        public void CreateTest()
        {
            bool actual = _sampleService.Create(new EFSample() { UserName = &quot;Dapper&quot; + DateTime.Now.ToString(&quot;MMddHHmmss&quot;) });
            Assert.IsTrue(actual);
        }
 
        [TestMethod()]
        public void GetFirstOrDefaultTest()
        {
            EFSample actual = _sampleService.GetFirstOrDefault(ent =&gt; ent.ID == _testID);
            Assert.IsNotNull(actual);
        }
 
        [TestMethod()]
        public void GetByKeyIdTest()
        {
            EFSample actual = _sampleService.GetByKeyID(_testID);
            Assert.IsNotNull(actual);
        }
 
        [TestMethod()]
        public void DeleteTest()
        {
            bool actual = _sampleService.Delete(new EFSample() { ID = _testID });
            Assert.IsTrue(actual);
        }
 
        [TestMethod()]
        public void GetListTest()
        {
            List&lt;EFSample&gt; actual = _sampleService.GetList(ent =&gt; ent.Available == true);
            Assert.IsNotNull(actual);
            CollectionAssert.AllItemsAreNotNull(actual);
        }
 
        [TestMethod()]
        public void UpdateTest()
        {
            EFSample sample = new EFSample
            {
                ID = _testID,
                ModifyTime = DateTime.Now,
                UserName = &quot;modify&quot;
            };
            bool actual = _sampleService.Update(sample);
            Assert.IsNotNull(actual);
        }
 
        [TestMethod()]
        public void TransactionSuccessTest()
        {
            EFSample sample = new EFSample
            {
                UserName = &quot;TransactionSuccess1&quot;
            };
 
            EFSample sample2 = new EFSample
            {
                UserName = &quot;TransactionSuccess2&quot;
            };
            bool actual = _sampleService.CreateWithTransaction(sample, sample2);
            Assert.IsTrue(actual);
        }
 
        [TestMethod()]
        public void TransactionFailTest()
        {
            EFSample sample3 = new EFSample
            {
                UserName = &quot;TransactionSuccess3&quot;
            };
 
            EFSample sample4 = new EFSample
            {
                UserName = null
            };
            bool actual = _sampleService.CreateWithTransaction(sample3, sample4);
            Assert.IsFalse(actual);
        }
 
        [TestMethod()]
        public void ExistTest()
        {
            bool actual = _sampleService.Exist(ent =&gt; ent.ID == _testID);
            Assert.IsTrue(actual);
 
            actual = _sampleService.Exist(ent =&gt; ent.UserName == _testName);
            Assert.IsTrue(actual);
 
            actual = _sampleService.Exist(ent =&gt; ent.CreateTime &gt;= DateTime.Now.AddDays(-1));
            Assert.IsTrue(actual);
 
            actual = _sampleService.Exist(ent =&gt; ent.CreateTime &lt;= DateTime.Now);
            Assert.IsTrue(actual);
 
            actual = _sampleService.Exist(ent =&gt; ent.Available == true);
            Assert.IsTrue(actual);
 
            actual = _sampleService.Exist(ent =&gt; ent.Available != true);
            Assert.IsFalse(actual);
        }
 
        [TestMethod()]
        public void SqlQueryTest()
        {
            string sql = @&quot;select * from [dbo].[EFSample]
where CreateTime&gt;=@CreateTime
and Available=@Available
order by CreateTime desc&quot;;
            DbParameter[] parameter = {
                    new SqlParameter(){ ParameterName=&quot;@CreateTime&quot;, Value=DateTime.Now.AddDays(-1) },
                    new SqlParameter(){ ParameterName=&quot;@Available&quot;, Value=true }
                };
            List&lt;EFSample&gt; actual = _sampleService.SqlQuery(sql, parameter);
            Assert.IsNotNull(actual);
            CollectionAssert.AllItemsAreNotNull(actual);
        }
 
        /// &lt;summary&gt;
        /// 多线程测试
        /// &lt;/summary&gt;
        [TestMethod()]
        public void CreateTestThreadTest()
        {
            Task[] tasks = {
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                                Task.Factory.StartNew(() =&gt; CreateTest()),
                            };
            Task.WaitAll(tasks);
        }
    }
}</code></pre>
<pre class="sql"><code>USE [Sample]
GO
 
/****** Object:  Table [dbo].[EFSample]    Script Date: 2019/3/9 22:04:45 ******/
SET ANSI_NULLS ON
GO
 
SET QUOTED_IDENTIFIER ON
GO
 
CREATE TABLE [dbo].[EFSample](
    [ID] [uniqueidentifier] NOT NULL,
    [CreateTime] [datetime] NOT NULL,
    [ModifyTime] [datetime] NOT NULL,
    [Available] [bit] NOT NULL,
    [UserName] [nvarchar](20) NOT NULL,
 CONSTRAINT [EFSamle_PK] PRIMARY KEY CLUSTERED 
(
    [ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
 
EXEC sys.sp_addextendedproperty @name=N&#39;MS_Description&#39;, @value=N&#39;&#39; , @level0type=N&#39;SCHEMA&#39;,@level0name=N&#39;dbo&#39;, @level1type=N&#39;TABLE&#39;,@level1name=N&#39;EFSample&#39;, @level2type=N&#39;COLUMN&#39;,@level2name=N&#39;UserName&#39;
GO</code></pre>
<h4 id="日志">2. 日志</h4>
<hr />
<p>a. 目前实现基于Log4Net的本地文件日志以及Kafka ELK的日志；</p>
<p>b. 基于接口ILogService可以很容易扩展其他日志显示；</p>
<p>代码使用说明</p>
<ol>
<li>配置依赖注入，日志实现方式，这里采用文件日志形式</li>
</ol>
<pre class="c#"><code>using MasterChief.DotNet.Core.Log;
using Ninject.Modules;
 
namespace MasterChief.DotNet.Core.LogTests
{
    public sealed class LogModule : NinjectModule
    {
        public override void Load()
        {
            Bind&lt;ILogService&gt;().To&lt;FileLogService&gt;().InSingletonScope();
        }
    }
}</code></pre>
<ol>
<li>拷贝日志config文件到项目内，并设置属性“始终复制”到输出目录，您可以根据项目需求调整config内容</li>
</ol>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;configuration&gt;
  &lt;configSections&gt;
    &lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler&quot; /&gt;
  &lt;/configSections&gt;
  &lt;log4net&gt;
    &lt;!-- FileLogger --&gt;
    &lt;logger name=&quot;FATAL_FileLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;FATAL_FileAppender&quot; /&gt;
    &lt;/logger&gt;
    &lt;logger name=&quot;ERROR_FileLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;ERROR_FileAppender&quot; /&gt;
    &lt;/logger&gt;
    &lt;logger name=&quot;WARN_FileLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;WARN_FileAppender&quot; /&gt;
    &lt;/logger&gt;
    &lt;logger name=&quot;INFO_FileLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;INFO_FileAppender&quot; /&gt;
    &lt;/logger&gt;
    &lt;logger name=&quot;DEBUG_FileLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;DEBUG_FileAppender&quot; /&gt;
    &lt;/logger&gt;
    &lt;!-- AdoNetLogger --&gt;
    &lt;!--&lt;logger name=&quot;AdoNetLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;AdoNetAppender&quot; /&gt;
    &lt;/logger&gt;--&gt;
    &lt;!-- ConsoleLogger --&gt;
    &lt;logger name=&quot;ConsoleLogger&quot;&gt;
      &lt;level value=&quot;ALL&quot; /&gt;
      &lt;appender-ref ref=&quot;ColoredConsoleAppender&quot; /&gt;
    &lt;/logger&gt;
 
    &lt;!--使用Rolling方式记录日志按照日来记录日志--&gt;
    &lt;appender name=&quot;FATAL_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;
      &lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&gt;
      &lt;file value=&quot;.\log\\FATAL\\&quot; /&gt;
      &lt;!--是否增加文件--&gt;
      &lt;appendToFile value=&quot;true&quot; /&gt;
      &lt;maxSizeRollBackups value=&quot;5&quot; /&gt;
      &lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&gt;
      &lt;rollingStyle value=&quot;Date&quot; /&gt;
      &lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&gt;
      &lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&gt;
      &lt;!--最大文件大小--&gt;
      &lt;maximumFileSize value=&quot;10MB&quot; /&gt;
      &lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&gt;
      &lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;quot;.log&amp;quot;&quot; /&gt;
      &lt;!--是否固定文件名--&gt;
      &lt;staticLogFileName value=&quot;false&quot; /&gt;
      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
        &lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&gt;
      &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;ERROR_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;
      &lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&gt;
      &lt;file value=&quot;.\log\\ERROR\\&quot; /&gt;
      &lt;!--是否增加文件--&gt;
      &lt;appendToFile value=&quot;true&quot; /&gt;
      &lt;maxSizeRollBackups value=&quot;5&quot; /&gt;
      &lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&gt;
      &lt;rollingStyle value=&quot;Date&quot; /&gt;
      &lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&gt;
      &lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&gt;
      &lt;!--最大文件大小--&gt;
      &lt;maximumFileSize value=&quot;10MB&quot; /&gt;
      &lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&gt;
      &lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;quot;.log&amp;quot;&quot; /&gt;
      &lt;!--是否固定文件名--&gt;
      &lt;staticLogFileName value=&quot;false&quot; /&gt;
      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
        &lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&gt;
      &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;WARN_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;
      &lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&gt;
      &lt;file value=&quot;.\log\\WARN\\&quot; /&gt;
      &lt;!--是否增加文件--&gt;
      &lt;appendToFile value=&quot;true&quot; /&gt;
      &lt;maxSizeRollBackups value=&quot;5&quot; /&gt;
      &lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&gt;
      &lt;rollingStyle value=&quot;Date&quot; /&gt;
      &lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&gt;
      &lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&gt;
      &lt;!--最大文件大小--&gt;
      &lt;maximumFileSize value=&quot;10MB&quot; /&gt;
      &lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&gt;
      &lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;quot;.log&amp;quot;&quot; /&gt;
      &lt;!--是否固定文件名--&gt;
      &lt;staticLogFileName value=&quot;false&quot; /&gt;
      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
        &lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&gt;
      &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;INFO_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;
      &lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&gt;
      &lt;file value=&quot;.\log\\INFO\\&quot; /&gt;
      &lt;!--是否增加文件--&gt;
      &lt;appendToFile value=&quot;true&quot; /&gt;
      &lt;maxSizeRollBackups value=&quot;5&quot; /&gt;
      &lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&gt;
      &lt;rollingStyle value=&quot;Date&quot; /&gt;
      &lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&gt;
      &lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&gt;
      &lt;!--最大文件大小--&gt;
      &lt;maximumFileSize value=&quot;10MB&quot; /&gt;
      &lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&gt;
      &lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;quot;.log&amp;quot;&quot; /&gt;
      &lt;!--是否固定文件名--&gt;
      &lt;staticLogFileName value=&quot;false&quot; /&gt;
      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
        &lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&gt;
      &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;DEBUG_FileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;
      &lt;!--文件名,可以相对路径,也可以绝对路径,这里只给定了文件夹--&gt;
      &lt;file value=&quot;.\log\\DEBUG\\&quot; /&gt;
      &lt;!--是否增加文件--&gt;
      &lt;appendToFile value=&quot;true&quot; /&gt;
      &lt;maxSizeRollBackups value=&quot;5&quot; /&gt;
      &lt;!--日志追加类型,Date为按日期增加文件,Size为按大小--&gt;
      &lt;rollingStyle value=&quot;Date&quot; /&gt;
      &lt;!--最小锁定模型以允许多个进程可以写入同一个文件,解决文件独占问题--&gt;
      &lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&gt;
      &lt;!--最大文件大小--&gt;
      &lt;maximumFileSize value=&quot;10MB&quot; /&gt;
      &lt;!--文件命名格式,非日期参数化要进行转义,如自定义文件后缀--&gt;
      &lt;datePattern value=&quot;yyyyMM\\yyyy-MM-dd&amp;quot;.log&amp;quot;&quot; /&gt;
      &lt;!--是否固定文件名--&gt;
      &lt;staticLogFileName value=&quot;false&quot; /&gt;
      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
        &lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level %newline事件来源：%logger%newline日志内容：%message%newline&quot; /&gt;
      &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;!--使用AdoNetAppender方式记录日志按照日来记录日志--&gt;
    &lt;!--&lt;appender name=&quot;AdoNetAppender&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&gt;
      &lt;bufferSize value=&quot;1&quot; /&gt;
      &lt;connectionType value=&quot;System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; /&gt;
      &lt;connectionString value=&quot;DATABASE=Sample;SERVER=.\SQLEXPRESS;UID=sa;PWD=sasa;Connect Timeout=15;&quot; /&gt;
      &lt;commandText value=&quot;INSERT INTO [Log4Net] ([Date],[Host],[Thread],[Level],[Logger],[Message],[Exception]) VALUES (@log_date, @host, @thread, @log_level, @logger, @message, @exception)&quot; /&gt;
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@log_date&quot; /&gt;
        &lt;dbType value=&quot;DateTime&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.RawTimeStampLayout&quot; /&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@thread&quot; /&gt;
        &lt;dbType value=&quot;String&quot; /&gt;
        &lt;size value=&quot;255&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
          &lt;conversionPattern value=&quot;%thread&quot; /&gt;
        &lt;/layout&gt;
      &lt;/parameter&gt;
 
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@host&quot; /&gt;
        &lt;dbType value=&quot;String&quot; /&gt;
        &lt;size value=&quot;50&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
          &lt;conversionPattern value=&quot;%property{log4net:HostName}&quot; /&gt;
        &lt;/layout&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@log_level&quot; /&gt;
        &lt;dbType value=&quot;String&quot; /&gt;
        &lt;size value=&quot;50&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
          &lt;conversionPattern value=&quot;%level&quot; /&gt;
        &lt;/layout&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@logger&quot; /&gt;
        &lt;dbType value=&quot;String&quot; /&gt;
        &lt;size value=&quot;255&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
          &lt;conversionPattern value=&quot;%logger&quot; /&gt;
        &lt;/layout&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@message&quot; /&gt;
        &lt;dbType value=&quot;String&quot; /&gt;
        &lt;size value=&quot;4000&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
          &lt;conversionPattern value=&quot;%message&quot; /&gt;
        &lt;/layout&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
        &lt;parameterName value=&quot;@exception&quot; /&gt;
        &lt;dbType value=&quot;String&quot; /&gt;
        &lt;size value=&quot;4000&quot; /&gt;
        &lt;layout type=&quot;log4net.Layout.ExceptionLayout&quot; /&gt;
      &lt;/parameter&gt;
    &lt;/appender&gt;--&gt;
    &lt;!--使用ConsoleAppender方式记录日志按照日来记录日志--&gt;
    &lt;appender name=&quot;ColoredConsoleAppender&quot; type=&quot;log4net.Appender.ColoredConsoleAppender&quot;&gt;
      &lt;mapping&gt;
        &lt;level value=&quot;INFO&quot; /&gt;
        &lt;foreColor value=&quot;White, HighIntensity&quot; /&gt;
        &lt;backColor value=&quot;Green&quot; /&gt;
      &lt;/mapping&gt;
      &lt;mapping&gt;
        &lt;level value=&quot;DEBUG&quot; /&gt;
        &lt;foreColor value=&quot;White, HighIntensity&quot; /&gt;
        &lt;backColor value=&quot;Blue&quot; /&gt;
      &lt;/mapping&gt;
      &lt;mapping&gt;
        &lt;level value=&quot;WARN&quot; /&gt;
        &lt;foreColor value=&quot;Yellow, HighIntensity&quot; /&gt;
        &lt;backColor value=&quot;Purple&quot; /&gt;
      &lt;/mapping&gt;
      &lt;mapping&gt;
        &lt;level value=&quot;ERROR&quot; /&gt;
        &lt;foreColor value=&quot;Yellow, HighIntensity&quot; /&gt;
        &lt;backColor value=&quot;Red&quot; /&gt;
      &lt;/mapping&gt;
      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;
        &lt;conversionPattern value=&quot;---------------------------------------------------%newline发生时间：%date %newline事件级别：%-5level%newline事件来源：%logger%newline事件行号：%line%newline日志内容：%message%newline&quot; /&gt;
      &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;UdpAppender&quot; type=&quot;log4net.Appender.UdpAppender&quot;&gt;
      &lt;remoteAddress value=&quot;127.0.0.1&quot; /&gt;
      &lt;remotePort value=&quot;7071&quot; /&gt;
      &lt;layout type=&quot;log4net.Layout.XmlLayoutSchemaLog4j&quot; /&gt;
    &lt;/appender&gt;
    &lt;root&gt;
      &lt;appender-ref ref=&quot;UdpAppender&quot; /&gt;
    &lt;/root&gt;
  &lt;/log4net&gt;
&lt;/configuration&gt;</code></pre>
<ol>
<li>单元测试</li>
</ol>
<pre class="c#"><code>using MasterChief.DotNet.Core.LogTests;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Ninject;
 
namespace MasterChief.DotNet.Core.Log.Tests
{
    [TestClass()]
    public class FileLogServiceTests
    {
        private IKernel _kernel = null;
        private ILogService _logService = null;
 
        [TestInitialize]
        public void SetUp()
        {
            _kernel = new StandardKernel(new LogModule());
            Assert.IsNotNull(_kernel);
 
            _logService = _kernel.Get&lt;ILogService&gt;();
        }
 
        [TestMethod()]
        public void DebugTest()
        {
            _logService.Debug(&quot;DebugTest&quot;);
        }
 
        [TestMethod()]
        public void ErrorTest()
        {
            _logService.Error(&quot;ErrorTest&quot;);
        }
 
        [TestMethod()]
        public void FatalTest()
        {
            _logService.Fatal(&quot;FatalTest&quot;);
        }
 
        [TestMethod()]
        public void InfoTest()
        {
            _logService.Info(&quot;InfoTest&quot;);
        }
 
        [TestMethod()]
        public void WarnTest()
        {
            _logService.Warn(&quot;WarnTest&quot;);
        }
    }
}</code></pre>
<h4 id="缓存">3. 缓存</h4>
<hr />
<p>a. 支持本地内存缓存，HttpRequest请求缓存，Redis缓存；</p>
<p>b. 基于ICacheProvider接口，可以很容易扩展其他缓存实现；</p>
<p>代码使用说明：</p>
<ol>
<li><p>配置依赖注入，缓存实现方式，这里采用LocalCacheProvider缓存实现；</p>
<pre class="c#"><code>using MasterChief.DotNet.Core.Cache;
using Ninject.Modules;

namespace MasterChief.DotNet.Core.CacheTests
{
    public sealed class CacheModule : NinjectModule
    {
        public override void Load()
        {
            Bind&lt;ICacheProvider&gt;().To&lt;LocalCacheProvider&gt;().InSingletonScope();
        }
    }
}</code></pre></li>
<li><p>单元测试</p>
<pre class="c#"><code>using MasterChief.DotNet.Core.CacheTests;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Ninject;

namespace MasterChief.DotNet.Core.Cache.Tests
{
    [TestClass()]
    public class LocalCacheProviderTests
    {
        private IKernel _kernel = null;
        private ICacheProvider _cacheProvider = null;
        private readonly string _testCacheKey = &quot;sampleKey&quot;;
        private readonly string _testCache = &quot;sample&quot;;
        private readonly string _testKeyFormat = &quot;login_{0}&quot;;

        [TestInitialize]
        public void SetUp()
        {
            _kernel = new StandardKernel(new CacheModule());
            Assert.IsNotNull(_kernel);

            _cacheProvider = _kernel.Get&lt;ICacheProvider&gt;();
            _cacheProvider.Set(_testCacheKey, _testCache, 10);
        }

        [TestMethod()]
        public void GetTest()
        {
            string actual = _cacheProvider.Get&lt;string&gt;(_testCacheKey);
            Assert.AreEqual(_testCache, actual);
        }

        [TestMethod()]
        public void IsSetTest()
        {
            bool actual = _cacheProvider.IsSet(_testCacheKey);
            Assert.IsTrue(actual);
        }

        [TestMethod()]
        public void RemoveTest()
        {
            _cacheProvider.Remove(_testCacheKey);
            bool actual = _cacheProvider.IsSet(_testCacheKey);
            Assert.IsFalse(actual);
        }

        [TestMethod()]
        public void RemoveByPatternTest()
        {
            string _loginKey = string.Format(_testKeyFormat, &quot;123&quot;);
            _cacheProvider.Set(_loginKey, _testCache, 10);
            bool actual = _cacheProvider.IsSet(_loginKey);
            Assert.IsTrue(actual);
            _cacheProvider.RemoveByPattern(_testKeyFormat);
            actual = _cacheProvider.IsSet(_loginKey);
            Assert.IsFalse(actual);
            actual = _cacheProvider.IsSet(_testCacheKey);
            Assert.IsTrue(actual);
        }

        [TestMethod()]
        public void SetTest()
        {
            _cacheProvider.Set(&quot;sampleSetKey&quot;, &quot;sampleSetCache&quot;, 10);
            bool actual = _cacheProvider.IsSet(&quot;sampleSetKey&quot;);
            Assert.IsTrue(actual);
        }
    }
}
</code></pre></li>
</ol>
<h4 id="配置">4. 配置</h4>
<hr />
<p>a. 目前支持配置文件本地持久化，并且支持配置文件缓存依赖减少读取文件次数；</p>
<p>b. 基于IConfigProvider接口，可以很容易扩展其他配置实现；</p>
<p>代码使用说明：</p>
<ol>
<li><p>配置依赖注入，配置实现方式，这里采用FileConfigProvider缓存实现；</p>
<pre class="c#"><code>using MasterChief.DotNet.Core.Config;
using Ninject.Modules;

namespace MasterChief.DotNet.Core.ConfigTests
{
    public sealed class ConfigModule : NinjectModule
    {
        public override void Load()
        {
            Bind&lt;IConfigProvider&gt;().To&lt;FileConfigService&gt;().InSingletonScope();
            // Bind&lt;ConfigContext&gt;().ToSelf().InSingletonScope();
            Bind&lt;ConfigContext&gt;().To&lt;CacheConfigContext&gt;().InSingletonScope();
        }
    }
}</code></pre></li>
<li><p>扩展配置上下文基于文件依赖</p>
<pre class="c#"><code>using MasterChief.DotNet.Core.Config;
using MasterChief.DotNet4.Utilities.WebForm.Core;
using System;
using System.Web.Caching;

namespace MasterChief.DotNet.Core.ConfigTests
{
    public sealed class CacheConfigContext : ConfigContext
    {
        public override T Get&lt;T&gt;(string index = null)
        {
            if (!(base.ConfigService is FileConfigService))
            {
                throw new NotSupportedException(&quot;CacheConfigContext&quot;);
            }
            string filePath = GetClusteredIndex&lt;T&gt;(index);
            string key = filePath;
            object cacheContent = CacheManger.Get(key);
            if (cacheContent != null)
            {
                return (T)cacheContent;
            }
            T value = base.Get&lt;T&gt;(index);
            CacheManger.Set(key, value, new CacheDependency(filePath));
            return value;
        }
    }
}</code></pre></li>
<li><p>单元测试</p>
<pre class="c#"><code>using MasterChief.DotNet.Core.ConfigTests;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Ninject;
using System.Collections.Generic;

namespace MasterChief.DotNet.Core.Config.Tests
{
    [TestClass()]
    public class FileConfigServiceTests
    {
        private IKernel _kernel = null;
        private IConfigProvider _configProvider = null;
        public ConfigContext _configContext = null;

        [TestInitialize]
        public void SetUp()
        {
            _kernel = new StandardKernel(new ConfigModule());
            Assert.IsNotNull(_kernel);

            _configProvider = _kernel.Get&lt;IConfigProvider&gt;();
            _configContext = _kernel.Get&lt;ConfigContext&gt;();
        }

        [TestMethod()]
        public void SaveConfigTest()
        {
            RedisConfig redisConfig = new RedisConfig
            {
                AutoStart = true,
                LocalCacheTime = 10,
                MaxReadPoolSize = 1024,
                MaxWritePoolSize = 1024,
                ReadServerList = &quot;10&quot;,
                RecordeLog = true,
                WriteServerList = &quot;10&quot;
            };
            redisConfig.RedisItems = new List&lt;RedisItemConfig&gt;
            {
                new RedisItemConfig() { Text = &quot;MasterChief&quot; },
                new RedisItemConfig() { Text = &quot;Config.&quot; }
            };

            _configContext.Save(redisConfig, &quot;prod&quot;);
            _configContext.Save(redisConfig, &quot;alpha&quot;);

            RedisConfig prodRedisConfig = _configContext.Get&lt;RedisConfig&gt;(&quot;prod&quot;);
            Assert.IsNotNull(prodRedisConfig);

            prodRedisConfig = _configContext.Get&lt;RedisConfig&gt;(&quot;prod&quot;);//文件缓存测试
            Assert.IsNotNull(prodRedisConfig);

            RedisConfig alphaRedisConfig = _configContext.Get&lt;RedisConfig&gt;(&quot;alpha&quot;);
            Assert.IsNotNull(alphaRedisConfig);

            DaoConfig daoConfig = new DaoConfig
            {
                Log = &quot;server=localhost;database=Sample;uid=sa;pwd=sasa&quot;
            };
            _configContext.Save(daoConfig, &quot;prod&quot;);
            _configContext.Save(daoConfig, &quot;alpha&quot;);
            DaoConfig prodDaoConfig = _configContext.Get&lt;DaoConfig&gt;(&quot;prod&quot;);
            Assert.IsNotNull(prodDaoConfig);

            DaoConfig alphaDaoConfig = _configContext.Get&lt;DaoConfig&gt;(&quot;alpha&quot;);
            Assert.IsNotNull(alphaDaoConfig);
        }
    }
}</code></pre></li>
<li><p>本地配置会在程序根目录Config下，如图：</p>
<p><img src="./images/[开源]MasterChief  快速开发辅助类库1.png" alt="1552231625890" /></p></li>
<li><p>配置文件基于XML持久化存储，如图：</p>
<p><img src="./images/[开源]MasterChief  快速开发辅助类库2.png" alt="1552231725395" /></p></li>
</ol>
<h4 id="验证码">5. 验证码</h4>
<hr />
<p>a. 派生实现ValidateCodeType抽象类，来自定义验证码样式；</p>
<p>b. 派生实现VerifyCodeHandler抽象类，快速切换需要显示验证码；</p>
<p>代码使用说明：</p>
<ol>
<li><p>Mvc 简单使用如下：</p>
<pre class="c#"><code>/// &lt;summary&gt;
///     处理生成Mvc 程序验证码
/// &lt;/summary&gt;
public sealed class MvcVerifyCodeHandler : VerifyCodeHandler
{
    public override void OnValidateCodeCreated(HttpContext context, string validateCode)
    {
        context.Session[&quot;validateCode&quot;] = validateCode;
    }

    public override byte[] CreateValidateCode(string style)
    {
        ValidateCodeType createCode;
        switch (style)
        {
            case &quot;type1&quot;:
                createCode = new ValidateCode_Style1();
                break;
            default:
                createCode = new ValidateCode_Style1();
                break;
        }

        var buffer = createCode.CreateImage(out var validateCode);
        OnValidateCodeCreated(HttpContext.Current, validateCode);
        return buffer;
    }
}</code></pre></li>
<li><p>WebForm 简单使用如下：</p>
<pre class="c#"><code>/// &lt;summary&gt;
///     WebFormVerifyCodeHandler 的摘要说明
/// &lt;/summary&gt;
public class WebFormVerifyCodeHandler : VerifyCodeHandler, IHttpHandler, IRequiresSessionState
{
    public void ProcessRequest(HttpContext context)
    {
        var validateType = context.Request.Params[&quot;style&quot;];
        var buffer = CreateValidateCode(validateType);
        context.Response.ClearContent();
        context.Response.ContentType = MimeTypes.ImageGif;
        context.Response.BinaryWrite(buffer);
    }

    public bool IsReusable =&gt; false;

    public override void OnValidateCodeCreated(HttpContext context, string validateCode)
    {
        context.Session[&quot;validateCode&quot;] = validateCode;
    }

    public override byte[] CreateValidateCode(string style)
    {
        style = style?.Trim();
        ValidateCodeType createCode;
        switch (style)
        {
            case &quot;type1&quot;:
                createCode = new ValidateCode_Style1();
                break;

            default:
                createCode = new ValidateCode_Style1();
                break;
        }

        var buffer = createCode.CreateImage(out var validateCode);
        OnValidateCodeCreated(HttpContext.Current, validateCode);
        return buffer;
    }
}
</code></pre></li>
</ol>
<h4 id="序列化与反序列化">6. 序列化与反序列化</h4>
<hr />
<p>a. 目前支持Json以及Protobuf两种方式的序列化与反序列化</p>
<p>b. 可以通过实现接口ISerializer扩展实现其他方式；</p>
<p>代码使用说明：</p>
<pre class="c#"><code>private static void Main()
{
    SampleSerializer(new JsonSerializer());
    Console.WriteLine(Environment.NewLine);
    SampleSerializer(new ProtocolBufferSerializer());
    Console.ReadLine();
}
 
private static void SampleSerializer(ISerializer serializer)
{
    #region 单个对象序列化与反序列化
 
    var person = new Person();
    person.Age = 10;
    person.FirstName = &quot;yan&quot;;
    person.LastName = &quot;zhiwei&quot;;
    person.Remark = &quot;ISerializer Sample&quot;;
    var jsonText = serializer.Serialize(person);
    Console.WriteLine($&quot;{serializer.GetType().Name}-Serialize&quot; + jsonText);
 
 
    var getPerson = serializer.Deserialize&lt;Person&gt;(jsonText);
    Console.WriteLine($&quot;{serializer.GetType().Name}-Deserialize&quot; + getPerson);
 
    #endregion
 
    #region 集合序列化与反序列化
 
    var persons = new List&lt;Person&gt;();
    for (var i = 0; i &lt; 10; i++)
        persons.Add(new Person
        {
            FirstName = &quot;Yan&quot;,
            Age = 20 + i,
            LastName = &quot;Zhiwei&quot;,
            Remark = DateTime.Now.ToString(CultureInfo.InvariantCulture)
        });
    jsonText = serializer.Serialize(persons);
    Console.WriteLine($&quot;{serializer.GetType().Name}-Serialize&quot; + jsonText);
 
    var getPersons = serializer.Deserialize&lt;List&lt;Person&gt;&gt;(jsonText);
    foreach (var item in getPersons)
        Console.WriteLine($&quot;{serializer.GetType().Name}-Deserialize&quot; + item);
 
    #endregion
}</code></pre>
<p><img src="./images/[开源]MasterChief  快速开发辅助类库3.png" /></p>
<h4 id="excel导入导出">7. EXCEL导入导出</h4>
<hr />
<p>a. 基于Npoi实现，可以基于接口IExcelManger扩展实现诸如MyXls等；</p>
<p>b. 目前实现了将Excel导出DataTable和DataTable导出到Excel文件；</p>
<p>c. 后续完善诸如整个Excel文件导入导出等；</p>
<p>代码使用说明：</p>
<ol>
<li><p>将DataTable导出到Excel文件</p>
<pre class="c#"><code>private void BtnToExcel_Click(object sender, EventArgs e)
{
    var mockTable = BuilderExcelData();
    _mockExcelPath = $&quot;D:\\ExcelSample{DateTime.Now.FormatDate(12)}.xls&quot;;
    _excelManger.ToExcel(mockTable, &quot;员工信息汇总&quot;, &quot;员工列表&quot;, _mockExcelPath);
    Process.Start(_mockExcelPath);
}

private DataTable BuilderExcelData()
{
    var mockTable = new DataTable();
    mockTable.Columns.Add(new DataColumn {ColumnName = &quot;序号&quot;});
    mockTable.Columns.Add(new DataColumn {ColumnName = &quot;姓名&quot;});
    mockTable.Columns.Add(new DataColumn {ColumnName = &quot;工作单位&quot;});
    mockTable.Columns.Add(new DataColumn {ColumnName = &quot;性别&quot;});
    mockTable.Columns.Add(new DataColumn {ColumnName = &quot;入职时间&quot;});

    for (var i = 0; i &lt; 100; i++)
        mockTable.Rows.Add(i.ToString(), $&quot;张{i}&quot;, $&quot;李{i}计算机公司&quot;, i % 2 == 0 ? &quot;男&quot; : &quot;女&quot;,
            DateTime.Now.AddDays(i));
    return mockTable;
}</code></pre>
<p><img src="./images/[开源]MasterChief  快速开发辅助类库4.png" /></p></li>
<li><p>将Excel文件导出DataTable</p>
<pre class="c#"><code>private void BtnToDataTable_Click(object sender, EventArgs e)
{
    if (string.IsNullOrEmpty(_mockExcelPath))
    {
        MessageBox.Show(&quot;请生成模拟测试EXCEL文件&quot;);
        return;
    }

    var excleTable = _excelManger.ToDataTable(_mockExcelPath, 0, 1, 2);
    var jsonText = _jsonSerializer.Serialize(excleTable);
    MessageBox.Show(jsonText);
}</code></pre></li>
</ol>
<h4 id="文件下载">8. 文件下载</h4>
<hr />
<p>a.支持下载文件加密；</p>
<p>b.支持下载自定义限速；</p>
<p>c.通过DownloadHandler抽象类实现扩展诸如在Asp.Net Mvc实现；</p>
<p>代码使用说明：</p>
<ol>
<li><p>文件下载配置文件</p>
<pre class="xml"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot;?&gt;
&lt;DownloadConfig xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
                FileNameEncryptorIv=&quot;0102030405060708090a0a0c0d010208&quot;
                FileNameEncryptorKey=&quot;DotnetDownloadConfig&quot;
                LimitDownloadSpeedKb=&quot;1024&quot;
                DownLoadMainDirectory=&quot;D:\OneDrive\软件\工具\&quot;&gt;
&lt;/DownloadConfig&gt;</code></pre></li>
<li><p>在WebForm实现DownloadHandler抽象类，迅速实现文件下载</p>
<pre class="c#"><code>public class FileDownloadHandler : DownloadHandler, IHttpHandler
{
    public void ProcessRequest(HttpContext context)
    {
        var fileName = context.Request[&quot;fileName&quot;];
        StartDownloading(context, fileName);
    }

    public bool IsReusable =&gt; false;

    public override void OnDownloadFailed(HttpContext context, string fileName, string filePath, string ex)
    {
        context.Response.Write(ex);
    }

    public override void OnDownloadSucceed(HttpContext context, string fileName, string filePath)
    {
        var result = $&quot;文件[{fileName}]下载成功，映射路径：{filePath}&quot;;
        context.Response.Write(result);
    }
}</code></pre></li>
<li><p>修改Web.Config 文件</p>
<pre class="xml"><code>  &lt;system.web&gt;
    &lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.5&quot;/&gt;
    &lt;httpRuntime targetFramework=&quot;4.5&quot;/&gt;
    &lt;httpHandlers&gt;
      &lt;add verb=&quot;*&quot; path=&quot;FileDownloadHandler.ashx&quot; type=&quot;MasterChief.DotNet.Framework.WbSample.BackHandler.FileDownloadHandler&quot; /&gt;
    &lt;/httpHandlers&gt;
  &lt;/system.web&gt;
  &lt;system.webServer&gt;
    &lt;modules runAllManagedModulesForAllRequests=&quot;true&quot; /&gt;
  &lt;/system.webServer&gt;</code></pre></li>
</ol>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>