<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C# virtual 和 abstract 区别' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C# virtual 和 abstract 区别</center></div><div class='banquan'>原文出处:本文由博客园博主H滴水提供。<br/>
原文连接:https://www.cnblogs.com/houxt/p/11344909.html</div><br>
    <ul>
<li>
<h4>Virtual方法（虚方法）</h4>
</li>
</ul>
<p>　　virtual 关键字用于在基类中修饰方法。virtual的使用会有两种情况：<br />　　情况1：在基类中定义了virtual方法，但在派生类中没有重写该虚方法。那么在对派生类实例的调用中，该虚方法使用的是基类定义的方法。<br />　　情况2：在基类中定义了virtual方法，然后在派生类中使用override重写该方法。那么在对派生类实例的调用中，该虚方法使用的是派生重写的方法。</p>
<ul>
<li>
<h4><strong>Abstract方法（抽象方法）</strong></h4>


</li>


</ul>
<p>　　abstract关键字只能用在抽象类中修饰方法，并且没有具体的实现。抽象方法的实现必须在派生类中使用override关键字来实现。<br />　　接口和抽象类最本质的区别：抽象类是一个不完全的类，是对对象的抽象，而接口是一种行为规范。</p>
<p>&nbsp;</p>
<p style="margin-left: 30px;"><strong>Static</strong>：当一个方法被声明为Static时，这个方法是一个静态方法，编译器会在编译时保留这个方法的实现。也就是说，这个方法属于类，但是不属于任何成员，不管这个类的实例是否存在，它们都会存在。就像入口函数Static void Main，因为它是静态函数，所以可以直接被调用。</p>
<p style="margin-left: 30px;"><strong>Virtual</strong>：当一个方法被声明为Virtual 时，它是一个虚拟方法，直到你使用ClassName variable = new ClassName();声明一个类的实例之前，它都不存在于真实的内存空间中。这个关键字在类的继承中非常常用，用来提供类方法的多态性支持。</p>
<p style="margin-left: 30px;"><strong>overrride</strong>：表示重写 这个类是继承于Shape类。<br /><strong>virtual</strong>，<strong>abstract</strong>是告诉其它想继承于他的类 你可以重写我的这个方法或属性，否则不允许。<br /><strong>abstract</strong>：抽象方法声明使用，是必须被派生类覆写的方法，抽象类就是用来被继承的；可以看成是没有实现体的虚方法；如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法；抽象类不能有实体的。</p>
<p style="margin-left: 30px;"><strong>a)&nbsp;&nbsp;&nbsp;&nbsp; virtual修饰的方法必须有方法实现(哪怕只有一对大括号),abstract修饰的方法不能有实现。</strong></p>
<p style="margin-left: 30px;"><strong>b)&nbsp;&nbsp;&nbsp; virtual可以被子类重写,abstract必须被子类重写。</strong></p>
<p style="margin-left: 30px;"><strong>c)&nbsp;&nbsp;&nbsp;&nbsp; 如果类中的某一函数被abstact修饰,则类名也必须用abstact修饰。</strong></p>
<p style="margin-left: 30px;"><strong>d)&nbsp;&nbsp;&nbsp; Abstract修饰的类不能被创建实例。</strong></p>
<p style="margin-left: 30px;"><strong>e)&nbsp;&nbsp;&nbsp;&nbsp; C#中如果准备在子类重写父类的方法，则该方法在父类中必须用virtual修饰，在子类中必须用overide修饰，避免了程序员在子类中不小心重写了父类父类方法。</strong></p>
<p style="margin-left: 30px;">注：用abstract修饰的类只能被继承不能够被实例化。</p>
<p>&nbsp;</p>
<p style="margin-left: 30px;">virtual和abstract都是用来修饰父类的，通过覆盖父类的定义，让子类重新定义。</p>
<p style="margin-left: 30px;">它们有一个共同点：如果用来修饰方法，前面必须添加public，要不然就会出现编译错误：虚拟方法或抽象方法是不能私有的。毕竟加上virtual或abstract就是让子类重新定义的，而private成员是不能被子类访问的。</p>
<p style="margin-left: 30px;">但是它们的区别很大。（virtual是&ldquo;虚拟的&rdquo;，abstract是&ldquo;抽象的").</p>
<p style="margin-left: 30px;">&nbsp;</p>
<p style="margin-left: 30px;">参考 https://www.cnblogs.com/lvjy-net/p/8467170.html</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>