<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C# 中的值类型和引用类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C# 中的值类型和引用类型</center></div><div class='banquan'>原文出处:本文由博客园博主Vin&#176;提供。<br/>
原文连接:https://www.cnblogs.com/vin-c/p/12043992.html</div><br>
    <p>数据的类型定义了存储数据需要的内存大小及组成该类型的数据成员。类型还决定了对象在内存中的存储位置——栈或堆。</p>
<p>类型被分为两种：值类型和引用类型，这两种类型的对象在内存中的存储方式不同。</p>
<ul>
<li>值类型只需要一段单独的内存，用于存储实际的数据。</li>
<li>引用类型需要两段内存。
<ul>
<li>第一段存储实际的数据，它总是位于堆中。</li>
<li>第二段是一个引用，指向数据在堆中的存放位置。</li>
</ul></li>
</ul>
<p>下图展示了每种类型的单个数据项是如何存储的。对于值类型，数据存放在栈里。对于引用类型，实际数据存放在堆里而引用存放在栈里。</p>
<figure>
  <a href="./images/C# 中的值类型和引用类型0.png" target="_blank"><img src="./images/C# 中的值类型和引用类型0.png"></a>
  <figcaption>数据的存储</figcaption>
</figure>
<h2 id="值类型">值类型</h2>
<p>所有值类型都隐式派生自 <code>System.ValueType</code>，下表显示 C# 值类型：</p>
<table>
<thead>
<tr class="header">
<th>值类型</th>
<th>类别</th>
<th>类型后缀</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bool</code></td>
<td><code>Boolean</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>byte</code></td>
<td>无符号、数字、整型</td>
<td></td>
</tr>
<tr class="odd">
<td><code>char</code></td>
<td>无符号、数字、整型</td>
<td></td>
</tr>
<tr class="even">
<td><code>decimal</code></td>
<td>数字、浮点</td>
<td><code>M</code> 或 <code>m</code></td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td>数字、浮点</td>
<td><code>D</code> 或 <code>d</code></td>
</tr>
<tr class="even">
<td><code>enum</code></td>
<td>枚举</td>
<td></td>
</tr>
<tr class="odd">
<td><code>float</code></td>
<td>数字、浮点</td>
<td><code>F</code> 或 <code>f</code></td>
</tr>
<tr class="even">
<td><code>int</code></td>
<td>带符号、数字、整型</td>
<td></td>
</tr>
<tr class="odd">
<td><code>long</code></td>
<td>带符号、数字、整型</td>
<td><code>L</code> 或 <code>l</code></td>
</tr>
<tr class="even">
<td><code>sbyte</code></td>
<td>带符号、数字、整型</td>
<td></td>
</tr>
<tr class="odd">
<td><code>short</code></td>
<td>带符号、数字、整型</td>
<td></td>
</tr>
<tr class="even">
<td><code>struct</code></td>
<td>用户定义的结构</td>
<td></td>
</tr>
<tr class="odd">
<td><code>uint</code></td>
<td>无符号、数字、整型</td>
<td><code>U</code> 或 <code>u</code></td>
</tr>
<tr class="even">
<td><code>ulong</code></td>
<td>无符号、数字、整型</td>
<td><code>UL</code>、<code>Ul</code>、<code>uL</code>、<code>ul</code>、<code>LU</code>、<code>Lu</code>、<code>lU</code> 或 <code>lu</code></td>
</tr>
<tr class="odd">
<td><code>ushort</code></td>
<td>无符号、数字、整型</td>
<td></td>
</tr>
</tbody>
</table>
<p>值类型直接包含值，换言之，变量引用的位置就是内存中实际存储值的位置。</p>
<p>因此，将一个值赋给变量 1，再将变量 1 赋给变量 2，会在变量 2 的位置创建值的拷贝，而不是引用变量 1 的位置。</p>
<p>这进一步造成更改变量 1 的值不会影响变量 2 的值。</p>
<p>下图对此进行了演示。<code>number1</code> 引用内存中的特定位置，该位置包含值 <code>42</code>。将 <code>number1</code> 的值赋给 <code>number2</code> 之后，两个变量都包含值 <code>42</code>。但修改其中任何一个值都不会影响另一个值。</p>
<figure>
  <a href="./images/C# 中的值类型和引用类型1.png" target="_blank"><img src="./images/C# 中的值类型和引用类型1.png"></a>
  <figcaption>值类型的实例直接包含数据</figcaption>
</figure>
<p>类似地，将值类型的实例传给 <code>Console. WriteLine()</code> 这样的方法也会生成内存拷贝。在方法内部对参数值进行的任何修改都不会影响调用函数中的原始值。</p>
<h2 id="引用类型">引用类型</h2>
<p>引用类型的变量存储对数据存储位置的引用，而不是直接存储数据。要去那个位置才能找到真正的数据。所以为了访问数据，“运行时”<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> 要先从变量中读取内存位置，再“跳转”到包含数据的内存位置。</p>
<p>为引用类型的变量分配实际数据的内存区域称为堆（heap）。</p>
<figure>
  <a href="./images/C# 中的值类型和引用类型2.png" target="_blank"><img src="./images/C# 中的值类型和引用类型2.png"></a>
  <figcaption>引用类型的实例指向堆</figcaption>
</figure>
<p>由于引用类型只拷贝对数据的引用，所以两个不同的变量可引用相同的数据。因此，对一个变量执行的操作会影响另一个变量所引用的对象。无论赋值还是方法调用都会如此。因此，如果在方法内部更改引用类型的数据，方法执行完成之后，将看到更改后的结果。</p>
<h2 id="总结">总结</h2>
<p>一个类型要么是值类型，要么是引用类型。区别在于数据存储的方式：对于值类型，数据存放在栈里。对于引用类型，实际数据存放在堆里而引用存放在栈里。</p>
<p>引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两个变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量。</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>“运行时”的内容请参考这篇文章：<a href="https://www.vinanysoft.com/c-sharp-basics/introducing/managed-execution-and-the-common-language-infrastructure/" class="uri">https://www.vinanysoft.com/c-sharp-basics/introducing/managed-execution-and-the-common-language-infrastructure/</a><a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>