<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[翻译] NumSharp的数组切片功能 []' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[翻译] NumSharp的数组切片功能 []</center></div><div class='banquan'>原文出处:本文由博客园博主solenovex提供。<br/>
原文连接:https://www.cnblogs.com/cgzl/p/10925023.html</div><br>
    <p>原文地址：<a href="https://medium.com/scisharp/slicing-in-numsharp-e56c46826630">https://medium.com/scisharp/slicing-in-numsharp-e56c46826630</a></p>
<p>&nbsp;</p>
<p>翻译初稿（英文水平有限，请多包涵）：</p>
<div class="OutlineElement Ltr SCXW135368893 BCX0"><span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">由于<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW135368893 BCX0">Numsharp<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">新推出了<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="none">数组切片<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">这个牛逼的功能，所以<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">.NET<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">社区距离拥有强大的开源机器学习平台又近了一步。<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></div>
<div class="OutlineElement Ltr SCXW135368893 BCX0"><span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></div>
<div class="OutlineElement Ltr SCXW135368893 BCX0"><span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">Python<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">之所以是机器学习的首选语言，部分原因就是因为它拥有一些牛逼的库，例如<a class="Hyperlink SCXW135368893 BCX0" href="https://www.numpy.org/" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">NumPy</span></span></a><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">和<a class="Hyperlink SCXW135368893 BCX0" href="https://www.tensorflow.org/" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">Tensorflow</span></span></a><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">。<span class="SpellingError SCXW135368893 BCX0">与此同时，<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW135368893 BCX0">C<span class="NormalTextRun SCXW135368893 BCX0">#<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">开发人员也迫切需要用于机器学习和数据科学的强大开源库。而<a class="Hyperlink SCXW135368893 BCX0" href="https://github.com/SciSharp/NumSharp" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">NumSharp</span></span></a><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">，<span class="SpellingError SCXW135368893 BCX0">这个由<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<a class="Hyperlink SCXW135368893 BCX0" href="https://github.com/SciSharp" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">SciSharp&nbsp;STACK<span class="TextRun Underlined SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">这个开源组织</span></span></span></span></a><span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">全力推动的，要把<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">NumPy<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">移植到<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C#<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的这个项目<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">，由于其最近全面实现了切片技术，从而向该目标迈进了一大步。该技术允许对<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">n<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">维数组随意的创建子集，并将其作为对原始数据的高效视图。因为这些，使得它与<a class="Hyperlink SCXW135368893 BCX0" href="https://github.com/SciSharp/TensorFlow.NET" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW135368893 BCX0">TensorFlow.net</span></span></a><span class="TextRun Underlined SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="SpellingError SCXW135368893 BCX0">一起成为了<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW135368893 BCX0">C<span class="NormalTextRun SCXW135368893 BCX0">#<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">中机器学习的有用工具。<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></div>
<div class="OutlineElement Ltr SCXW135368893 BCX0">
<p class="Paragraph SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></p>
</div>
<div class="OutlineElement Ltr SCXW135368893 BCX0">
<h1 class="Paragraph SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">到底有啥大不了的？<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></h1>
</div>
<div class="OutlineElement Ltr SCXW135368893 BCX0">
<p class="Paragraph SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">如果你没用过<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">NumPy<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">，你可能不知道切片技术有多好用，<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;Python<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">数组允许通过对一定范围对元素进行索引来返回数组的一个切片，其索引操作是这样的：<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">a[<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW135368893 BCX0">start<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW135368893 BCX0">:end:step<span class="NormalTextRun SCXW135368893 BCX0">]<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">。但是，只有使用<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">NumPy<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">复杂巧妙的数组实现，切片才成为一种真正强大的数据操作技术，若没有这种技术，机器学习或数据科学就无法想象了。<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<div class="OutlineElement Ltr SCXW135368893 BCX0">
<p class="Paragraph SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></p>
</div>
<div class="OutlineElement Ltr SCXW135368893 BCX0">
<p class="Paragraph SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">对于那些不能或不想因为机器学习就转换到<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">Python<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">语言的人来说，幸运的事情发生了，<span class="TextRun Highlight SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW135368893 BCX0">我对此也很羡慕，<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW135368893 BCX0">&nbsp;<span class="SpellingError SCXW135368893 BCX0">NumSharp<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">将这种能力带入了<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">.NET<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">世界里。作为<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW135368893 BCX0">NumSharp<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的开发人员之一，我将向您展示几个重要的切片用例，并附有<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C#<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的示例代码段。首先请注意，由于语言语法的不同，在<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C#<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">中无法以与<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">Python<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">相同的方式进行索引。但是，我们决定保留<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">Python<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">里切片定义的语法，因此在<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C#<span class="TextRun SCXW135368893 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">里，我们使用字符串来索引切片。<span class="TextRun SCXW135368893 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;&nbsp;<span class="EOP SCXW135368893 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<div class="page" title="Page 2">&nbsp;<img src="./images/[翻译] NumSharp的数组切片功能 []0.png" alt="" width="800" />
<p>&nbsp;</p>
<p><img src="./images/[翻译] NumSharp的数组切片功能 []1.png" alt="" /></p>
<p><span class="TextRun SCXW189589596 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW189589596 BCX0">而使用<span class="TextRun SCXW189589596 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW189589596 BCX0">NumSharp<span class="TextRun SCXW189589596 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW189589596 BCX0">写出的<span class="TextRun SCXW189589596 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW189589596 BCX0">C#<span class="TextRun SCXW189589596 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW189589596 BCX0">代码也是差不多一样的。但请注意，这里有一个细微的差别是，这里的切片使用的是字符串作为索引器的参数进行的索引。<span class="EOP SCXW189589596 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></p>
<div class="OutlineElement Ltr SCXW157468980 BCX0">
<p class="Paragraph SCXW157468980 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW157468980 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW157468980 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></p>
<p class="Paragraph SCXW157468980 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW157468980 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><img src="./images/[翻译] NumSharp的数组切片功能 []2.png" alt="" width="800" /></span></p>
<p class="Paragraph SCXW157468980 BCX0" lang="EN-US" xml:lang="EN-US"><img src="./images/[翻译] NumSharp的数组切片功能 []3.png" alt="" /></p>
<p>正如您所看到的，<span class="TextRun SCXW48840318 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW48840318 BCX0">NumSharp<span class="TextRun SCXW48840318 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">团队花了很多的精力来保证代码尽可能的与<span class="TextRun SCXW48840318 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">Python<span class="TextRun SCXW48840318 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">相似。 这非常重要，因为这样的话，现有的依赖于<span class="TextRun SCXW48840318 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">NumPy<span class="TextRun SCXW48840318 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">的代码就可以很轻松的移植到<span class="TextRun SCXW48840318 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">C#<span class="TextRun SCXW48840318 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW48840318 BCX0">上去了。<span class="EOP SCXW48840318 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<h1><span class="TextRun SCXW157468980 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">用例<span class="TextRun SCXW157468980 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">:&nbsp;<span class="TextRun SCXW157468980 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">使用同一数据的多个视图<span class="EOP SCXW157468980 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></h1>
</div>
<p><img src="./images/[翻译] NumSharp的数组切片功能 []4.png" alt="" width="800" /></p>
<div class="OutlineElement Ltr SCXW184242134 BCX0">
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW184242134 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">对于运行时性能，尤其是对于大规模的数据集而言，能够在不进行复制的情况下仅对函数传入和传出原始数据的本地部分（例如：一张大图片中的一部分）是至关重要的。切片使用局部坐标进行索引的，因此您的算法无需了解数据的全局结构，这样就有效地简化了您的工作，并确保尽可能高的性能，因为避免了不必要的复制。<span class="EOP SCXW184242134 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></p>
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US">&nbsp;</p>
<h1 class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US">用例：稀疏视图和递归切片<span class="EOP SCXW184242134 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span>&nbsp;</h1>
</div>
<div class="OutlineElement Ltr SCXW184242134 BCX0">
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW184242134 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">除了对切片的范围指定<span class="TextRun SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">start<span class="TextRun SCXW184242134 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">和<span class="TextRun SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">end<span class="TextRun SCXW184242134 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">之外，再通过指定它的步长<span class="TextRun SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="TextRun SCXW184242134 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">，就可以创建数组的稀疏视图了。这是一个连<span class="TextRun SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C# 8.0<span class="TextRun SCXW184242134 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">新的数组切片语法都没有的功能（据我所知）。在使用交错数据时，此功能变得非常重要。您可以通过设计算法来让它们处理连的续数据并为它们提供模拟连续数据源的稀疏切片，从而尽可能降低算法的复杂性。<span class="EOP SCXW184242134 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></p>
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US"><img src="./images/[翻译] NumSharp的数组切片功能 []5.png" alt="" width="800" /></p>
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW205839800 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW205839800 BCX0">切片可以进一步切片，如果您使用高维数据的话，这也将是一个非常重要的功能。同时这也有助于减少算法的复杂性，因为通过递归切片减少了数据的维数。<span class="EOP SCXW205839800 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></p>
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US">&nbsp;</p>
<h1 class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW205839800 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="TextRun SCXW3215969 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW3215969 BCX0">用例：高效地处理高维数据<span class="EOP SCXW3215969 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></h1>
<p class="Paragraph SCXW184242134 BCX0" lang="EN-US" xml:lang="EN-US"><img src="./images/[翻译] NumSharp的数组切片功能 []6.png" alt="" width="800" /></p>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">如果您需要将数据数组视为一个卷，并在不需要进行令人烦躁的坐标转换计算的情况下使用其中的某些部分，那么<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="ContextualSpellingAndGrammarError SCXW162102896 BCX0">.reshape<span class="NormalTextRun SCXW162102896 BCX0">()<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">方法就是您的朋友。<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></p>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">所有由<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="ContextualSpellingAndGrammarError SCXW162102896 BCX0">.reshape<span class="NormalTextRun SCXW162102896 BCX0">()<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">或切片操作创建的数组都只是原始数据的视图。当您对视图的元素进行迭代、读取或写入时，其实您访问的是原始的数据数组。很显然，<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW162102896 BCX0">NumSharp<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">为您做了相应的索引变换，所以您可以使用相对的坐标对切片进行索引。<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></p>
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US">&nbsp;</p>
<h1 class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">用例：在无任何额外成本的情况下颠倒元素的顺序<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></h1>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">使用值为负数的步长<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">可以高效的反转切片的顺序。它的优点是不需要复制或列举数据就可以完成此操作，就像<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW162102896 BCX0">IEnumerable.Reverse<span class="NormalTextRun SCXW162102896 BCX0">()&nbsp;<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">一样。区别在于，视图（就是指<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="ContextualSpellingAndGrammarError SCXW162102896 BCX0">a[<span class="NormalTextRun SCXW162102896 BCX0">"::-1"]<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的操作结果）以相反的顺序显示数据，此外您无需对其进行列举就可以索引到该反转序列。<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US">&nbsp;</p>
<h1 class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">用例：通过减少维度来降低复杂性<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></h1>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">当处理高维数据时，该数据的算法也会变得非常复杂。在处理<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW162102896 BCX0">NumSharp<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW162102896 BCX0">NDArray<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW162102896 BCX0">.<span class="SpellingError SCXW162102896 BCX0">ToString<span class="NormalTextRun SCXW162102896 BCX0">()&nbsp;<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">方法时（这个方法可以打印出任意高维卷）我注意到该算法通过系统地和递归地将<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW162102896 BCX0">(N-<span class="ContextualSpellingAndGrammarError SCXW162102896 BCX0">1)D<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">卷切出<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">ND-<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">卷等诸如此类的方式简单而优雅的取得了结果。<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">通过在可返回低维子卷的范围符号上使用<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW162102896 BCX0">NumSharp<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">的索引符号进行切片，才使这种分而治之的方法变得可行。<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></p>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></p>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<h1 class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">范围符号 vs 索引符号<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></h1>
</div>
<div class="OutlineElement Ltr SCXW162102896 BCX0">
<p class="Paragraph SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">范围符号<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW162102896 BCX0">[&ldquo;<span class="SpellingError SCXW162102896 BCX0">start:stop:step<span class="NormalTextRun SCXW162102896 BCX0">&rdquo;]<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">允许您访问具有相同维度给定卷的子范围。所以即使只划出二维矩阵的一列，仍然可以得到只有一列的二维矩阵。下面这一小段<span class="TextRun SCXW162102896 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C#<span class="TextRun SCXW162102896 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">代码就展示了这一点：<span class="EOP SCXW162102896 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></p>
</div>
<p><img src="./images/[翻译] NumSharp的数组切片功能 []7.png" alt="" width="800" /></p>
<p><span class="TextRun SCXW81032482 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW81032482 BCX0">数组字符索引重载可以实现在一个N维数组里从特定位置创建视图。<span class="TextRun SCXW81032482 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW81032482 BCX0"><span class="TextRun SCXW81032482 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW81032482 BCX0"><span class="TextRun SCXW81032482 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW81032482 BCX0"><span class="TextRun SCXW81032482 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto"><span class="NormalTextRun SCXW81032482 BCX0">因此，用索引符号从二维矩阵中分割出一个列，可以得到一个一维向量：<span class="EOP SCXW81032482 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></p>
<p><img src="./images/[翻译] NumSharp的数组切片功能 []8.png" alt="" width="800" /></p>
<p><img src="./images/[翻译] NumSharp的数组切片功能 []9.png" alt="" /></p>
<div class="OutlineElement Ltr SCXW191820257 BCX0">
<p class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">如果您一眼也没有发现差异，那么下面这两个切片定义，&nbsp;<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW191820257 BCX0">ange<span class="NormalTextRun SCXW191820257 BCX0">&nbsp;[<span class="ContextualSpellingAndGrammarError SCXW191820257 BCX0">":,<span class="NormalTextRun SCXW191820257 BCX0">2:3"] vs index [":,2"]<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">，它们的结果是大不相同的。<a class="Hyperlink SCXW191820257 BCX0" href="https://github.com/SciSharp/NumSharp/wiki" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW191820257 BCX0">NumSharp wiki</span></span></a><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="SpellingError SCXW191820257 BCX0">提供了新切片表示法的完整参考<span class="NormalTextRun SCXW191820257 BCX0">。<span class="EOP SCXW191820257 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></p>
<p class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US">&nbsp;</p>
<h1 class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">附注：<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW191820257 BCX0">ArraySlice<span class="NormalTextRun SCXW191820257 BCX0">&nbsp;&lt;T&gt;<span class="EOP SCXW191820257 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></h1>
</div>
<div class="OutlineElement Ltr SCXW191820257 BCX0">
<p class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">在实现<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">N<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">维视图的切片时，我得出这样一个结论，对于<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">.NET<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">中的许多其他领域来说它可能很有趣，因此我将它分解出一个自己的独立库<a class="Hyperlink SCXW191820257 BCX0" href="https://github.com/henon/SliceAndDice" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW191820257 BCX0">SliceAndDice</span></span></a><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW191820257 BCX0">。<span class="SpellingError SCXW191820257 BCX0">它里面有个东西叫做<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW191820257 BCX0">ArraySlice<span class="NormalTextRun SCXW191820257 BCX0">&nbsp;&lt;T&gt;<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">，它是对所有索引的<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">C<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">＃数据结构（如<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="ContextualSpellingAndGrammarError SCXW191820257 BCX0">T[<span class="NormalTextRun SCXW191820257 BCX0">]<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">或<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW191820257 BCX0">IList<span class="NormalTextRun SCXW191820257 BCX0">&lt;T&gt;<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">）的一个轻量级包装，此外它还允许您使用相同的塑形，切片和视图机制，并且无需进行任何其他的重度数值计算。它只使用了几百行代码就漂亮简洁的完成了切片的壮举。<span class="EOP SCXW191820257 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<div class="OutlineElement Ltr SCXW191820257 BCX0">
<p class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">&nbsp;<span class="EOP SCXW191820257 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></p>
</div>
<div class="OutlineElement Ltr SCXW191820257 BCX0">
<h1 class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">综上</span></h1>
</div>
<div class="OutlineElement Ltr SCXW191820257 BCX0">
<p class="Paragraph SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US"><span class="TextRun EmptyTextRun SCXW191820257 BCX0" data-contrast="auto"><a class="Hyperlink SCXW191820257 BCX0" href="https://github.com/SciSharp/NumSharp" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW191820257 BCX0">NumSharp</span></span></a><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="SpellingError SCXW191820257 BCX0">最近被赋予了切片和视图机制，同样就是这些机制让<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW191820257 BCX0">NumPy<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">成为<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">Python<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">机器学习生态最重要的库之一。<a class="Hyperlink SCXW191820257 BCX0" href="https://github.com/SciSharp" rel="noreferrer" target="_blank"><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW191820257 BCX0">SciSharp Stack</span></span></a><span class="TextRun Underlined SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW191820257 BCX0">作为一个开源组织，目前只有少数技术娴熟的开发人员，但他们却非常努力地要为<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto">.NET<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">世界带来同样的魔力。<span class="TextRun SCXW191820257 BCX0" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="SpellingError SCXW191820257 BCX0">NumSharp<span class="TextRun SCXW191820257 BCX0" lang="ZH-CN" xml:lang="ZH-CN" data-contrast="auto">最近的这次改进就是实现这一目标的重要基石。<span class="EOP SCXW191820257 BCX0" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
</div>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>