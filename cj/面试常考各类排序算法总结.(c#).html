<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修面试常考各类排序算法总结.(c#)' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>面试常考各类排序算法总结.(c#)</center></div><div class='banquan'>原文出处:本文由博客园博主whitebbai提供。<br/>
原文连接:https://www.cnblogs.com/whitebai/p/11544126.html</div><br>
    <h2>前言</h2>
<p>面试以及考试过程中必会出现一道排序算法面试题，为了加深对排序算法的理解，在此我对各种排序算法做个总结归纳。</p>
<h2>1、冒泡排序算法(BubbleSort)</h2>
<h4>1.1 算法描述</h4>
<p>（1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>（2）对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
<p>（3）针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>（4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p><span class="sup--normal" data-sup="1">&nbsp; 最好时间复杂度O（n） 最坏时间复杂度O（n2）</span></p>
<h4><span class="sup--normal" data-sup="1">1.2 动图演示</span></h4>
<p><span class="sup--normal" data-sup="1"><img src="./images/面试常考各类排序算法总结.(c#)0.png" alt="" /></span></p>
<h4><span class="sup--normal" data-sup="1">1.3 C#代码实现</span></h4>
<div class="cnblogs_code">
<pre><code>public Class SortDemo
{
     public void BubbleSort(int[] arr)
     {
            int temp=0;
          //需要走arr.Length-1 趟
           for(int i=0;i&lt;arr.Length-1;i++)
           {
                 //每一趟需要比较次数
                 for(int j=0,j&lt;arr.Length-i-1;j++)
                 {
                     //升序排序
                      if(arr[j]&gt;arr[j+1])
                      {
                               temp=arr[j];//将较大的变量保存在临时变量
                               arr[j]=arr[j+1]；
                               arr[j+1]=temp;
                       }   
                 }
            }
         
     }
}</pre>
</div>
<p>&nbsp;</p>
<h2>2、直接插入排序(InsertionSort)</h2>
<h4>2.1 算法描述</h4>
<p>（1）从第一个元素开始，该元素可以认为已经被排序；</p>
<p>（2）取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
<p>（3）如果该元素（已排序）大于新元素，将该元素移到下一位置；</p>
<p>（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p>
<p>（5） 将新元素插入到该位置后；</p>
<p>（6）重复步骤2~5。</p>
<h4>2.2 动图演示</h4>
<p><img src="./images/面试常考各类排序算法总结.(c#)1.png" alt="" /></p>
<h4>2.3 C#代码实现</h4>
<div class="cnblogs_code">
<pre><code>public Class SortDemo
{
      public void InsertionSort(int[] arr)
      {
             int temp=0;
             //遍历待插入的数(从第二位开始)
             for(int i=1;i&lt;arr.Length;i++)
             {</pre>
<pre><code>　　　　　　　　　　　　temp=arr[i];//待插入的数</pre>
<pre><code>　　　　　　　　　　　　int j=i-1;//（j为已排序的待插入的位置序号）<br />                     
                     //若已排序的数大于待插入数，则往后移一位
                     while(j&gt;=0&amp;&amp;arr[j]&gt;temp)
                     {
                            arr[j+1]=arr[j];
                            j--;
                      }
                     arr[j+1]=temp;//将待插入的数放入插入位置
              }
      }
}</pre>
</div>
<h2>3、选择排序(SelectionSort)</h2>
<h4>3.1 算法描述</h4>
<p>&nbsp;选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&nbsp;</p>
<p>（1）初始状态：无序区为R[1..n]，有序区为空；</p>
<p>（2）第i趟排序(i=1,2,3&hellip;n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</p>
<p>（3）n-1趟结束，数组有序化了。</p>
<h4>3.2 动图演示</h4>
<p><img src="./images/面试常考各类排序算法总结.(c#)2.png" alt="" /></p>
<h4>3.3 C#代码实现</h4>
<div class="cnblogs_code">
<pre><code>public void SelectionSort(int[] arr)
     {<br />         int temp;
         for(int i=0;i&lt;arr.Length-1;i++)<br />         {<br />             int minVal=arr[i];<br />             int minIndex=i;<br />             for(int j=i+1;j&lt;arr.Length;j++)<br />             {<br />                 if(minVal&gt;arr[j])<br />                 { <br />                    minVal=arr[j];<br />                    minIndex=j;<br />                 }<br />             }<br />             temp=arr[i];<br />             arr[i]=minVal;<br />             arr[minIndex]=temp;<br />         }
 
     }
}</pre>
</div>
<h2>&nbsp;4、快速排序(QuickSort)</h2>
<h4>4.1 算法描述</h4>
<p>（1）从数列中挑出一个元素，称为 &ldquo;基准&rdquo;（pivot）；</p>
<p>（2）重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
<p>（3）递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p>&nbsp; &nbsp;快速排序法是采用递归的方式对待排序的数列进行若干次的操作,每次操作使得被操作的数列部分以某个元素为分界值分成两部分,一部分小于该分界值,另一部分大于该分界值.该分界值一般被称为"枢轴". 一般先以左边第一个数作为分界值，将数列按该分界值分成左右两 部分，左边部分小于该分界值，右边部分大于该分界值，然后再对左右两部分做重复的操作，直到最后完成排序。</p>
<p class="font-color">&nbsp; 以数列 14,11,25,37,9,28 为例,详细描述执行一趟快速排序的算法:</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,选择待排序数列的枢轴,一般以数列的首元素作为枢轴.此数列中,我们选择首元素14作为枢轴,nPivot = 14.</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2,设定两个指针 i 和 j ,分别指向数列的首元素和尾元素. i 指向首元素14, j 指向尾元素28.示意图如下:</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="./images/面试常考各类排序算法总结.(c#)3.png" alt="" width="400" height="120" border="0" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3,向前移动尾指针 j ,使其指向从数列尾部算起首个小于枢轴(即14)的元素,并将该元素置换到头指针 i 指向的位置._nArray[i] =_nArray[j].示意图如下:</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="./images/面试常考各类排序算法总结.(c#)4.png" alt="" width="400" height="165" border="0" /></p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首次执行该操作时 i 指针指向处的值实际上就是枢轴的值,此处的操作可以理解为 i 指针指向处的值已在之前被置换到枢轴中,此时, i 指向处已经是一个空位,在此时用找到的小于枢轴的元素填在此处.</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4,向后移动头指针 i ,使其指向从数列头部算起首个大于枢轴(即14)的元素,并将该元素置换到尾指针 j 指向的位置._nArray[j] =_nArray[i].示意图如下:</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="./images/面试常考各类排序算法总结.(c#)5.png" alt="" width="400" height="170" border="0" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处同样可以理解为 j 指针指向处的值已在上一步操作中置换了出去. j 处已是一个空位.</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5,如此重复执行步骤3和步骤4,直至 i==j 时结束该循环.</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6,退出了该循环后, i 与 j 必定指向同一位置.在该位置的前部元素,其值均小于枢轴.而在该位置的后部元素,其值均大于枢轴.显而易见,此时 i 和 j 同时指向的位置就应该是枢轴的"新家"._nArray[i]=nPivot.如下图:</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="./images/面试常考各类排序算法总结.(c#)6.png" alt="" width="400" height="140" border="0" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此,一趟排序结束.待排序数列的首元素将该数列分成了比其小和比其大的两部分.如下图:</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="./images/面试常考各类排序算法总结.(c#)7.png" alt="" width="400" height="105" border="0" /></p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着,我们对这一大一小两部分子数列执行相同的排序操作.</p>
<p class="font-color">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此"递归",直至对整个数列完成排序操作.</p>
<h4>4.2 动图演示</h4>
<p><img src="./images/面试常考各类排序算法总结.(c#)8.png" alt="" /></p>
<h4>4.3 c#代码实现</h4>
<div class="cnblogs_code">
<div>class Program</div>
<div>{</div>
<div>&nbsp; &nbsp; &nbsp; static void Main(string[] args)</div>
<div>&nbsp; &nbsp; &nbsp; {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; Console.WriteLine("请输入待排序数列(以\",\"分割):");</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; int[] arr = new int[] { 10, 11, 44, 9, 8, 19, 45, 20, 24, 11, 3, 7 };</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; Sort(arr, 0, arr.Length - 1);</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; foreach (var i in arr)</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; {</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Console.WriteLine(i.ToString());</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp; }</div>
<div>&nbsp; &nbsp; &nbsp; &nbsp;}</div>
<div style="margin-left: 30px;">
<p style="margin-left: 30px;">/// &lt;summary&gt;<br />        /// 排序<br />        /// &lt;/summary&gt;<br />        /// &lt;param name="array"&gt;要排序的数组&lt;/param&gt;<br />        /// &lt;param name="low"&gt;下标开始位置，向右查找&lt;/param&gt;<br />        /// &lt;param name="high"&gt;下标开始位置，向左查找&lt;/param&gt;<br />        public static void Sort(int[] array, int low, int high)<br />        {<br />&nbsp; if (low &gt;= high)<br />&nbsp; &nbsp;return;<br />&nbsp; //完成一次单元排序<br />&nbsp; int index = SortUnit(array, low, high);<br />&nbsp; //递归调用，对左边部分的数组进行单元排序<br />&nbsp; Sort(array, low, index - 1);<br />&nbsp; //递归调用，对右边部分的数组进行单元排序<br />&nbsp; Sort(array, index + 1, high);<br />    }</p>
<p style="margin-left: 30px;">&nbsp;/// &lt;summary&gt;</p>
<p style="margin-left: 30px;"><em id="__mceDel">/// 单元排序</em></p>
<p style="margin-left: 30px;"><em id="__mceDel"><em id="__mceDel">        /// &lt;/summary&gt;<br />        /// &lt;param name="array"&gt;要排序的数组&lt;/param&gt;<br />        /// &lt;param name="low"&gt;下标开始位置，向右查找&lt;/param&gt;<br />        /// &lt;param name="high"&gt;下标开始位置，向右查找&lt;/param&gt;<br />        /// &lt;returns&gt;每次单元排序的停止下标&lt;/returns&gt;<br />        public static int SortUnit(int[] array, int low, int high)<br />        {<br />&nbsp;int key = array[low];//基准数<br />&nbsp; while (low &lt; high)<br />&nbsp; {<br />&nbsp; &nbsp;//从high往前找小于或等于key的值<br />&nbsp; &nbsp;while (low &lt; high &amp;&amp; array[high] &gt; key)<br />&nbsp; &nbsp; &nbsp;high--;<br />&nbsp; &nbsp;//比key小开等的放左边<br />&nbsp; &nbsp;array[low] = array[high];<br />&nbsp; &nbsp;//从low往后找大于key的值<br />&nbsp; &nbsp;while (low &lt; high &amp;&amp; array[low] &lt;= key)<br />&nbsp; &nbsp; low++;<br />&nbsp; &nbsp;//比key大的放右边<br />&nbsp; &nbsp;array[high] = array[low];<br />&nbsp;}<br />            //结束循环时，此时low等于high，左边都小于或等于key，右边都大于key。将key放在游标当前位置。 <br />&nbsp; array[low] = key;<br />&nbsp; return high;<br />        }</em></em></p>


</div>
<div>}</div>


</div>
<p>文章参考摘自：<a href="https://www.cnblogs.com/yundan/p/4022056.html">https://www.cnblogs.com/yundan/p/4022056.html</a>&nbsp; &nbsp;<a href="https://www.cnblogs.com/geduocoding/p/7097870.html">https://www.cnblogs.com/geduocoding/p/7097870.html</a></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>