<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【C#】【分享】 XX分钟学会C#' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【C#】【分享】 XX分钟学会C#</center></div><div class='banquan'>原文出处:本文由博客园博主从南到北ss提供。<br/>
原文连接:https://www.cnblogs.com/younShieh/p/10945264.html</div><br>
    <p><strong><a href="https://www.cnblogs.com/younShieh/p/10945264.html">原文地址 https://www.cnblogs.com/younShieh/p/10945264.html</a></strong></p>
<p> </p>
<p>  前几天发现了一个GitHub上的项目，该项目名为“learn x in y minutes”，这个名称就很简明扼要——“y分钟学习xxx”，一看就很牛。对于这种大神级别的人物我是非常憧憬的，怀着欣喜和敬畏的心态，点下了star，然后我就把网页关了。。。不要问我为什么不趁热学习一下，毕竟众所周知，收藏就等于学会了嘛。</p>
<p> </p>
<p>  n天后的今天，我终于想起来有这么一个伟大的项目还躺在我的列表里，我又把它翻了出来，学习了一下该项目里的c#文档。果然不负众望，收获颇丰。正如作者所说的：</p>
<blockquote>
<p>Code documentation written as code! How novel and totally my idea!</p>
</blockquote>
<p>  确实是很新奇的讲解方法，几百行代码就把C#的很多常用基础语法讲了个遍，而且是以代码的形式，没有长篇大论，用代码讲语法才是最直观的。但是觉得不太适合初学者，还是适合有一定基础的人，不然一句都看不懂，也没有释义，可不得在心里把作者骂个十几遍。</p>
<p> </p>
<p>  废话不多说，<a href="https://github.com/adambard/learnxinyminutes-docs">项目地址：https://github.com/adambard/learnxinyminutes-docs</a></p>
<p> </p>
<p>  这个项目里的c#代码在运行时存在一些简单的问题，我自作主张的进行了修改。修改后的代码贴在文章末尾了。</p>
<p> </p>
<p>  把这个文档和项目分享出来，希望能对像我一样的新手玩家有所帮助。</p>
<p> </p>
<pre><code><code>
// 单行注释以 // 开始
/*
多行注释是这样的
*/
/// &lt;summary&gt;
/// XML文档注释
/// &lt;/summary&gt;

// 声明应用用到的命名空间
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Dynamic;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading.Tasks;

// 定义作用域，将代码组织成包
namespace Learning
{
    // 每个 .cs 文件至少需要包含一个和文件名相同的类
    // 你可以不这么干，但是这样不好。
    public class LearnCSharp
    {
        // 基本语法 -  如果你以前用过 Java 或 C++ 的话，可以直接跳到后文「有趣的特性」
        public static void Syntax()
        {
            // 使用 Console.WriteLine 打印信息
            Console.WriteLine(&quot;Hello World&quot;);
            Console.WriteLine(
                &quot;Integer: &quot; + 10 +
                &quot; Double: &quot; + 3.14 +
                &quot; Boolean: &quot; + true);

            // 使用 Console.Write 打印，不带换行符号
            Console.Write(&quot;Hello &quot;);
            Console.Write(&quot;World&quot;);

            // 字符串 -- 和前面的基本类型不同，字符串不是值，而是引用。
            // 这意味着你可以将字符串设为null。
            string fooString = &quot;\&quot;escape\&quot; quotes and add \n (new lines) and \t (tabs)&quot;;
            Console.WriteLine(fooString);

            // 你可以通过索引访问字符串的每个字符：
            char charFromString = fooString[1]; // =&gt; &#39;e&#39;
            // 字符串不可修改:  fooString[1] = &#39;X&#39; 是行不通的;

            // 根据当前的locale设定比较字符串，大小写不敏感
            string.Compare(fooString, &quot;x&quot;, StringComparison.CurrentCultureIgnoreCase);

            // 基于sprintf的字符串格式化
            string fooFs = string.Format(&quot;Check Check, {0} {1}, {0} {1:0.0}&quot;, 1, 2);

            // 日期和格式
            DateTime fooDate = DateTime.Now;
            Console.WriteLine(fooDate.ToString(&quot;hh:mm, dd MMM yyyy&quot;));

            ///////////////////////////////////////////////////
            // 数据结构
            ///////////////////////////////////////////////////

            // 数组 - 从0开始计数
            // 声明数组时需要确定数组长度
            // 声明数组的格式如下：
            // &lt;datatype&gt;[] &lt;var name&gt; = new &lt;datatype&gt;[&lt;array size&gt;];
            int[] intArray = new int[10];

            // 声明并初始化数组的其他方式：
            int[] y = { 9000, 1000, 1337 };

            // 访问数组的元素
            Console.WriteLine(&quot;intArray @ 0: &quot; + intArray[0]);
            // 数组可以修改
            intArray[1] = 1;

            // 列表
            // 列表比数组更常用，因为列表更灵活。
            // 声明列表的格式如下：
            // List&lt;datatype&gt; &lt;var name&gt; = new List&lt;datatype&gt;();
            List&lt;int&gt; intList = new List&lt;int&gt;();
            List&lt;string&gt; stringList = new List&lt;string&gt;();
            List&lt;int&gt; z = new List&lt;int&gt; { 9000, 1000, 1337 }; // i
            // &lt;&gt;用于泛型 - 参考下文

            // 列表无默认值
            // 访问列表元素时必须首先添加元素
            intList.Add(1);
            Console.WriteLine(&quot;intList @ 0: &quot; + intList[0]);

            // 其他数据结构：
            // 堆栈/队列
            // 字典 (哈希表的实现)
            // 哈希集合
            // 只读集合
            // 元组 (.Net 4+)

            ///////////////////////////////////////
            // 操作符
            ///////////////////////////////////////
            Console.WriteLine(&quot;\n-&gt;Operators&quot;);

            int i1 = 1, i2 = 2; // 多重声明的简写形式

            // 算术直截了当
            Console.WriteLine(i1 + i2 - i1 * 3 / 7); // =&gt; 3

            // 取余
            Console.WriteLine(&quot;11%3 = &quot; + (11 % 3)); // =&gt; 2

            // 比较操作符
            Console.WriteLine(&quot;3 == 2? &quot; + (3 == 2)); // =&gt; false
            Console.WriteLine(&quot;3 != 2? &quot; + (3 != 2)); // =&gt; true
            Console.WriteLine(&quot;3 &gt; 2? &quot; + (3 &gt; 2)); // =&gt; true
            Console.WriteLine(&quot;3 &lt; 2? &quot; + (3 &lt; 2)); // =&gt; false
            Console.WriteLine(&quot;2 &lt;= 2? &quot; + (2 &lt;= 2)); // =&gt; true
            Console.WriteLine(&quot;2 &gt;= 2? &quot; + (2 &gt;= 2)); // =&gt; true

            // 位操作符
            /*
            ~       取反
            &lt;&lt;      左移（有符号）
            &gt;&gt;      右移（有符号）
            &amp;       与
            ^       异或
            |       或
            */

            // 自增、自减
            int i = 0;
            Console.WriteLine(&quot;\n-&gt;Inc/Dec-rementation&quot;);
            Console.WriteLine(i++); //i = 1. 事后自增
            Console.WriteLine(++i); //i = 2. 事先自增
            Console.WriteLine(i--); //i = 1. 事后自减
            Console.WriteLine(--i); //i = 0. 事先自减

            ///////////////////////////////////////
            // 控制结构
            ///////////////////////////////////////
            Console.WriteLine(&quot;\n-&gt;Control Structures&quot;);

            // 类似C的if语句
            int j = 10;
            if (j == 10)
            {
                Console.WriteLine(&quot;I get printed&quot;);
            }
            else if (j &gt; 10)
            {
                Console.WriteLine(&quot;I don&#39;t&quot;);
            }
            else
            {
                Console.WriteLine(&quot;I also don&#39;t&quot;);
            }

            // 三元表达式
            // 简单的 if/else 语句可以写成：
            // &lt;条件&gt; ? &lt;真&gt; : &lt;假&gt;
            int toCompare = 17;
            string isTrue = toCompare == 17 ? &quot;True&quot; : &quot;False&quot;;

            // While 循环
            int fooWhile = 0;
            while (fooWhile &lt; 100)
            {
                //迭代 100 次, fooWhile 0-&gt;99
                fooWhile++;
            }

            // Do While 循环
            int fooDoWhile = 0;
            do
            {
                //迭代 100 次, fooDoWhile 0-&gt;99
                fooDoWhile++;
            } while (fooDoWhile &lt; 100);

            //for 循环结构 =&gt; for(&lt;初始条件&gt;; &lt;条件&gt;; &lt;步&gt;)
            for (int fooFor = 0; fooFor &lt; 10; fooFor++)
            {
                //迭代10次, fooFor 0-&gt;9
            }

            // foreach循环
            // foreach 循环结构 =&gt; foreach(&lt;迭代器类型&gt; &lt;迭代器&gt; in &lt;可枚举结构&gt;)
            // foreach 循环适用于任何实现了 IEnumerable 或 IEnumerable&lt;T&gt; 的对象。
            // .Net 框架下的集合类型(数组, 列表, 字典...)
            // 都实现了这些接口
            // (下面的代码中，ToCharArray()可以删除，因为字符串同样实现了IEnumerable)
            foreach (char character in &quot;Hello World&quot;.ToCharArray())
            {
                //迭代字符串中的所有字符
            }

            // Switch 语句
            // switch 适用于 byte、short、char和int 数据类型。
            // 同样适用于可枚举的类型
            // 包括字符串类, 以及一些封装了原始值的类：
            // Character、Byte、Short和Integer。
            int month = 3;
            switch (month)
            {
                case 1:
                    break;
                case 2:
                    break;
                case 3:
                    break;
                // 你可以一次匹配多个case语句
                // 但是你在添加case语句后需要使用break
                // （否则你需要显式地使用goto case x语句）
                case 6:
                case 7:
                case 8:
                    break;
                default:
                    break;
            }

            ///////////////////////////////////////
            // 转换、指定数据类型
            ///////////////////////////////////////

            // 转换类型

            // 转换字符串为整数
            // 转换失败会抛出异常
            int.Parse(&quot;123&quot;);//返回整数类型的&quot;123&quot;

            // TryParse会尝试转换类型，失败时会返回缺省类型
            // 例如 0
            int tryInt;
            if (int.TryParse(&quot;123&quot;, out tryInt)) // Funciton is boolean
                Console.WriteLine(tryInt);       // 123

            // 转换整数为字符串
            // Convert类提供了一系列便利转换的方法
            Convert.ToString(123);
            // or
            tryInt.ToString();
        }

        ///////////////////////////////////////
        // 类
        ///////////////////////////////////////
        public static void Classes()
        {
            // 参看文件尾部的对象声明

            // 使用new初始化对象
            Bicycle trek = new Bicycle();

            // 调用对象的方法
            trek.SpeedUp(3); // 你应该一直使用setter和getter方法
            trek.Cadence = 100;

            // 查看对象的信息.
            Console.WriteLine(&quot;trek info: &quot; + trek.Info());

            // 实例化一个新的Penny Farthing
            PennyFarthing funbike = new PennyFarthing(1, 10);
            Console.WriteLine(&quot;funbike info: &quot; + funbike.Info());

            Console.Read();
        } // 结束main方法

        // 终端程序 终端程序必须有一个main方法作为入口
        public static void Main(string[] args)
        {
            OtherInterestingFeatures();
        }

        //
        // 有趣的特性
        //

        // 默认方法签名

        public // 可见性
        static // 允许直接调用类，无需先创建实例
        int //返回值
        MethodSignatures(
            int maxCount, // 第一个变量，类型为整型
            int count = 0, // 如果没有传入值，则缺省值为0
            int another = 3,
            params string[] otherParams // 捕获其他参数
        )
        {
            return -1;
        }

        // 方法可以重名，只要签名不一样
        public static void MethodSignature(string maxCount)
        {
        }

        //泛型
        // TKey和TValue类由用用户调用函数时指定。
        // 以下函数模拟了Python的SetDefault
        public static TValue SetDefault&lt;TKey, TValue&gt;(
            IDictionary&lt;TKey, TValue&gt; dictionary,
            TKey key,
            TValue defaultItem)
        {
            TValue result;
            if (!dictionary.TryGetValue(key, out result))
                return dictionary[key] = defaultItem;
            return result;
        }

        // 你可以限定传入值的范围
        public static void IterateAndPrint&lt;T&gt;(T toPrint) where T : IEnumerable&lt;int&gt;
        {
            // 我们可以进行迭代，因为T是可枚举的
            foreach (var item in toPrint)
                // ittm为整数
                Console.WriteLine(item.ToString());
        }

        public static void OtherInterestingFeatures()
        {
            // 可选参数  
            MethodSignatures(3, 1, 3, &quot;Some&quot;, &quot;Extra&quot;, &quot;Strings&quot;);
            MethodSignatures(3, another: 3); // 显式指定参数，忽略可选参数

            // 扩展方法
            int i = 3;
            i.Print(); // 参见下面的定义 

            // 可为null的类型 对数据库交互、返回值很有用
            // 任何值类型 (i.e. 不为类) 添加后缀 ? 后会变为可为null的值
            // &lt;类型&gt;? &lt;变量名&gt; = &lt;值&gt;
            int? nullable = null; // Nullable&lt;int&gt; 的简写形式
            Console.WriteLine(&quot;Nullable variable: &quot; + nullable);
            bool hasValue = nullable.HasValue; // 不为null时返回真
            // ?? 是用于指定默认值的语法糖
            // 以防变量为null的情况
            int notNullable = nullable ?? 0; // 0
            // magic = 9; // 不工作，因为magic是字符串，而不是整数。 

            // 泛型
            //
            var phonebook = new Dictionary&lt;string, string&gt;() {
                {&quot;Sarah&quot;, &quot;212 555 5555&quot;} // 在电话簿中加入新条目
            };

            // 调用上面定义为泛型的SETDEFAULT
            Console.WriteLine(SetDefault&lt;string, string&gt;(phonebook, &quot;Shaun&quot;, &quot;No Phone&quot;)); // 没有电话
            // 你不用指定TKey、TValue，因为它们会被隐式地推导出来
            Console.WriteLine(SetDefault(phonebook, &quot;Sarah&quot;, &quot;No Phone&quot;)); // 212 555 5555

            // lambda表达式 - 允许你用一行代码搞定函数
            Func&lt;int, int&gt; square = (x) =&gt; x * x; // 最后一项为返回值
            Console.WriteLine(square(3)); // 9

            // 可抛弃的资源管理 - 让你很容易地处理未管理的资源
            // 大多数访问未管理资源 (文件操作符、设备上下文, etc.)的对象
            // 都实现了IDisposable接口。 
            // using语句会为你清理IDisposable对象。
            using (StreamWriter writer = new StreamWriter(&quot;log.txt&quot;))
            {
                writer.WriteLine(&quot;这里没有什么可疑的东西&quot;);
                // 在作用域的结尾，资源会被回收
                // （即使有异常抛出，也一样会回收）
            }

            // 并行框架
            // http://blogs.msdn.com/b/csharpfaq/archive/2010/06/01/parallel-programming-in-net-framework-4-getting-started.aspx
            var websites = new string[] {
                &quot;http://www.google.com&quot;, &quot;http://www.reddit.com&quot;,
                &quot;http://www.shaunmccarthy.com&quot;
            };
            var responses = new Dictionary&lt;string, string&gt;();

            // 为每个请求新开一个线程
            // 在运行下一步前合并结果
            Parallel.ForEach(websites,
                new ParallelOptions() { MaxDegreeOfParallelism = 3 }, // max of 3 threads
                website =&gt;
                {
                    // Do something that takes a long time on the file
                    using (var r = WebRequest.Create(new Uri(website)).GetResponse())
                    {
                        responses[website] = r.ContentType;
                    }
                });

            // 直到所有的请求完成后才会运行下面的代码
            foreach (var key in responses.Keys)
                Console.WriteLine(&quot;{0}:{1}&quot;, key, responses[key]);

            // 动态对象（配合其他语言使用很方便）
            dynamic student = new ExpandoObject();
            student.FirstName = &quot;First Name&quot;; // 不需要先定义类！

            // 你甚至可以添加方法（接受一个字符串，输出一个字符串）
            student.Introduce = new Func&lt;string, string&gt;(
                (introduceTo) =&gt; string.Format(&quot;Hey {0}, this is {1}&quot;, student.FirstName, introduceTo));
            Console.WriteLine(student.Introduce(&quot;Beth&quot;));

            // IQUERYABLE&lt;T&gt; - 几乎所有的集合都实现了它，
            // 带给你 Map / Filter / Reduce 风格的方法
            var bikes = new List&lt;Bicycle&gt;();
            bikes.Sort(); // Sorts the array
            bikes.Sort((b1, b2) =&gt; b1.Wheels.CompareTo(b2.Wheels)); // 根据车轮数排序
            var result = bikes
                .Where(b =&gt; b.Wheels &gt; 3) // 筛选 - 可以连锁使用 （返回IQueryable)
                .Where(b =&gt; b.IsBroken &amp;&amp; b.HasTassles)
                .Select(b =&gt; b.ToString()); // Map - 这里我们使用了select，所以结果是IQueryable&lt;string&gt;

            var sum = bikes.Sum(b =&gt; b.Wheels); // Reduce - 计算集合中的轮子总数

            // 创建一个包含基于自行车的一些参数生成的隐式对象的列表
            var bikeSummaries = bikes.Select(b =&gt; new { Name = b.Name, IsAwesome = !b.IsBroken &amp;&amp; b.HasTassles });
            // 很难演示，但是编译器在代码编译完成前就能推导出以上对象的类型
            foreach (var bikeSummary in bikeSummaries.Where(b =&gt; b.IsAwesome))
                Console.WriteLine(bikeSummary.Name);

            // ASPARALLEL
            // 邪恶的特性 —— 组合了linq和并行操作
            var threeWheelers = bikes.AsParallel().Where(b =&gt; b.Wheels == 3).Select(b =&gt; b.Name);
            // 以上代码会并发地运行。会自动新开线程，分别计算结果。
            // 适用于多核、大数据量的场景。

            // LINQ - 将IQueryable&lt;T&gt;映射到存储，延缓执行
            // 例如 LinqToSql 映射数据库, LinqToXml 映射XML文档
            var db = new BikeRespository();

            // 执行被延迟了，这对于查询数据库来说很好
            var filter = db.Bikes.Where(b =&gt; b.HasTassles); // 不运行查询
            if (42 &gt; 6) // 你可以不断地增加筛选，包括有条件的筛选，例如用于“高级搜索”功能
                filter = filter.Where(b =&gt; b.IsBroken); // 不运行查询 

            var query = filter
                .OrderBy(b =&gt; b.Wheels)
                .ThenBy(b =&gt; b.Name)
                .Select(b =&gt; b.Name); // 仍然不运行查询

            // 现在运行查询，运行查询的时候会打开一个读取器，所以你迭代的是一个副本
            foreach (string bike in query)
                Console.WriteLine(result);
        }

    } // 结束LearnCSharp类

    // 你可以在同一个 .cs 文件中包含其他类

    public static class Extensions
    {
        // 扩展函数
        public static void Print(this object obj)
        {
            Console.WriteLine(obj.ToString());
        }
    }
    // 声明类的语法：
    // &lt;public/private/protected/internal&gt; class &lt;类名&gt;{
    //    //数据字段, 构造器, 内部函数.
    //    // 在Java中函数被称为方法。
    // }

    public class Bicycle
    {
        // 自行车的字段、变量
        public int Cadence // Public: 任何地方都可以访问
        {
            get // get - 定义获取属性的方法
            {
                return this._cadence;
            }
            set // set - 定义设置属性的方法
            {
                this._cadence = value; // value是被传递给setter的值
            }
        }
        private int _cadence;

        protected virtual int Gear // 类和子类可以访问
        {
            get; // 创建一个自动属性，无需成员字段
            set;
        }

        internal int Wheels // Internal:在同一程序集内可以访问
        {
            get;
            private set; // 可以给get/set方法添加修饰符
        }

        private int _speed; // 默认为private: 只可以在这个类内访问，你也可以使用`private`关键词
        public string Name { get; set; }

        // enum类型包含一组常量
        // 它将名称映射到值（除非特别说明，是一个整型）
        // enmu元素的类型可以是byte、sbyte、short、ushort、int、uint、long、ulong。
        // enum不能包含相同的值。
        public enum BikeBrand
        {
            AIST,
            BMC,
            Electra = 42, //你可以显式地赋值
            Gitane // 43
        }
        // 我们在Bicycle类中定义的这个类型，所以它是一个内嵌类型。
        // 这个类以外的代码应当使用`Bicycle.Brand`来引用。

        public BikeBrand Brand; // 声明一个enum类型之后，我们可以声明这个类型的字段

        // 静态方法的类型为自身，不属于特定的对象。
        // 你无需引用对象就可以访问他们。
        // Console.WriteLine(&quot;Bicycles created: &quot; + Bicycle.bicyclesCreated);
        public static int BicyclesCreated = 0;

        // 只读值在运行时确定
        // 它们只能在声明或构造器内被赋值
        private readonly bool _hasCardsInSpokes = false; // read-only private

        // 构造器是创建类的一种方式
        // 下面是一个默认的构造器
        public Bicycle()
        {
            Gear = 1; // 你可以使用关键词this访问对象的成员
            Cadence = 50;  // 不过你并不总是需要它
            this._speed = 5;
            Name = &quot;Bontrager&quot;;
            this.Brand = BikeBrand.AIST;
            BicyclesCreated++;
        }

        // 另一个构造器的例子（包含参数）
        public Bicycle(int startCadence, int startSpeed, int startGear,
                       string name, bool hasCardsInSpokes, BikeBrand brand)
            : base() // 首先调用base
        {
            Gear = startGear;
            Cadence = startCadence;
            this._speed = startSpeed;
            Name = name;
            this._hasCardsInSpokes = hasCardsInSpokes;
            this.Brand = brand;
        }

        // 构造器可以连锁使用
        public Bicycle(int startCadence, int startSpeed, BikeBrand brand) :
            this(startCadence, startSpeed, 0, &quot;big wheels&quot;, true, brand)
        {
        }

        // 函数语法
        // &lt;public/private/protected&gt; &lt;返回值&gt; &lt;函数名称&gt;(&lt;参数&gt;)

        // 类可以为字段实现 getters 和 setters 方法 for their fields
        // 或者可以实现属性（C#推荐使用这个）
        // 方法的参数可以有默认值
        // 在有默认值的情况下，调用方法的时候可以省略相应的参数
        public void SpeedUp(int increment = 1)
        {
            this._speed += increment;
        }

        public void SlowDown(int decrement = 1)
        {
            this._speed -= decrement;
        }

        // 属性可以访问和设置值
        // 当只需要访问数据的时候，考虑使用属性。
        // 属性可以定义get和set，或者是同时定义两者
        private bool _hasTassles; // private variable
        public bool HasTassles // public accessor
        {
            get { return this._hasTassles; }
            set { this._hasTassles = value; }
        }

        // 你可以在一行之内定义自动属性
        // 这个语法会自动创建后备字段
        // 你可以给getter或setter设置访问修饰符
        // 以便限制它们的访问
        public bool IsBroken { get; private set; }

        // 属性的实现可以是自动的
        public int FrameSize
        {
            get;
            // 你可以给get或set指定访问修饰符
            // 以下代码意味着只有Bicycle类可以调用Framesize的set
            private set;
        }

        //显示对象属性的方法
        public virtual string Info()
        {
            return &quot;Gear: &quot; + Gear +
                    &quot; Cadence: &quot; + Cadence +
                    &quot; Speed: &quot; + this._speed +
                    &quot; Name: &quot; + Name +
                    &quot; Cards in Spokes: &quot; + (this._hasCardsInSpokes ? &quot;yes&quot; : &quot;no&quot;) +
                    &quot;\n------------------------------\n&quot;
                    ;
        }

        // 方法可以是静态的。通常用于辅助方法。
        public static bool DidWeCreateEnoughBycles()
        {
            // 在静态方法中，你只能引用类的静态成员
            return BicyclesCreated &gt; 9000;
        } // 如果你的类只需要静态成员，考虑将整个类作为静态类。


    } //  Bicycle类结束

    // PennyFarthing是Bicycle的一个子类
    internal class PennyFarthing : Bicycle
    {
        // (Penny Farthings是一种前轮很大的自行车。没有齿轮。）

        // 调用父构造器
        public PennyFarthing(int startCadence, int startSpeed) :
            base(startCadence, startSpeed, 0, &quot;PennyFarthing&quot;, true, BikeBrand.Electra)
        {
        }

        protected override int Gear
        {
            get
            {
                return 0;
            }
            set
            {
                throw new ArgumentException(&quot;你不可能在PennyFarthing上切换齿轮&quot;);
            }
        }

        public override string Info()
        {
            string result = &quot;PennyFarthing bicycle &quot;;
            result += base.ToString(); // 调用父方法
            return result;
        }

        // 接口只包含成员的签名，而没有实现。
        private interface IJumpable
        {
            void Jump(int meters); // 所有接口成员是隐式地公开的
        }

        private interface IBreakable
        {
            bool Broken { get; } // 接口可以包含属性、方法和事件
        }

        // 类只能继承一个类，但是可以实现任意数量的接口

        private int damage = 0;

        public void Jump(int meters)
        {
            this.damage += meters;
        }

        public bool Broken
        {
            get
            {
                return this.damage &gt; 100;
            }
        }
    }

    /// &lt;summary&gt;
    /// 连接数据库，一个 LinqToSql的示例。
    /// EntityFramework Code First 很棒 (类似 Ruby的 ActiveRecord, 不过是双向的)
    /// http://msdn.microsoft.com/en-us/data/jj193542.aspx
    /// &lt;/summary&gt;
    public class BikeRespository : DbSet
    {
        public BikeRespository()
            : base()
        {
        }

        public DbSet&lt;Bicycle&gt; Bikes { get; set; }
    }
} // 结束 Namespace

</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>