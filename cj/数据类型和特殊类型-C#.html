<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修数据类型和特殊类型-C#' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>数据类型和特殊类型-C#</center></div><div class='banquan'>原文出处:本文由博客园博主冰乐提供。<br/>
原文连接:https://www.cnblogs.com/taotaozhuanyong/p/11563342.html</div><br>
    <p>参考地址：<a href="https://blog.csdn.net/qiaoquan3/article/details/51380992">https://blog.csdn.net/qiaoquan3/article/details/51380992</a></p>
<p>1、集合set：纯粹的数据集合</p>
<p>2、线性结构：一对一的，数组</p>
<p>3、树形结构：一对多的，菜单/文件夹/类别/属性控件/表达式目录树</p>
<p>4、图形/网状结构：多对多，地图应用比较多，网站的应用比较少</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">线性结构：</span></strong></p>
<p>Array/ArrayList/List/LinkedList/Queue/Stack/HastSet/SortedSet/Hashtable/SortedList/Dictionary/SortedDictionary</p>
<p>IEnumerable、ICollection、IList、IQueryable</p>
<p>接口是标机功能的，不同的接口岔开，就是为了接口隔离；虽然我们接口内容也可以复用。</p>
<p>IEnumerable任何数据集合，都实现了的，为不同的数据结构，提供了统一数据访问方式，这个就是迭代器模式。</p>
<p>1、内存连续存储，节约空间，可以索引访问，读取速度快，增删慢</p>
<p>　<strong><span style="font-size: 18px;">　Array</span></strong>：在内存上连续分配的，而且元素类型是一样的。</p>
<div class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">int</span>[] intArray = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[<span style="color: #800080;">3</span><span style="color: #000000;">];
 intArray[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">123</span><span style="color: #000000;">;
 </span><span style="color: #0000ff;">string</span>[] stringArray = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">string</span>[] { <span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">234</span><span style="color: #800000;">"</span> };<span style="color: #008000;">//</span><span style="color: #008000;">Array</span></pre>
</div>
<p>　　ArrayList：不定长的，连续分配的；元素没有类型限制，任何元素都是当成object处理，如果是值类型，会有装箱操作；读取快，增删慢。</p>
<div class="cnblogs_code">
<pre><code> ArrayList arrayList = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList();
 arrayList.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">Bingle1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 arrayList.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">Bingle2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 arrayList.Add(</span><span style="color: #800080;">32</span>);<span style="color: #008000;">//</span><span style="color: #008000;">add增加长度
 </span><span style="color: #008000;">//</span><span style="color: #008000;">arrayList[4] = 26;</span><span style="color: #008000;">//</span><span style="color: #008000;">索引复制，不会增加长度
 </span><span style="color: #008000;">//</span><span style="color: #008000;">删除数据
 </span><span style="color: #008000;">//</span><span style="color: #008000;">arrayList.RemoveAt(4);</span>
 <span style="color: #0000ff;">var</span> value = arrayList[<span style="color: #800080;">2</span><span style="color: #000000;">];
 arrayList.RemoveAt(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
 arrayList.Remove(</span><span style="color: #800000;">"</span><span style="color: #800000;">Bingle2</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>　　<strong><span style="font-size: 18px;">List&lt;T&gt;</span></strong>：也是Array，内存上都是连续拜访的；不定长；泛型，保证类型安全，避免装箱拆箱；读取快，增删慢。</p>
<div class="cnblogs_code">
<pre><code>List&lt;<span style="color: #0000ff;">int</span>&gt; intList = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span><span style="color: #000000;"> };
intList.Add(</span><span style="color: #800080;">123</span><span style="color: #000000;">);
intList.Add(</span><span style="color: #800080;">123</span><span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">intList.Add("123");
</span><span style="color: #008000;">//</span><span style="color: #008000;">intList[0] = 123;</span>
List&lt;<span style="color: #0000ff;">string</span>&gt; stringList = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
</span><span style="color: #008000;">//</span><span style="color: #008000;">stringList[0] = "123";</span><span style="color: #008000;">//</span><span style="color: #008000;">异常的</span>
<span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> intList)
{

}</span></pre>
</div>
<p>2、非连续拜访的，存储数据+地址，找书的话就只能顺序查找，读取就比较慢，增删快</p>
<p>　　<strong><span style="font-size: 18px;">LinkedList&lt;T&gt;</span></strong>：泛型的特点；链表，元素不连续分配，每个元素都有记录前后节点；节点值可以重复。能不能下标访问？不能的，找元素就只能遍历，查找不方便，增删就比较方便。</p>
<div class="cnblogs_code">
<pre><code> LinkedList&lt;<span style="color: #0000ff;">int</span>&gt; linkedList = <span style="color: #0000ff;">new</span> LinkedList&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
 </span><span style="color: #008000;">//</span><span style="color: #008000;">linkedList[3]</span>
 linkedList.AddFirst(<span style="color: #800080;">123</span><span style="color: #000000;">);
 linkedList.AddLast(</span><span style="color: #800080;">456</span><span style="color: #000000;">);

 </span><span style="color: #0000ff;">bool</span> isContain = linkedList.Contains(<span style="color: #800080;">123</span><span style="color: #000000;">);
 LinkedListNode</span>&lt;<span style="color: #0000ff;">int</span>&gt; node123 = linkedList.Find(<span style="color: #800080;">123</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">元素123的位置  从头查找</span>
 linkedList.AddBefore(node123, <span style="color: #800080;">123</span><span style="color: #000000;">);
 linkedList.AddBefore(node123, </span><span style="color: #800080;">123</span><span style="color: #000000;">);
 linkedList.AddAfter(node123, </span><span style="color: #800080;">9</span><span style="color: #000000;">);

 linkedList.Remove(</span><span style="color: #800080;">456</span><span style="color: #000000;">);
 linkedList.Remove(node123);
 linkedList.RemoveFirst();
 linkedList.RemoveLast();
 linkedList.Clear();</span></pre>
</div>
<p>　<strong><span style="font-size: 18px;">　Queue</span></strong>：就是链表，先进先出，放任务延迟执行，A不断写入日志任务，B不断获取任务去执行</p>
<div class="cnblogs_code">
<pre><code> Queue&lt;<span style="color: #0000ff;">string</span>&gt; numbers = <span style="color: #0000ff;">new</span> Queue&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 numbers.Enqueue(</span><span style="color: #800000;">"</span><span style="color: #800000;">one</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Enqueue(</span><span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Enqueue(</span><span style="color: #800000;">"</span><span style="color: #800000;">three</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Enqueue(</span><span style="color: #800000;">"</span><span style="color: #800000;">four</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Enqueue(</span><span style="color: #800000;">"</span><span style="color: #800000;">four</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Enqueue(</span><span style="color: #800000;">"</span><span style="color: #800000;">five</span><span style="color: #800000;">"</span><span style="color: #000000;">);

 </span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">string</span> number <span style="color: #0000ff;">in</span><span style="color: #000000;"> numbers)
 {
     Console.WriteLine(number);
 }

 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Dequeuing '{numbers.Dequeue()}'</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Peek at next item to dequeue: { numbers.Peek()}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Dequeuing '{numbers.Dequeue()}'</span><span style="color: #800000;">"</span><span style="color: #000000;">);

 Queue</span>&lt;<span style="color: #0000ff;">string</span>&gt; queueCopy = <span style="color: #0000ff;">new</span> Queue&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">(numbers.ToArray());
 </span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">string</span> number <span style="color: #0000ff;">in</span><span style="color: #000000;"> queueCopy)
 {
     Console.WriteLine(number);
 }

 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">queueCopy.Contains(\"four\") = {queueCopy.Contains(</span><span style="color: #800000;">"</span>four<span style="color: #800000;">"</span><span style="color: #800000;">)}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 queueCopy.Clear();
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">queueCopy.Count = {queueCopy.Count}</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>　　<strong><span style="font-size: 18px;">Stack</span></strong>：就是链表，先进后出，解析表达式目录树的时候，先产生的数据后使用。操作记录为命令，撤销的时候是倒叙的。</p>
<div class="cnblogs_code">
<pre><code> Stack&lt;<span style="color: #0000ff;">string</span>&gt; numbers = <span style="color: #0000ff;">new</span> Stack&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 numbers.Push(</span><span style="color: #800000;">"</span><span style="color: #800000;">one</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Push(</span><span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Push(</span><span style="color: #800000;">"</span><span style="color: #800000;">three</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Push(</span><span style="color: #800000;">"</span><span style="color: #800000;">four</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 numbers.Push(</span><span style="color: #800000;">"</span><span style="color: #800000;">five</span><span style="color: #800000;">"</span>);<span style="color: #008000;">//</span><span style="color: #008000;">放进去</span>

 <span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">string</span> number <span style="color: #0000ff;">in</span><span style="color: #000000;"> numbers)
 {
     Console.WriteLine(number);
 }

 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Pop '{numbers.Pop()}'</span><span style="color: #800000;">"</span>);<span style="color: #008000;">//</span><span style="color: #008000;">获取并移除</span>
 Console.WriteLine($<span style="color: #800000;">"</span><span style="color: #800000;">Peek at next item to dequeue: { numbers.Peek()}</span><span style="color: #800000;">"</span>);<span style="color: #008000;">//</span><span style="color: #008000;">获取不移除</span>
 Console.WriteLine($<span style="color: #800000;">"</span><span style="color: #800000;">Pop '{numbers.Pop()}'</span><span style="color: #800000;">"</span><span style="color: #000000;">);

 Stack</span>&lt;<span style="color: #0000ff;">string</span>&gt; stackCopy = <span style="color: #0000ff;">new</span> Stack&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">(numbers.ToArray());
 </span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">string</span> number <span style="color: #0000ff;">in</span><span style="color: #000000;"> stackCopy)
 {
     Console.WriteLine(number);
 }

 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">stackCopy.Contains(\"four\") = {stackCopy.Contains(</span><span style="color: #800000;">"</span>four<span style="color: #800000;">"</span><span style="color: #800000;">)}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 stackCopy.Clear();
 Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">stackCopy.Count = {stackCopy.Count}</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>　　<strong><span style="font-size: 18px;">队列是没有底的瓶子，栈是有底的瓶子</span></strong></p>
<p>　　集合：纯粹的集合，容器，东西丢进去，唯一性，无序的。</p>
<p>　　<strong><span style="font-size: 18px;">HashSet</span></strong>：hash分布，元素间没有关系，动态增加容量，去重的。统计用户IP；IP投票；交叉并补；二次好友/间接关注/粉丝集合</p>
<div class="cnblogs_code">
<pre><code> HashSet&lt;<span style="color: #0000ff;">string</span>&gt; hashSet = <span style="color: #0000ff;">new</span> HashSet&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 hashSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">689</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">456</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);

HashSet</span>&lt;<span style="color: #0000ff;">string</span>&gt; hashSet1 = <span style="color: #0000ff;">new</span> HashSet&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 hashSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">689</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">789</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 hashSet1.SymmetricExceptWith(hashSet);</span><span style="color: #008000;">//</span><span style="color: #008000;">补</span>
 hashSet1.UnionWith(hashSet);<span style="color: #008000;">//</span><span style="color: #008000;">并</span>
 hashSet1.ExceptWith(hashSet);<span style="color: #008000;">//</span><span style="color: #008000;">差</span>
 hashSet1.IntersectWith(hashSet);<span style="color: #008000;">//</span><span style="color: #008000;">交</span></pre>
</div>
<p>&nbsp;</p>
<p>　　<strong><span style="font-size: 18px;">SortSet</span></strong>：排序的集合；去重而且排序；统计排名，每统计一个就丢进去集合</p>
<div class="cnblogs_code">
<pre><code> SortedSet&lt;<span style="color: #0000ff;">string</span>&gt; sortedSet = <span style="color: #0000ff;">new</span> SortedSet&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 </span><span style="color: #008000;">//</span><span style="color: #008000;">IComparer&lt;T&gt; comparer  自定义对象要排序，就用这个指定</span>
 sortedSet.Add(<span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">689</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">456</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">); 

SortedSet</span>&lt;<span style="color: #0000ff;">string</span>&gt; sortedSet1 = <span style="color: #0000ff;">new</span> SortedSet&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 sortedSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">689</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">456</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet1.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">12435</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 sortedSet1.SymmetricExceptWith(sortedSet);</span><span style="color: #008000;">//</span><span style="color: #008000;">补</span>
 sortedSet1.UnionWith(sortedSet);<span style="color: #008000;">//</span><span style="color: #008000;">并</span>
 sortedSet1.ExceptWith(sortedSet);<span style="color: #008000;">//</span><span style="color: #008000;">差</span>
 sortedSet1.IntersectWith(sortedSet);<span style="color: #008000;">//</span><span style="color: #008000;">交</span></pre>
</div>
<p>　　读取和增删都快的，有没有？有，hash散列，字典。是key-value，一段连续空间放value（开辟的空间比用到的多，hash使用空间换性能），基于key散列计算得到地址索引，这样读取快，但是没有数组快。增删也快，删除时也是计算位置，增加也不影响别人。代价就是，肯定会出现2个key（散列冲突），散列结果一致，可以让第二次的+1；可能会造成效率的降低，尤其是数据量大的情况下，以前测试Dictionary在3W条左右的时候，性能爱是下降的厉害。</p>
<p><strong><span style="font-size: 18px;">　　Hashtable-</span></strong>--key-value，体积可以动态增加，拿着key计算下一个地址，然后放入key-value；object-装箱茶香，如果不同的key得到相同的地址，第二个在前面地址上+1；查找的时候，如果地址对应数据的key不对，那就+1查找。。</p>
<p>　　浪费了空间，Hashtable是基于数组实现；查找个数据，一次定位；增删，一次定位；增删改查都很快，但是浪费空间，数据太多，重复定位定位，效率就下去了。</p>
<div class="cnblogs_code">
<pre><code> Hashtable table = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Hashtable();
 table.Add(</span><span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">456</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 table[</span><span style="color: #800080;">234</span>] = <span style="color: #800080;">456</span><span style="color: #000000;">;
 table[</span><span style="color: #800080;">234</span>] = <span style="color: #800080;">567</span><span style="color: #000000;">;
 table[</span><span style="color: #800080;">32</span>] = <span style="color: #800080;">4562</span><span style="color: #000000;">;
 table[</span><span style="color: #800080;">1</span>] = <span style="color: #800080;">456</span><span style="color: #000000;">;
 table[</span><span style="color: #800000;">"</span><span style="color: #800000;">eleven</span><span style="color: #800000;">"</span>] = <span style="color: #800080;">456</span><span style="color: #000000;">;
 </span><span style="color: #0000ff;">foreach</span> (DictionaryEntry objDE <span style="color: #0000ff;">in</span><span style="color: #000000;"> table)
 {
     Console.WriteLine(objDE.Key.ToString());
     Console.WriteLine(objDE.Value.ToString());
 }
 </span><span style="color: #008000;">//</span><span style="color: #008000;">线程安全</span>
 Hashtable.Synchronized(table);<span style="color: #008000;">//</span><span style="color: #008000;">只有一个线程写  多个线程读</span></pre>
</div>
<p><strong><span style="font-size: 18px;">字典</span></strong>：泛型；key - value，增删查改 都很快；有序的。但是字段不是线程安全的，ConcurrentDictionary</p>
<div class="cnblogs_code">
<pre><code> Dictionary&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt; dic = <span style="color: #0000ff;">new</span> Dictionary&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
 dic.Add(</span><span style="color: #800080;">1</span>, <span style="color: #800000;">"</span><span style="color: #800000;">HaHa</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 dic.Add(</span><span style="color: #800080;">5</span>, <span style="color: #800000;">"</span><span style="color: #800000;">HoHo</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 dic.Add(</span><span style="color: #800080;">3</span>, <span style="color: #800000;">"</span><span style="color: #800000;">HeHe</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 dic.Add(</span><span style="color: #800080;">2</span>, <span style="color: #800000;">"</span><span style="color: #800000;">HiHi</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 dic.Add(</span><span style="color: #800080;">4</span>, <span style="color: #800000;">"</span><span style="color: #800000;">HuHu1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 dic[</span><span style="color: #800080;">4</span>] = <span style="color: #800000;">"</span><span style="color: #800000;">HuHu</span><span style="color: #800000;">"</span><span style="color: #000000;">;
 dic.Add(</span><span style="color: #800080;">4</span>, <span style="color: #800000;">"</span><span style="color: #800000;">HuHu</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 </span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> dic)
 {
     Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Key:{item.Key}, Value:{item.Value}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 }</span></pre>
</div>
<p>我们来看一下List，如下图</p>
<p><img src="./images/数据类型和特殊类型-C#0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;List集合为什么会继承这么多接口呢？</p>
<p>　　1、ICollection：</p>
<p>　　　　Count、IsReadOnly、Add、Clear、Contains、CopyTo、Clear</p>
<p>　　2、IList：</p>
<p>　　　　T this[int index] （索引）、IndexoOf、.....</p>
<p>　　3、IEnumerable：</p>
<p>　　　　遍历才会去查询比较，迭代器 yield</p>
<p>　　　　GetEnumerator：Current、MoveNext、Reset</p>
<p>　　　　任何数据集合，都实现了IEnumerable，为不同的数据结构提供了统一的数据访问方式，这个就是迭代器模式。</p>
<p>　　4、IQueryable：</p>
<p>　　　　表达式目录树的解析，延迟到遍历的时候才去执行，EF的延迟查询</p>
<p>　　　　IQueryProvider Provider{get;}</p>
<p>　　　　</p>
<p><strong><span style="font-size: 18px;">yield是语法糖</span></strong>，编译时由编译器生成Iterrator的代码，包括movenext current&nbsp; reset</p>
<p>　　含有yield的函数说明它是一个生成器，而不是普通的函数。当程序运行到yield这一行时，该函数会返回值，并保存当前域的所有变量状态；等到该函数下一次被调用时，会从上一次中断的地方开始执行，一直遇到下一个yield, 程序返回值, 并在此保存当前状态; 如此反复，直到函数正常执行完成。</p>
<p>　　&nbsp;迭代器模式是设计模式中行为模式(behavioral pattern)的一个例子，他是一种简化对象间通讯的模式，也是一种非常容易理解和使用的模式。简单来说，迭代器模式使得你能够获取到序列中的所有元素 而不用关心是其类型是array，list，linked list或者是其他什么序列结构。这一点使得能够非常高效的构建数据处理通道(data pipeline)。</p>
<p>　　--即数据能够进入处理通道，进行一系列的变换，或者过滤，然后得到结果。事实上，这正是LINQ的核心模式。</p>
<p>　　在.NET中，迭代器模式被IEnumerator和IEnumerable及其对应的泛型接口所封装。如果一个类实现了IEnumerable接 口，那么就能够被迭代；调用GetEnumerator方法将返回IEnumerator接口的实现，它就是迭代器本身。迭代器类似数据库中的游标，他是 数据序列中的一个位置记录。迭代器只能向前移动，同一数据序列中可以有多个迭代器同时对数据进行操作。</p>
<p>下面是一个yield的一个简单Demo：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b78de934-be43-438c-a0cb-337aa8b4f528')"><img id="code_img_closed_b78de934-be43-438c-a0cb-337aa8b4f528" class="code_img_closed" src="./images/数据类型和特殊类型-C#1.png" alt="" /><img id="code_img_opened_b78de934-be43-438c-a0cb-337aa8b4f528" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b78de934-be43-438c-a0cb-337aa8b4f528',event)" src="./images/数据类型和特殊类型-C#2.png" alt="" />
<div id="cnblogs_code_open_b78de934-be43-438c-a0cb-337aa8b4f528" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> YieldShow
{
    </span><span style="color: #0000ff;">public</span> IEnumerable&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> CreateEnumerable()
    {
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">
        {
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">{0} CreateEnumerable()方法开始</span><span style="color: #800000;">"</span><span style="color: #000000;">, DateTime.Now);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">5</span>; i++<span style="color: #000000;">)
            {
                Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">{0}开始 yield {1}</span><span style="color: #800000;">"</span><span style="color: #000000;">, DateTime.Now, i);
                </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
                Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">{0}yield 结束</span><span style="color: #800000;">"</span><span style="color: #000000;">, DateTime.Now);
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">4</span><span style="color: #000000;">)
                {
                    </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">break</span>;<span style="color: #008000;">//</span><span style="color: #008000;">直接终结迭代  4会出现的，，</span>
<span style="color: #000000;">                }
            }
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">{0} Yielding最后一个值</span><span style="color: #800000;">"</span><span style="color: #000000;">, DateTime.Now);
            </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">{0} CreateEnumerable()方法结束</span><span style="color: #800000;">"</span><span style="color: #000000;">, DateTime.Now);
        }
        </span><span style="color: #0000ff;">finally</span><span style="color: #000000;">
        {
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">停止迭代！</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
    }
 IEnumerable</span>&lt;<span style="color: #0000ff;">int</span>&gt; iterable = <span style="color: #0000ff;">this</span>.CreateEnumerable();<span style="color: #008000;">//</span><span style="color: #008000;">1 不会直接执行
 </span><span style="color: #008000;">//</span><span style="color: #008000;">IEnumerator iterator = iterable.GetEnumerator();</span>
 IEnumerator&lt;<span style="color: #0000ff;">int</span>&gt; iterator =<span style="color: #000000;"> iterable.GetEnumerator();
 Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">开始迭代</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">)
 {
     Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">调用MoveNext方法&hellip;&hellip;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
     Boolean result </span>= iterator.MoveNext();<span style="color: #008000;">//</span><span style="color: #008000;">2 正式开启CreateEnumerable</span>
     Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">MoveNext方法返回的{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, result);
     </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">result)
     {
         </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
     }
     Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">获取当前值&hellip;&hellip;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
     Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">获取到的当前值为{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, iterator.Current);
 }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b564427d-4128-41d8-a374-f6ab1087d8e6')"><img id="code_img_closed_b564427d-4128-41d8-a374-f6ab1087d8e6" class="code_img_closed" src="./images/数据类型和特殊类型-C#1.png" alt="" /><img id="code_img_opened_b564427d-4128-41d8-a374-f6ab1087d8e6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b564427d-4128-41d8-a374-f6ab1087d8e6',event)" src="./images/数据类型和特殊类型-C#2.png" alt="" />
<div id="cnblogs_code_open_b564427d-4128-41d8-a374-f6ab1087d8e6" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> YieldDemo
{
    </span><span style="color: #0000ff;">public</span> IEnumerable&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> Power()
    {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; i++<span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.Get(i);

            </span><span style="color: #008000;">//</span><span style="color: #008000;">Console.WriteLine("这里再来一次");
            </span><span style="color: #008000;">//</span><span style="color: #008000;">yield return this.Get(i) + 1;</span>
<span style="color: #000000;">        }
    }

    </span><span style="color: #0000ff;">public</span> IEnumerable&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> Common()
    {
        List</span>&lt;<span style="color: #0000ff;">int</span>&gt; intList = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; i++<span style="color: #000000;">)
        {
            intList.Add(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.Get(i));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> intList;
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> Get(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num)
    {
        Thread.Sleep(</span><span style="color: #800080;">2000</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> num *<span style="color: #000000;"> DateTime.Now.Second;
    }
}



 YieldDemo yieldDemo </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> YieldDemo();
 </span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> yieldDemo.Power())
 {
     Console.WriteLine(item);</span><span style="color: #008000;">//</span><span style="color: #008000;">按需获取，要一个拿一个</span>
     <span style="color: #0000ff;">if</span> (item &gt; <span style="color: #800080;">100</span><span style="color: #000000;">)
         </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
 }
 Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">*******************************************</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 </span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> yieldDemo.Common())
 {
     Console.WriteLine(item);</span><span style="color: #008000;">//</span><span style="color: #008000;">先全部获取，然后一起返还</span>
     <span style="color: #0000ff;">if</span> (item &gt; <span style="color: #800080;">100</span><span style="color: #000000;">)
         </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
 }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 18px;">dynamic</span></strong>关键字：</p>
<p>　　.NET Framework4.0出现的，让程序有了弱类型的特点；</p>
<p>　　强类型特点：</p>
<p>　　　　编译时完成安全检查</p>
<p>　　弱类型：</p>
<p>　　　　运行时才检查类型</p>
<div class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">object</span> A = <span style="color: #0000ff;">new</span><span style="color: #000000;"> YieldDemo();
 </span><span style="color: #008000;">//</span><span style="color: #008000;">A.Power();</span>
 Type type =<span style="color: #000000;"> A.GetType();
 MethodInfo method </span>= type.GetMethod(<span style="color: #800000;">"</span><span style="color: #800000;">Power</span><span style="color: #800000;">"</span><span style="color: #000000;">);
 method.Invoke(A, </span><span style="color: #0000ff;">null</span><span style="color: #000000;">);

 </span><span style="color: #0000ff;">dynamic</span> dA =<span style="color: #000000;"> A;
 dA.Power();
 </span><span style="color: #008000;">//</span><span style="color: #008000;">1 代替反射  2 数据绑定方便 3 跟C++交互方便
 </span><span style="color: #008000;">//</span><span style="color: #008000;">性能比反射高</span>
<span style="color: #0000ff;">dynamic</span> str = <span style="color: #800000;">"</span><span style="color: #800000;">abcd</span><span style="color: #800000;">"</span>;<span style="color: #008000;">//</span><span style="color: #008000;">任何跟dynamic交互，都变成dynamic</span>
<span style="color: #000000;">Console.WriteLine(str.Length);
Console.WriteLine(str.Substring(</span><span style="color: #800080;">1</span>));</pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>