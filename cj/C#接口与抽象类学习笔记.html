<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C#接口与抽象类学习笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C#接口与抽象类学习笔记</center></div><div class='banquan'>原文出处:本文由博客园博主缥缈的尘埃提供。<br/>
原文连接:https://www.cnblogs.com/atomy/p/12113733.html</div><br>
    <p>&nbsp; &nbsp;&nbsp;本笔记摘抄自：<a href="https://www.cnblogs.com/solan/archive/2012/08/01/CSharp06.html">https://www.cnblogs.com/solan/archive/2012/08/01/CSharp06.html</a>，记录一下学习过程以备后续查用。</p>
<p>&nbsp; &nbsp; <strong>摘要：</strong></p>
<p>&nbsp; &nbsp; 抽象类：是一种特殊的类，可以定义具有实现的方法，也可以定义未实现的方法契约，本身不能被实例化，只能在派生类中进行实例化。接口：对一</p>
<p>组方法签名进行统一的命名，只能定义未实现的方法契约，本身也不能被实例化，只能在实现类中进行实例化。</p>
<p>&nbsp; &nbsp; 二者都可以有部分数据成员（如：属性），它们貌似有着相同的&ldquo;契约&rdquo;功能，但对各自的派生类（实现类）又有着不同的要求，那么，到底它们有何</p>
<p>异同呢？下面将从四个方面来讲解它们的相同与不同之处。</p>
<p>&nbsp; &nbsp; <strong>一、定义</strong></p>
<p>&nbsp; &nbsp;&nbsp;<span class="spanKeyword"><strong>抽象类</strong>&nbsp;不能实例化。抽象类的用途是提供多个派生类可共享的基类的公共定义，是对类进行抽象，可以有实现，也可以不实现。使用关键字abstract</span></p>
<p><span class="spanKeyword">进行定义。</span></p>
<p><span class="spanKeyword">&nbsp; &nbsp; 下面定义一个抽象类：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Code_06_03
{
}</span></pre>
</div>
<p>&nbsp; &nbsp; 通过ISDASM来看一下生成的IL：</p>
<p><img src="./images/C#接口与抽象类学习笔记0.png" alt="" /></p>
<div class="cnblogs_code">
<pre><code>.<span style="color: #0000ff;">class</span> <span style="color: #0000ff;">abstract</span> auto ansi nested <span style="color: #0000ff;">public</span><span style="color: #000000;"> beforefieldinit Code_06_03
       extends [mscorlib]System.Object
{
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of class Code_06_03</span></pre>
</div>
<p>&nbsp; &nbsp; 可以看以，抽象类实际上是继承了System.Object类，并且编译器为它生成了一个默认的构造函数。</p>
<p>&nbsp; &nbsp; <strong>接口</strong> 它是对一组方法签名进行统一命名，是对一组行为规范的定义，使用关键字interface进行定义。</p>
<p>&nbsp; &nbsp; 下面定义一个接口：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> ICode_06_01
{
}</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;通过ISDASM来看一下生成的IL：</p>
<p><img src="./images/C#接口与抽象类学习笔记1.png" alt="" /></p>
<div class="cnblogs_code">
<pre><code>.<span style="color: #0000ff;">class</span> <span style="color: #0000ff;">interface</span> <span style="color: #0000ff;">abstract</span> auto ansi nested <span style="color: #0000ff;">public</span><span style="color: #000000;"> ICode_06_01
{
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of class ICode_06_01</span></pre>
</div>
<p>&nbsp; &nbsp; 可以看到，接口实际上是把它当成抽象类来看待，但是没有构造函数。无论是抽象类拥有构造函数，还是接口不拥有构造函数，它们都是不能被实例</p>
<p>化的。</p>
<p>&nbsp; &nbsp; <strong>二、成员的区别</strong></p>
<p>&nbsp; &nbsp; <strong>抽象类</strong> 描述：</p>
<p>&nbsp; &nbsp; 1）可以定义抽象方法，抽象方法没有具体实现，仅仅是一个方法的契约，在子类中重写该方法。抽象类可以重写父类的虚方法为抽象方法。</p>
<p>&nbsp; &nbsp; 2）可以定义非抽象方法，但要求该方法要有具体实现，如果该方法是虚方法，则在子类中可以重写该方法。</p>
<p>&nbsp; &nbsp; 3）可以定义字段、属性、抽象属性、事件及静态成员。</p>
<p>&nbsp; &nbsp; 下面是对类Code_06_03的扩充：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2c2e82e2-c13a-4c29-8f19-b42a2f5519b1')"><img id="code_img_closed_2c2e82e2-c13a-4c29-8f19-b42a2f5519b1" class="code_img_closed" src="./images/C#接口与抽象类学习笔记2.png" alt="" /><img id="code_img_opened_2c2e82e2-c13a-4c29-8f19-b42a2f5519b1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2c2e82e2-c13a-4c29-8f19-b42a2f5519b1',event)" src="./images/C#接口与抽象类学习笔记3.png" alt="" />
<div id="cnblogs_code_open_2c2e82e2-c13a-4c29-8f19-b42a2f5519b1" class="cnblogs_code_hide">
<pre><code>    <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 抽象类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Code_06_03
        {
            Dictionary</span>&lt;Guid, <span style="color: #0000ff;">string</span>&gt; root = <span style="color: #0000ff;">new</span> Dictionary&lt;Guid, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> Sex { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">string</span> Address { <span style="color: #0000ff;">get</span><span style="color: #000000;">; }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);

            </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">string</span> GetAddress(<span style="color: #0000ff;">string</span><span style="color: #000000;"> addressID)
            {
                </span><span style="color: #0000ff;">return</span> addressID + <span style="color: #800000;">"</span><span style="color: #800000;"> 广东</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> AddRoot(Guid id, <span style="color: #0000ff;">string</span><span style="color: #000000;"> rootName)
            {
                root.Add(id, rootName);
                OnAddRoot();
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">event</span><span style="color: #000000;"> EventHandler AddRootEvent;

            </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> OnAddRoot()
            {
                AddRootEvent</span>?.Invoke(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">[Guid key]
            {
                </span><span style="color: #0000ff;">get</span><span style="color: #000000;">
                {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root[key];
                }
                </span><span style="color: #0000ff;">set</span><span style="color: #000000;">
                {
                    root[key] </span>=<span style="color: #000000;"> value;
                }
            }
        }

        </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {

        }
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp; 2.1抽象方法public abstract int Add(int a, int b);的IL：</p>
<div class="cnblogs_code">
<pre><code>.method <span style="color: #0000ff;">public</span> hidebysig newslot <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> 
        instance int32  Add(int32 a,
                            int32 b) cil managed
{
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method Code_06_03::Add</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;编译器把Add方法当作一个虚方法，在子类中可以被重写。</p>
<p>&nbsp; &nbsp; 2.2虚方法protected virtual string GetAddress(string addressID)的IL：</p>
<div class="cnblogs_code">
<pre><code>.method family hidebysig newslot <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> 
        instance </span><span style="color: #0000ff;">string</span>  GetAddress(<span style="color: #0000ff;">string</span><span style="color: #000000;"> addressID) cil managed
{
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 略过</span><span style="color: #000000;">
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method Code_06_03::GetAddress</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;它本来就是一个虚方法，所以编译器并没有特殊对待它。</p>
<p>&nbsp; &nbsp; 2.3方法public void AddRoot(Guid id, string rootName)的IL：</p>
<div class="cnblogs_code">
<pre><code>.method <span style="color: #0000ff;">public</span> hidebysig instance <span style="color: #0000ff;">void</span><span style="color: #000000;">  AddRoot(valuetype [mscorlib]System.Guid id,
                                                </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> rootName) cil managed
{
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 略过</span><span style="color: #000000;">
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method Code_06_03::AddRoot</span></pre>
</div>
<p>&nbsp; &nbsp; 它也是一个普通的对象方法。</p>
<p>&nbsp; &nbsp; <strong>接口</strong> 描述：</p>
<p>&nbsp; &nbsp; 1）可以定义属性及索引器，但不能定义字段。</p>
<p>&nbsp; &nbsp;&nbsp;2）可以定义事件。</p>
<p>&nbsp; &nbsp;&nbsp;3）可以定义方法，仅仅是方法签名的约定，不得有实现，在实现类中对该方法进行具体实现，有点类似于抽象类的抽象方法。</p>
<p>&nbsp; &nbsp;&nbsp;4）不可以定义虚方法。</p>
<p>&nbsp; &nbsp;&nbsp;5）不可以定义任何静态成员。</p>
<p>&nbsp; &nbsp;&nbsp;6）接口成员默认是全开放的，不得有访问修饰符。</p>
<p>&nbsp; &nbsp;&nbsp;下面是对类Code_06_01的扩充：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('b3488f03-1422-41cb-9511-7725585980f2')"><img id="code_img_closed_b3488f03-1422-41cb-9511-7725585980f2" class="code_img_closed" src="./images/C#接口与抽象类学习笔记2.png" alt="" /><img id="code_img_opened_b3488f03-1422-41cb-9511-7725585980f2" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('b3488f03-1422-41cb-9511-7725585980f2',event)" src="./images/C#接口与抽象类学习笔记3.png" alt="" />
<div id="cnblogs_code_open_b3488f03-1422-41cb-9511-7725585980f2" class="cnblogs_code_hide">
<pre><code>    <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 接口
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> ICode_06_01
        {
            </span><span style="color: #0000ff;">string</span> Name { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
            </span><span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
            </span><span style="color: #0000ff;">event</span><span style="color: #000000;"> EventHandler AddEvent;
        }

        </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {

        }
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp; 2.4方法int Add(int a, int b);的IL：</p>
<div class="cnblogs_code">
<pre><code>.method <span style="color: #0000ff;">public</span> hidebysig newslot <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> 
        instance int32  Add(int32 a,
                            int32 b) cil managed
{
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method ICode_06_01::Add</span></pre>
</div>
<p>&nbsp; &nbsp; 可以看到，定义的时候，我们并没有为其指定可访问修饰符（编译器也不允许我们明文指定其可访问修饰符），但编译器默认将它的访问级</p>
<p>别指定为public，另外是把它当作一个抽象的虚方法。</p>
<p>&nbsp; &nbsp; 至于成员属性和事件，编译器则将它们当作普通的对象属性和对象事件对待，会为它们生成相应的get/set和add/remove 方法，并无特别之</p>
<p>处。</p>
<p>&nbsp; &nbsp; <strong>三、实现方式的区别</strong></p>
<p><span class="spanKeyword">&nbsp; &nbsp; <strong>抽象类</strong> 实现：</span></p>
<p>&nbsp; &nbsp; 由于抽象类也是类，所以对它的实现就像普通的继承一样，子类通过继承可以得到抽象类的公有成员，且可以重写部分成员，如虚方法和抽象</p>
<p>方法等。</p>
<p>&nbsp; &nbsp; 下面是对Code_06_03类的实现：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('8ab59707-c120-4e8a-8770-19d7eb9b917f')"><img id="code_img_closed_8ab59707-c120-4e8a-8770-19d7eb9b917f" class="code_img_closed" src="./images/C#接口与抽象类学习笔记2.png" alt="" /><img id="code_img_opened_8ab59707-c120-4e8a-8770-19d7eb9b917f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('8ab59707-c120-4e8a-8770-19d7eb9b917f',event)" src="./images/C#接口与抽象类学习笔记3.png" alt="" />
<div id="cnblogs_code_open_8ab59707-c120-4e8a-8770-19d7eb9b917f" class="cnblogs_code_hide">
<pre><code>    <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 抽象类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Code_06_03
        {
            Dictionary</span>&lt;Guid, <span style="color: #0000ff;">string</span>&gt; root = <span style="color: #0000ff;">new</span> Dictionary&lt;Guid, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">();
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> Sex { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">string</span> Address { <span style="color: #0000ff;">get</span><span style="color: #000000;">; }

            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 抽象方法ADD
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="a"&gt;&lt;/param&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="b"&gt;&lt;/param&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;returns&gt;&lt;/returns&gt;</span>
            <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);

            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 虚方法GetAddress
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="addressID"&gt;&lt;/param&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;returns&gt;&lt;/returns&gt;</span>
            <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">string</span> GetAddress(<span style="color: #0000ff;">string</span><span style="color: #000000;"> addressID)
            {
                </span><span style="color: #0000ff;">return</span> addressID + <span style="color: #800000;">"</span><span style="color: #800000;"> 广东</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> AddRoot(Guid id, <span style="color: #0000ff;">string</span><span style="color: #000000;"> rootName)
            {
                root.Add(id, rootName);
                OnAddRoot();
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">event</span><span style="color: #000000;"> EventHandler AddRootEvent;

            </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> OnAddRoot()
            {
                AddRootEvent</span>?.Invoke(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">[Guid key]
            {
                </span><span style="color: #0000ff;">get</span><span style="color: #000000;">
                {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root[key];
                }
                </span><span style="color: #0000ff;">set</span><span style="color: #000000;">
                {
                    root[key] </span>=<span style="color: #000000;"> value;
                }
            }
        }

        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 抽象类的实现
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Code_06_04 : Code_06_03
        {
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
            {
                </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
            }
            </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">string</span> GetAddress(<span style="color: #0000ff;">string</span><span style="color: #000000;"> addressID)
            {
                </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">GuangDong</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            }

            </span><span style="color: #0000ff;">readonly</span> <span style="color: #0000ff;">string</span> addressPrefix = <span style="color: #800000;">"</span><span style="color: #800000;">China </span><span style="color: #800000;">"</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> Address
            {
                </span><span style="color: #0000ff;">get</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> addressPrefix; }
            }
        }

        </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {

        }
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp;&nbsp;通过ISDASM来看一下生成的IL：</p>
<p><img src="./images/C#接口与抽象类学习笔记8.png" alt="" /></p>
<p>&nbsp; &nbsp; 可以看到类Code_06_04是标准地对继承类Code_06_03，两个重写的方法Add和GetAddress都是普通的对象方法，只是依然被</p>
<p>当作虚方法来看待。</p>
<p>&nbsp; &nbsp; 3.1方法Add的IL：</p>
<div class="cnblogs_code">
<pre><code>.method <span style="color: #0000ff;">public</span> hidebysig <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> instance int32 
        Add(int32 a,
            int32 b) cil managed
{
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 略过</span><span style="color: #000000;">
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method Code_06_04::Add</span></pre>
</div>
<p>&nbsp; &nbsp; 3.2方法GetAddress的IL：</p>
<div class="cnblogs_code">
<pre><code>.method family hidebysig <span style="color: #0000ff;">virtual</span> instance <span style="color: #0000ff;">string</span><span style="color: #000000;"> 
        GetAddress(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> addressID) cil managed
{
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 略过</span><span style="color: #000000;">
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method Code_06_04::GetAddress</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;因为这两个方法保持着虚方法的特性，所以对于Code_06_04类的子类，同样还可以重写这两个方法。属性成员Address这里还</p>
<p>是一普通的对象属性。</p>
<p>&nbsp; &nbsp;&nbsp;<span class="spanKeyword"><strong>接口&nbsp;</strong>实现</span></p>
<p>&nbsp; &nbsp; 对接口的实现跟对抽象类的实现相似，下面是对接口ICode_06_01的实现：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e50e7433-6275-4424-8c51-d2e5547c4c90')"><img id="code_img_closed_e50e7433-6275-4424-8c51-d2e5547c4c90" class="code_img_closed" src="./images/C#接口与抽象类学习笔记2.png" alt="" /><img id="code_img_opened_e50e7433-6275-4424-8c51-d2e5547c4c90" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e50e7433-6275-4424-8c51-d2e5547c4c90',event)" src="./images/C#接口与抽象类学习笔记3.png" alt="" />
<div id="cnblogs_code_open_e50e7433-6275-4424-8c51-d2e5547c4c90" class="cnblogs_code_hide">
<pre><code>    <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 接口
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> ICode_06_01
        {
            </span><span style="color: #0000ff;">string</span> Name { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
            </span><span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
            </span><span style="color: #0000ff;">event</span><span style="color: #000000;"> EventHandler AddEvent;
        }

        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 接口的实现
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Code_06_02 : ICode_06_01
        {
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> Name { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
            {
                OnAdded();
                </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
            }

            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">event</span><span style="color: #000000;"> EventHandler AddEvent;

            </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> OnAdded()
            {
                AddEvent</span>?.Invoke(<span style="color: #0000ff;">this</span>, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
            }
        }

        </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {

        }
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp;&nbsp;通过ISDASM来看一下生成的IL：</p>
<p><img src="./images/C#接口与抽象类学习笔记11.png" alt="" /></p>
<p>&nbsp; &nbsp; 它与普通类的区别不大，只是很明确的是实现了接口ICode_06_01，来看一下它的IL：</p>
<div class="cnblogs_code">
<pre><code>.<span style="color: #0000ff;">class</span> auto ansi nested <span style="color: #0000ff;">public</span><span style="color: #000000;"> beforefieldinit Code_06_02
       extends [mscorlib]System.Object
       implements LinkTo.Test.InterfaceAndAbstractClass.Program</span>/<span style="color: #000000;">ICode_06_01
{
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of class Code_06_02</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;可以看到，类Code_06_02不仅继承于System.Object类，同时还实现了接口ICode_06_01。再来看一下对于接口中的方法，编</p>
<p>译器是如何处理的？</p>
<p>&nbsp; &nbsp; 3.3方法Add的IL：</p>
<div class="cnblogs_code">
<pre><code>.method <span style="color: #0000ff;">public</span> hidebysig newslot <span style="color: #0000ff;">virtual</span><span style="color: #000000;"> final 
        instance int32  Add(int32 a,
                            int32 b) cil managed
{
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 略过</span><span style="color: #000000;">
} </span><span style="color: #008000;">//</span><span style="color: #008000;"> end of method Code_06_02::Add</span></pre>
</div>
<p>&nbsp; &nbsp; 编译器认为Add方法具有虚方法的特性。而对于属性和事件，依然是普通的实现，如get/set、add/remove。另外，接口还支持</p>
<p>显示实现接口，我们上面讨论的Code_06_02类对接口的实现默认是隐式实现。</p>
<p>&nbsp; &nbsp; 在接口的实现类内部，可以存在一个与接口某一方法名（包括签名）完全相同的方法，但要求对接口实现的那个方法必须是显</p>
<p>示实现，如下代码：</p>
<div class="cnblogs_code">
<pre><code>        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
        {
            </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
        }

        </span><span style="color: #0000ff;">int</span> ICode_06_01.Add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
        {
            OnAdded();
            </span><span style="color: #0000ff;">return</span> a +<span style="color: #000000;"> b;
        }</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;可以看出显示实现就是在方法前加上接口名和点号（ICode_06_01.），另外方法是不能有可访问修饰符的，编译器会对其进行</p>
<p>private处理。那如何才能调用显示实现的接口方法呢？可以将实现类的对象转为一个接口变量，再调用该变量的相应方法，如下</p>
<p>代码：</p>
<div class="cnblogs_code">
<pre><code>        <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {
            Code_06_02 code0602 </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Code_06_02();
            ICode_06_01 icode0602 </span>=<span style="color: #000000;"> code0602;
            </span><span style="color: #0000ff;">var</span> result = icode0602.Add(<span style="color: #800080;">1</span>, <span style="color: #800080;">2</span><span style="color: #000000;">);
            Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Result={result}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            Console.Read();
        }</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;而对于抽象类的实现，是不能进行显示实现的。</p>
<p>&nbsp; &nbsp; <strong>四、应用中的区别</strong></p>
<p>&nbsp; &nbsp; 1）抽象类保留一普通类的部分特性，定义可能已经实现的方法行为，方法内可以对数据成员（如属性）进行操作，且方法可以</p>
<p>相互沟通。而接口仅仅是定义方法的签名，就像规则，只是约定，并没有实现。</p>
<p>&nbsp; &nbsp; 2）抽象类的派生类可以原封不动地得到抽象类的部分成员，接口的实现类如果想要得到接口的数据成员，则必须对其进行重写。</p>
<p>&nbsp; &nbsp; 3）一个类只能继承于一个类（含抽象类），但可以实现多个接口，并且可以在继承一个基类的基础上，同时实现多个接口。</p>
<p>&nbsp; &nbsp; 4）抽象类和接口都不能对其使用密封sealed，事实上这两者都是为了被其他类继承和实现，对其使用sealed是没有任何意义的。</p>
<p>&nbsp; &nbsp; 5）抽象类可以对接口进行实现。</p>
<p>&nbsp; &nbsp; 6）抽象类更多的用于&ldquo;复制对象副本&rdquo;，就是我们常说的&ldquo;子类与父类有着is a的关系&rdquo;，它更多关注于一个对象的整体特性。接口</p>
<p>更多倾向于一系列的方法操作，这些操作在当前上下文中既有着相同作用对象，又相互隔离。</p>
<p>&nbsp; &nbsp; 7）某些时候，抽象类可以与接口互换。</p>
<p>&nbsp; &nbsp; 通过生活中常见的红娘搭线的示例：红娘（Matchmaker）安排相亲者（wooer）见面并指导场面话，来说明接口与抽象类给我们</p>
<p>带来的方便性。</p>
<p>&nbsp; &nbsp; 下面代码演示不使用接口与抽象类的红娘搭线：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('9540eafa-f923-466c-9306-34bb486994d1')"><img id="code_img_closed_9540eafa-f923-466c-9306-34bb486994d1" class="code_img_closed" src="./images/C#接口与抽象类学习笔记2.png" alt="" /><img id="code_img_opened_9540eafa-f923-466c-9306-34bb486994d1" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9540eafa-f923-466c-9306-34bb486994d1',event)" src="./images/C#接口与抽象类学习笔记3.png" alt="" />
<div id="cnblogs_code_open_9540eafa-f923-466c-9306-34bb486994d1" class="cnblogs_code_hide">
<pre><code>    <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 红娘类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Matchmaker
        {
            </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> message;

            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 场面话、客套话指导
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Teach()
            {
                message </span>= <span style="color: #800000;">"</span><span style="color: #800000;">曾经有一份真挚的爱情摆在我面前&hellip;&hellip;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                Wooer wooer </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Wooer();
                wooer.Say(message);
            }
        }

        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 相亲者类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Wooer
        {
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 场面话、客套话大全
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="message"&gt;&lt;/param&gt;</span>
            <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Say(<span style="color: #0000ff;">string</span><span style="color: #000000;"> message)
            {
                Console.WriteLine(message);
            }
        }

        </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {
            </span><span style="color: #0000ff;">#region</span> 不使用接口及抽象类的红娘搭线<span style="color: #000000;">
            Matchmaker matchmaker </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Matchmaker();
            matchmaker.Teach();
            Console.Read();
            </span><span style="color: #0000ff;">#endregion</span><span style="color: #000000;">
        }
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp; 运行结果如下：</p>
<p><img src="./images/C#接口与抽象类学习笔记14.png" alt="" /></p>
<p>&nbsp; &nbsp; 以上功能实现没有问题，但是假如相亲者想要增加一点肢体动作或文艺展示来博取对方好感的话，红娘就得跟着变。于是，红娘</p>
<p>搭建了一个相亲平台&hellip;&hellip;</p>
<p>&nbsp; &nbsp;&nbsp;下面代码演示使用接口与抽象类的红娘搭线：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('de063d77-c99f-4a06-a93e-2ea68219c37c')"><img id="code_img_closed_de063d77-c99f-4a06-a93e-2ea68219c37c" class="code_img_closed" src="./images/C#接口与抽象类学习笔记2.png" alt="" /><img id="code_img_opened_de063d77-c99f-4a06-a93e-2ea68219c37c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('de063d77-c99f-4a06-a93e-2ea68219c37c',event)" src="./images/C#接口与抽象类学习笔记3.png" alt="" />
<div id="cnblogs_code_open_de063d77-c99f-4a06-a93e-2ea68219c37c" class="cnblogs_code_hide">
<pre><code>    <span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    {
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 红娘类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MatchmakerNew
        {
            </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> message;
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 场面话、客套话指导
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Teach(IWooer wooer)
            {
                message </span>= <span style="color: #800000;">"</span><span style="color: #800000;">曾经有一份真挚的爱情摆在我面前&hellip;&hellip;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                wooer.Say(message);
            }
        }
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 相亲者接口
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> IWooer
        {
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 房子车子票子&hellip;&hellip;
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #0000ff;">string</span> Message { <span style="color: #0000ff;">get</span><span style="color: #000000;">; }
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 能歌善舞&hellip;&hellip;
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #0000ff;">void</span><span style="color: #000000;"> Action();
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
            <span style="color: #808080;">///</span><span style="color: #008000;"> 甜言蜜语&hellip;&hellip;
            </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
            <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="message"&gt;&lt;/param&gt;</span>
            <span style="color: #0000ff;">void</span> Say(<span style="color: #0000ff;">string</span><span style="color: #000000;"> message);
        }

        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 男相亲者实现类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> ManWooer : IWooer
        {
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> Message
            {
                </span><span style="color: #0000ff;">get</span> { <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">嫁给我，房子车子票子啥都有。</span><span style="color: #800000;">"</span><span style="color: #000000;">; }
            }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Action()
            {
                Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">野狼disco&hellip;&hellip;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Say(<span style="color: #0000ff;">string</span><span style="color: #000000;"> message)
            {
                Action();
                Console.WriteLine(message </span>+<span style="color: #000000;"> Message);
            }
        }

        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
        <span style="color: #808080;">///</span><span style="color: #008000;"> 女相亲者实现类
        </span><span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
        <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> WomanWooer : IWooer
        {
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> Message
            {
                </span><span style="color: #0000ff;">get</span> { <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">娶了我，这头牛和后面的这座山都是你的。</span><span style="color: #800000;">"</span><span style="color: #000000;">; }
            }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Action()
            {
                Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">相见恨晚&hellip;&hellip;</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Say(<span style="color: #0000ff;">string</span><span style="color: #000000;"> message)
            {
                Action();
                Console.WriteLine(message </span>+<span style="color: #000000;"> Message);
            }
        }

        </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        {
            </span><span style="color: #0000ff;">#region</span> 使用接口及抽象类的红娘搭线<span style="color: #000000;">
            MatchmakerNew matchmakerNew </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> MatchmakerNew();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">男大为婚</span>
            IWooer manWooer= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ManWooer();
            matchmakerNew.Teach(manWooer);
            manWooer.Say(</span><span style="color: #800000;">"</span><span style="color: #800000;">亲：</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            Console.WriteLine();

            </span><span style="color: #008000;">//</span><span style="color: #008000;">女大为嫁</span>
            IWooer womanWooer = <span style="color: #0000ff;">new</span><span style="color: #000000;"> WomanWooer();
            matchmakerNew.Teach(womanWooer);
            womanWooer.Say(</span><span style="color: #800000;">"</span><span style="color: #800000;">亲：</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            
            Console.Read();
            </span><span style="color: #0000ff;">#endregion</span><span style="color: #000000;">
        }
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp; &nbsp; 运行结果如下：</p>
<p><img src="./images/C#接口与抽象类学习笔记17.png" alt="" /></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>