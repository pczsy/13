<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修What&#39;s new in C# 7.0' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>What&#39;s new in C# 7.0</center></div><div class='banquan'>原文出处:本文由博客园博主羊驼和七只章鱼提供。<br/>
原文连接:https://www.cnblogs.com/yhqclub/p/10847565.html</div><br>
    <h2><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">1.数字分隔符(<span class="fontstyle0">Digit Separators </span>)<span class="fontstyle0"><br /></span></span></span></span></span></span></h2>
<p>数字分隔符使代码更具可读性。在声明变量时，可以将_添加到单独的数字中。编译器只删除_。以下代码片段在C＃7中看起来更具可读性：</p>
<p><span class="fontstyle0"><strong>In C# 6</strong><br /></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">long</span> n1 = <span style="color: #800080;">0x1234567890ABCDEF</span>; </pre>
</div>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0">In C# 7</span></span></span></span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">long</span> n2 = 0x1234_5678_90AB_CDEF;</pre>
</div>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">In C# 7.2</span></span></span></span></span></span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">long</span> n2 = 0x_1234_5678_90AB_CDEF;</pre>
</div>
<h2><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">2.二进制(<span class="fontstyle0">Binary Literals </span>)</span></span></span></span></span></span></span></span></span></strong></h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">C＃7为二进制文件提供了一个新的文字。二进制文件只能包含va 0和1。现在，数字分隔符变得尤为重要</span></span></span></span></span></span></span></span></span></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><strong>In C# 7</strong></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">uint</span> binary1 = 0b1111_0000_1010_0101_1111_0000_1010_0101;</pre>
</div>
<h2>3.Expression-bodied 函数成员(Expression-Bodied Members )</h2>
<p><span data-ttu-id="0e4d9-124">C＃6允许表达式方法和属性。使用C＃7，表达式主体可以与构造函数，析构函数，本地函数，属性访问器等一起使用。在这里，您可以看到C＃6和C＃7之间的属性访问器的区别：</span></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><strong>In C# 6</strong><br /></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> _firstName;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> FirstName
{
    </span><span style="color: #0000ff;">get</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> _firstName; }
    </span><span style="color: #0000ff;">set</span> { Set(<span style="color: #0000ff;">ref</span><span style="color: #000000;"> _firstName, value); }
}</span></pre>
</div>
<p><strong>In C# 7</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> _firstName;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> FirstName
{
    </span><span style="color: #0000ff;">get</span> =&gt;<span style="color: #000000;"> _firstName; 
    </span><span style="color: #0000ff;">set</span> =&gt; Set(<span style="color: #0000ff;">ref</span><span style="color: #000000;"> _firstName, value);
}</span></pre>
</div>
<h2><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">4.Out 变量(Out Var)</span></span></span></span></span></span></span></span></span></span></span></h2>
<p>在C＃7之前，必须在使用之前声明out变量。使用C＃7，代码减少了一行，因为变量可以声明</p>
<p>使用：</p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><strong>In C# 6</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> n = <span style="color: #800000;">"</span><span style="color: #800000;">42</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> result;
</span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">string</span>.TryParse(n, <span style="color: #0000ff;">out</span><span style="color: #000000;"> result)
{
    Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Converting to a number was successful:{result}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>In C# 7</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> n = <span style="color: #800000;">"</span><span style="color: #800000;">42</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">string</span>.TryParse(n, <span style="color: #0000ff;">out</span> <span style="color: #0000ff;">var</span><span style="color: #000000;"> result)
{
    Console.WriteLine($</span><span style="color: #800000;">"</span><span style="color: #800000;">Converting to a number was successful:{result}</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}</span></pre>
</div>
<p>&nbsp;</p>
<h2><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">5.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span data-ttu-id="d7fc5-135">非尾随命名参数(<span class="fontstyle0">Non-Trailing Named Arguments </span>)</span></h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">使用C＃7.2，支持非尾随命名参数。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments" data-linktype="relative-path">命名参数和可选参数</a>。<br /><span class="fontstyle0"><strong>In C# 7.0</strong><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">if</span> (Enum.TryParse(weekdayRecommendation.Entity, ignoreCase:<span style="color: #0000ff;">true</span>,result: <span style="color: #0000ff;">out</span><span style="color: #000000;"> DayOfWeek weekday))

{
　　reservation.Weekday </span>=<span style="color: #000000;"> weekday;
}</span></pre>
</div>
<p><strong>In C# 7.2</strong></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">if</span> (Enum.TryParse(weekdayRecommendation.Entity, ignoreCase:<span style="color: #0000ff;">true</span>,<span style="color: #0000ff;">out</span><span style="color: #000000;"> DayOfWeek weekday))
{
　　reservation.Weekday </span>=<span style="color: #000000;"> weekday; 
}</span></pre>
</div>
<h2>6.只读结构(Readonly Struct )</h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">结构应该是只读的（有一些例外）。使用C＃7.2，可以使用readonly修饰符声明结构，因此编译器会验证结构是否未更改。编译器也可以使用此保证不复制将其作为参数传递的结构，而是将其作为引用传递：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><strong>In C# 7.2</strong><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">readonly</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> Dimensions
{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> Length { <span style="color: #0000ff;">get</span><span style="color: #000000;">; }
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> Width { <span style="color: #0000ff;">get</span><span style="color: #000000;">; }
</span><span style="color: #0000ff;">public</span> Dimensions(<span style="color: #0000ff;">double</span> length, <span style="color: #0000ff;">double</span><span style="color: #000000;"> width)
{
Length </span>=<span style="color: #000000;"> length;
Width </span>=<span style="color: #000000;"> width;
}
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> Diagonal =&gt; Math.Sqrt(Length * Length +<span style="color: #000000;"> Width
</span>*<span style="color: #000000;"> Width);
}</span></pre>
</div>
<h2>7.In 修饰参数(In Parameters )</h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">C＃7.2还允许带有参数的in修饰符。这可以保证传递的值类型不会改变，它可以通过引用传递以避免副本：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><strong>In C# 7.2</strong><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> CantChange(<span style="color: #0000ff;">in</span><span style="color: #000000;"> AStruct s)
{
　　</span><span style="color: #008000;">//</span><span style="color: #008000;"> s can't change</span>
} </pre>
</div>
<h2>8.private protected 访问修饰符</h2>
<p>C＃7.2添加了一个新的访问修饰符：private protected。访问修饰符protected internal允许访问该成员（如果已使用）来自同一程序集中的类型，或来自派生自该类的另一个程序集中的类型。对于private protected，如果类派生自基类并且在同一个程序集中，则只允许使用AND而不是OR访问。</p>
<h2>&nbsp;</h2>
<p>使用C＃7.1，定义了一个默认文字，与默认运算符相比，它允许更短的语法。默认运算符总是需要重复类型，现在不再需要了。</p>
<p><span class="fontstyle0"><strong>In C# 7.0</strong><br /></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span> x = <span style="color: #0000ff;">default</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">);
ImmutableArray</span>&lt;<span style="color: #0000ff;">int</span>&gt; arr = <span style="color: #0000ff;">default</span>(ImmutableArray&lt;<span style="color: #0000ff;">int</span>&gt;);</pre>
</div>
<p><strong>In C# 7.1</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span> x = <span style="color: #0000ff;">default</span><span style="color: #000000;">;
ImmutableArray</span>&lt;<span style="color: #0000ff;">int</span>&gt; arr = <span style="color: #0000ff;">default</span>;</pre>
</div>
<h2>10.本地函数(Local Functions )</h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2">在C＃7之前，无法在方法中声明函数。你可以创建一个lambda表达式并调用它，如C＃6代码片段所示：</span></span></span></span></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><strong>In C# 6</strong><br /></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> SomeFunStuff()
{
　　Func</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; add = (x, y) =&gt; x +<span style="color: #000000;"> y;
　　</span><span style="color: #0000ff;">int</span> result = add(<span style="color: #800080;">38</span>, <span style="color: #800080;">4</span><span style="color: #000000;">);
　　Console.WriteLine(result);
}</span></pre>
</div>
<p>使用C＃7，可以在方法中声明本地函数。只能在方法范围内访问本地函数：</p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><strong>In C# 7</strong><br /></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> SomeFunStuff()
{
　　</span><span style="color: #0000ff;">int</span> add(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y) =&gt; x +<span style="color: #000000;"> y;
　　</span><span style="color: #0000ff;">int</span> result = add(<span style="color: #800080;">38</span>, <span style="color: #800080;">4</span><span style="color: #000000;">);
　　Console.WriteLine(result);
}</span></pre>
</div>
<h2>11.元组(Tuples )</h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span data-ttu-id="aa38b-147">低于 C# 7.0 的版本中也提供元组，但它们效率低下且不具有语言支持。&nbsp;<span data-ttu-id="aa38b-148">这意味着元组元素只能作为&nbsp;<code>Item1</code>&nbsp;和&nbsp;<code>Item2</code>&nbsp;等引用。<span data-ttu-id="aa38b-149">C# 7.0 引入了对元组的语言支持，可利用更有效的新元组类型向元组字段赋予语义名称</span></span></span>。在C＃7中，元组是语言的一部分，你可以定义成员的名字：</span></span></span></span></span></span></span></span></span></p>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2">in C# 6</span></span></span></span></span></span></span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> t1 = Tuple.Create(<span style="color: #800080;">42</span>, <span style="color: #800000;">"</span><span style="color: #800000;">astring</span><span style="color: #800000;">"</span><span style="color: #000000;">); 
</span><span style="color: #0000ff;">int</span> i1 =<span style="color: #000000;"> t1.Item1;
</span><span style="color: #0000ff;">string</span> s1 = t1.Item2;</pre>
</div>
<p><strong>In C# 7</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> t1 = (n: <span style="color: #800080;">42</span>, s: <span style="color: #800000;">"</span><span style="color: #800000;">magic</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">int</span> i1 =<span style="color: #000000;"> t1.n;
</span><span style="color: #0000ff;">string</span> s1 = t1.s;</pre>
</div>
<h2>12.推断元组元素名称(Inferred Tuple Names )</h2>
<p><span class="fontstyle0"><span data-ttu-id="6b873-135">此功能是对 C# 7.0 中引入的元组功能一次小型增强。&nbsp;<span data-ttu-id="6b873-136">在初始化元组时，许多时候，赋值操作右侧的变量名与用于元组元素的名称相同,元组元素的名称可通过在 C# 7.1 中初始化元组时使用的变量进行推断：</span></span></span>&nbsp;</p>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">In C# 7.0</span></span></span></span></span></span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">5</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">string</span> label = <span style="color: #800000;">"</span><span style="color: #800000;">Colors used in the map</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> pair = (count: count, label: label);</pre>
</div>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">In C# 7.1</span></span></span></span></span></span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">5</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">string</span> label = <span style="color: #800000;">"</span><span style="color: #800000;">Colors used in the map</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">var</span> pair = (count, label); <span style="color: #008000;">//</span><span style="color: #008000;"> element names are "count" and "label"</span></pre>
</div>
<h2>13.析构元组(Deconstructors )</h2>
<p><span data-ttu-id="aa38b-154">在某些时候，你可能想要解包从方法返回的元组的成员。&nbsp;<span data-ttu-id="aa38b-155">可通过为元组中的每个值声明单独的变量来实现此目的。&nbsp;<span data-ttu-id="aa38b-156">这种解包操作称为析构元组</span></span></span></p>
<p><strong><span data-ttu-id="aa38b-154"><span data-ttu-id="aa38b-155"><span data-ttu-id="aa38b-156">In C# 7</span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span> Person(<span style="color: #800000;">"</span><span style="color: #800000;">Tom</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Turbo</span><span style="color: #800000;">"</span><span style="color: #000000;">);
(</span><span style="color: #0000ff;">string</span> firstName, <span style="color: #0000ff;">string</span> lastName) = p1;</pre>
</div>
<h2><strong><span data-ttu-id="aa38b-154"><span data-ttu-id="aa38b-155"><span data-ttu-id="aa38b-156"><span class="fontstyle0">14.模式匹配(<span class="fontstyle0">Pattern Matching </span>)</span></span></span></span></strong></h2>
<p>通过模式匹配，is运算符和switch语句增强了三种模式：const模式，类型模式和var模式。以下代码段显示</p>
<p>使用is运算符的模式。匹配的第一次检查与常量42匹配，第二次匹配检查Person对象，第三次匹配检查具有var模式的每个对象。使用类型和var模式，可以为强类型访问声明变量：</p>
<p><span class="fontstyle0"><strong>In C# 7</strong><br /></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> PatternMatchingWithIsOperator(<span style="color: #0000ff;">object</span><span style="color: #000000;"> o)
{
　　</span><span style="color: #0000ff;">if</span> (o <span style="color: #0000ff;">is</span> <span style="color: #800080;">42</span><span style="color: #000000;">)
　　{
　　}
　　</span><span style="color: #0000ff;">if</span> (o <span style="color: #0000ff;">is</span><span style="color: #000000;"> Person p)
　　{
　　}
　　</span><span style="color: #0000ff;">if</span> (o <span style="color: #0000ff;">is</span> <span style="color: #0000ff;">var</span><span style="color: #000000;"> v1)
　　{
　　}
}</span></pre>
</div>
<p>使用switch语句，可以对case子句使用相同的模式。如果模式匹配，您还可以声明要强类型的变量。您还可以使用何时在条件上过滤模式：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> PatternMatchingWithSwitchStatement(<span style="color: #0000ff;">object</span><span style="color: #000000;"> o)
{
　　swtich (o)
　　{
　　　　</span><span style="color: #0000ff;">case</span> <span style="color: #800080;">42</span><span style="color: #000000;">:
　　　　</span><span style="color: #0000ff;">break</span><span style="color: #000000;">; 
　　　　</span><span style="color: #0000ff;">case</span> Person p when p.FirstName == <span style="color: #800000;">"</span><span style="color: #800000;">Katharina</span><span style="color: #800000;">"</span><span style="color: #000000;">:
　　　　</span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
　　　　</span><span style="color: #0000ff;">case</span><span style="color: #000000;"> Person p:
　　　　</span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
　　　　</span><span style="color: #0000ff;">case</span> <span style="color: #0000ff;">var</span><span style="color: #000000;"> v:
　　　　</span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
　　}
}</span></pre>
</div>
<p><span style="color: #ff0000;">注:使用&nbsp;</span><code style="color: #ff0000;">when</code><span style="color: #ff0000;">&nbsp;关键字来指定模式的其他规则。</span></p>
<h2><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">15.Throw表达式(<span class="fontstyle0">Throw Expressions </span>)</span></span></span></span></span></span></span></span></span></span></span></h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">抛出异常只能通过声明来实现;在表达中是不可能的。因此，当使用构造函数接收参数时，需要额外检查null以抛出ArgumentNullException。使用C＃7，可以在表达式中抛出异常，因此当左侧为空时，可以使用合并运算符抛出ArgumentNullException</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><strong>In C# 6</strong><br /></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">readonly</span><span style="color: #000000;"> IBooksService _booksService;
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> BookController(BooksService booksService)
{
　　</span><span style="color: #0000ff;">if</span> (booksService == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
　　{
　　　　</span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArgumentNullException(nameof(b));
　　}
　　_booksService </span>=<span style="color: #000000;"> booksService;
}</span></pre>
</div>
<p><strong>In C# 7</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">readonly</span><span style="color: #000000;"> IBooksService _booksService;
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> BookController(BooksService booksService)
{
　　_booksService </span>= booksService ?? <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArgumentNullException(nameof(b));
}</span></pre>
</div>
<h2>16.异步Main方法</h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">在C＃7.1之前，Main方法总是需要声明为void类型。用C＃7。1,Main方法也可以是Task类型，并使用async和await关键字：<br /><span class="fontstyle0"><strong>In C# 7.0</strong><br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Main()
{
　　SomeMethodAsync().Wait();
}</span></pre>
</div>
<p><strong>In C# 7.1</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">async</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> Task Main()
{
　　</span><span style="color: #0000ff;">await</span><span style="color: #000000;"> SomeMethodAsync();
}</span></pre>
</div>
<h2>17.条件Ref表达式</h2>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">以下代码片段声明方法GetNumber以返回对int的引用。这条路，调用者可以直接访问数组中的元素，并可以更改其内容：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle0">In C# 7.0</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span>[] _numbers = { <span style="color: #800080;">3</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">11</span>, <span style="color: #800080;">15</span>, <span style="color: #800080;">21</span><span style="color: #000000;"> };
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">ref</span> <span style="color: #0000ff;">int</span> GetNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index)
{
</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">ref</span><span style="color: #000000;"> _numbers[index];
} </span></pre>
</div>
<p><strong><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">In C# 7.2</span></span></span></span></span></span></span></span></span></span></span></strong></p>
<p><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0"><span class="fontstyle2"><span class="fontstyle0">变量&nbsp;<code>r</code>&nbsp;是对&nbsp;<code>arr</code>&nbsp;或&nbsp;<code>otherArr</code>&nbsp;中第一个值的引用。</span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">ref</span> <span style="color: #0000ff;">var</span> r = <span style="color: #0000ff;">ref</span> (arr != <span style="color: #0000ff;">null</span> ? <span style="color: #0000ff;">ref</span> arr[<span style="color: #800080;">0</span>] : <span style="color: #0000ff;">ref</span> otherArr[<span style="color: #800080;">0</span>]);</pre>
</div>
<p><span style="color: #339966;">扩展:</span></p>
<p><span style="color: #339966;">1.使用C＃7.2，可以将readonly修饰符添加到ref返回。调用者接收引用但不允许更改它：</span></p>
<p><strong>In C# 7.2</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">int</span>[] _numbers = { <span style="color: #800080;">3</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">11</span>, <span style="color: #800080;">15</span>, <span style="color: #800080;">21</span><span style="color: #000000;"> };
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">ref</span> <span style="color: #0000ff;">readonly</span> <span style="color: #0000ff;">int</span> GetNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;"> index)
{
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">ref</span><span style="color: #000000;"> _numbers[index];
}</span></pre>
</div>
<p><span style="color: #339966;">2.ref Struct (在C＃7.2之前，C＃可以创建引用类型（类）和值类型（结构）。但是，当发生装箱时，结构也可以存储在堆上。用C＃7.2,可以声明只允许在堆栈上使用的类型：ref struct)</span></p>
<p><strong>In C# 7.2</strong></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">ref</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> OnlyOnTheStack
{
} </span></pre>
</div>
<p>C# 更多语法糖请参阅微软官方文档.<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/index">https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/index</a></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>