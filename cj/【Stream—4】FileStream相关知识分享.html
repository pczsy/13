<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【Stream—4】FileStream相关知识分享' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【Stream—4】FileStream相关知识分享</center></div><div class='banquan'>原文出处:本文由博客园博主萌萌丶小魔王提供。<br/>
原文连接:https://www.cnblogs.com/xiaomowang/p/11770864.html</div><br>
    <p><strong>一、如何理解FIleStream</strong></p>
<p>通过前3章的学些，相信大家对于Stream已经有一定的了解，但是又如何去理解FileStream呢？请看下图：</p>
<p><img src="./images/【Stream—4】FileStream相关知识分享0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;我们磁盘中的任何文件都是通过二进制数组组成，最为直观的就是记事本了，当我们新建一个记事本时，它的大小时0KB，我们每次输入一个数字或字母时，文件便会自动增大到4KB，可见，随着我们输入的内容越来越多，文件也会越来越大，同理，当我们删除文件内容时，文件也会相应的减小，对了，聪明的你肯定会问：谁将内容以怎样的形式放到文件中去了？</p>
<p>好问题，还记得第一章流的概念嘛？对了，真实世界的一群鱼可以通过河流往前往各个地方，FileStream也一样，byte可以通过FileStream进行传输，这样我们便能在计算机上对任何文件进行一系列操作了。</p>
<p><strong>二、FileStream的重要性</strong></p>
<p>FileStream顾名思义文件流，我们电脑上的文件都可以通过文件流进行操作，例如文件的复制、简介、粘贴、删除、本地文件上传、下载、等许多重要的功能都离不开文件流。所以文件流不仅在本机上非常重要，在如今的网络世界上也万万不能缺少的，想象一下我们开启虚拟机后，直接从本地复制一个文件到虚拟机上，时多么的方便，如果没有文件流，这个将难以想象。（大家别误解，文件流通过网络流将客户都安上传的文件传到服务器端接收，然后通过文件流进行处理，下载正好相反）</p>
<p><strong>三、FileStream常用构造函数介绍</strong></p>
<p><strong>1、FileStream(SafeFileHandle safeFileHandle,FileAccess fileAccess)</strong></p>
<p>非托管参数SafeFileHandle简单介绍</p>
<p>SafeFileHandle：是一个文件安全句柄，这样的解释可能大家一头雾水，别急，大家先不要去理睬这深邃的含义，只要知道这个类型是C#非托管资源，也就是说它能够调用非托管资源的方法，而且不属于C#回收机制，所以我们必须使用GC手动或其他方式（Finalize或Dispose方法）进行非托管资源的回收，所以SafeFileHandle是一个默默无闻的保镖，一直暗中保护FileStream和文件的安全，为了让大家更好的理解这个保镖，请看第一段代码：</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
</span><span style="color: #008080;">2</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">3</span>             <span style="color: #0000ff;">var</span> rootPath =<span style="color: #000000;"> Environment.CurrentDirectory;
</span><span style="color: #008080;">4</span>             <span style="color: #0000ff;">var</span> fileName = Path.Combine(rootPath, <span style="color: #800000;">"</span><span style="color: #800000;">TextFile1.txt</span><span style="color: #800000;">"</span>);<span style="color: #008000;">//</span><span style="color: #008000;">@"TextFile1.txt";</span>
<span style="color: #008080;">5</span>             FileStream fileStream = <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStream(fileName, FileMode.OpenOrCreate);
</span><span style="color: #008080;">6</span> <span style="color: #000000;">            Console.ReadLine();
</span><span style="color: #008080;">7</span> <span style="color: #000000;">            File.Delete(fileName);
</span><span style="color: #008080;">8</span> <span style="color: #000000;">            Console.ReadKey();
</span><span style="color: #008080;">9</span>         }</pre>
</div>
<p>我们运行一下，结果报错了，我看看一下错误：</p>
<p><img src="./images/【Stream—4】FileStream相关知识分享1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;为什么会报错呢？其实程序被卡在了Console.ReadLine()这里，FileStream并没有被释放，系统不知道这个文件是否还有用，所以帮我们保护这个文件（那个非托管资源SafeFileHandle所使用的内存还被占用着）所以SafeFileHandle在内部保护了这个文件从而报出了这个异常，如果我们将流关闭后，这个问题就不存在了。</p>
<p>所以，我们又回到了一个老问题上面，我们每次使用完FileStream后都必须将他关闭并释放资源。</p>
<p><strong>2、FileStream(string str,FileModel model)</strong></p>
<p>string 参数表示文件所在的地址，FileMode是个枚举，表示确定如何打开或创建文件 。</p>
<p>FileModel枚举参数包含以下内容：</p>
<table style="height: 433px; width: 1489px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="18%">
<p style="text-align: left;">成员名称</p>
</td>
<td valign="top" width="81%">
<p>说明</p>
</td>
</tr>
<tr>
<td valign="top" width="18%">
<p>Append</p>
</td>
<td valign="top" width="81%">
<p>打开现有文件并查找到文件尾，或创建新文件。FileMode.Append 只能同 FileAccess.Write 一起使用。</p>
</td>
</tr>
<tr>
<td valign="top" width="18%">
<p>&nbsp;&nbsp; &nbsp;</p>
<p>Create</p>
</td>
<td valign="top" width="81%">
<p>指定操作系统应创建新文件。如果文件已存在，它将被改写。这要求 FileIOPermissionAccess.Write。</p>
<p>System.IO.FileMode.Create 等效于这样的请求：如果文件不存在，则使用 CreateNew；否则使用 Truncate。</p>
</td>
</tr>
<tr>
<td valign="top" width="18%">
<p>CreateNew</p>
</td>
<td valign="top" width="81%">
<p>指定操作系统应创建新文件。此操作需要 FileIOPermissionAccess.Write。如果文件已存在，则将引发 IOException。</p>
</td>
</tr>
<tr>
<td valign="top" width="18%">
<p>&nbsp;&nbsp; &nbsp;</p>
<p>Open</p>
</td>
<td valign="top" width="81%">
<p>指定操作系统应打开现有文件。打开文件的能力取决于 FileAccess &nbsp; 所指定的值。如果该文件不存在，</p>
<p>则引发 System.IO.FileNotFoundException。</p>
</td>
</tr>
<tr>
<td valign="top" width="18%">
<p>&nbsp;&nbsp; &nbsp;</p>
<p>OpenOrCreate</p>
</td>
<td valign="top" width="81%">
<p>指定操作系统应打开文件（如果文件存在）；否则，应创建新文件。如果用 FileAccess.Read &nbsp; 打开文件，则需要</p>
<p>&nbsp;FileIOPermissionAccess.Read。如果文件访问为 FileAccess.Write 或 FileAccess.ReadWrite，则需要</p>
<p>FileIOPermissionAccess.Write。如果文件访问为 FileAccess.Append，则需要 FileIOPermissionAccess.Append。</p>
</td>
</tr>
<tr>
<td valign="top" width="18%">
<p>&nbsp;&nbsp; &nbsp;</p>
<p>Truncate</p>
</td>
<td valign="top" width="81%">
<p>指定操作系统应打开现有文件。文件一旦打开，就将被截断为零字节大小。此操作需要 FileIOPermissionAccess.Write。</p>
<p>试图从使用 Truncate 打开的文件中进行读取将导致异常。</p>
</td>
</tr>
</tbody>
</table>
<p><strong>&nbsp;3、FileStream(IntPtr intPtr,FIleAccess fileAccess,Boolean ownsHandle)</strong></p>
<p>FileAccess参数也是一个枚举，表示对该文件的操作权限：</p>
<p><img src="./images/【Stream—4】FileStream相关知识分享2.png" alt="" width="703" height="223" /></p>
<p>&nbsp;</p>
<p>&nbsp;参数ownsHandle：也就是类似于前面和大家介绍的SafeFileHandler，有2点必须注意：（1）对于指定的文件句柄，操作系统不允许所请求的access，例如：当access为Write或ReadWrite而文件句柄设置为只读访问的时候，会出现异常。所以ownsHandle才是老大，FileAccess的权限应该在ownsHandle的范围内。（2）FileStream假定它的句柄有独占控制权，当FileStream也持有句柄时，读取、写入或查找可能会导致数据破坏，为了数据安全，请使用句柄前调用Flush，并避免在使用完句柄后调用Close以外的任何方法。</p>
<p><strong>4、FileStream(string str,FileModel model,FileAccess,fileAccess,FileShare fileShare)</strong></p>
<p>FileShare：同样时一个枚举类型，确定文件如何由进程共享。</p>
<table style="height: 248px; width: 1420px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p align="left">Delete</p>
</td>
<td valign="top">
<p align="left">允许随后删除文件。</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="left">Inheritable</p>
</td>
<td valign="top">
<p align="left">使文件句柄可由子进程继承。Win32 不直接支持此功能。</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="left">None</p>
</td>
<td valign="top">
<p align="left">谢绝共享当前文件。文件关闭前，打开该文件的任何请求（由此进程或另一进程发出的请求）都将失败。</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="left">Read</p>
</td>
<td valign="top">
<p align="left">允许随后打开文件读取。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取的请求（由此进程或另一进程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="left">ReadWrite</p>
</td>
<td valign="top">
<p align="left">允许随后打开文件读取或写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行读取或写入的请求（由此进程或另一进程发出）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</p>
</td>
</tr>
<tr>
<td valign="top">
<p align="left">Write</p>
</td>
<td valign="top">
<p align="left">允许随后打开文件写入。如果未指定此标志，则文件关闭前，任何打开该文件以进行写入的请求（由此进程或另一进过程发出的请求）都将失败。但是，即使指定了此标志，仍可能需要附加权限才能够访问该文件。</p>
</td>
</tr>
</tbody>
</table>
<p><strong>5、FileStream(string str,FileMode mode,FileAccess fileAccess,FileShare fileShare,Int32 i,Boolean async)</strong></p>
<p>Int32:这是一个缓冲区的大小，大家可以按照自己的需要定制；</p>
<p>Boolean async：是否异步读写，告诉FileStream示例，是否采用异步读写</p>
<p><strong>6、FileStream(string str,FileMode mode,FileShare fileShare,Int32 i,FileOption fileOption)</strong></p>
<p>FileOption:这是类似于FileStream对于我呢见操作的高级选项</p>
<p>四、FileStream常用属性介绍</p>
<p>1、CanRead：指示FileStream是否可以读操作</p>
<p>2、CanSeek：指示FileStream是否可以跟踪查找流操作</p>
<p>3、IsAsync：FileStream是否同步工作还是异步工作</p>
<p>4、Name：FileStream的名字，只读属性</p>
<p>5、ReadTimeout：设置读取超时时间</p>
<p>6、SafeFileHandle：文件安全句柄，只读属性</p>
<p>7、Position：当前FileStream所在的流的位置</p>
<p><strong>五、FileStream常用方法介绍</strong></p>
<p>以下方法重写了Stream的一些虚方法</p>
<p>1、IAsyncResult BeginRead 异步读取</p>
<p>2、IAsyncResult BeginWrite 异步写</p>
<p>3、void Close 关闭当前FileStream</p>
<p>4、void EndRead 异步读取结束</p>
<p>5、void EndWrite 异步写结束</p>
<p>6、void Flush 立刻释放缓冲区，将数据全部导出到基础流（文件）中</p>
<p>7、int Read 一般读取</p>
<p>8、int ReadByte 读取单个字节</p>
<p>9、long Seek 跟踪查找流所在的位置</p>
<p>10、void SetLength 设置FileStream的长度</p>
<p>11、void Write 一般写</p>
<p>12、void WriteByte 写入单个字节</p>
<p><strong>六、属于FileStream独有的方法</strong></p>
<p>1、FileSecurity GetAccessControl()</p>
<p>这个不是很常用，FileSecurity时文件安全类，直接表达当前文件的访问控制列表（ACL）的复合当前文件权限的项目，ACL大家有个了解就行，以后会单独和大家讨论下ACL方面的知识</p>
<p>2、void Lock(long position,long length)</p>
<p>这个Lock方法和线程中的Lock关键字很不一样，它能够锁住文件中的某一部分，非常的强悍！用了这个方法我们能够精确锁定住我们要锁住的文件的部分内容</p>
<p>3、void SetAccessControl(FileSecurity fileSecurity)</p>
<p>和GetAccessControl很相似，ACL技术会再以后单独介绍</p>
<p>4、void Unlock(long position,long length)</p>
<p>正好和lock方法相反，对于文件部分的解锁</p>
<p><strong>七、文件的新建和拷贝（主要演示文件同步和异步操作）</strong></p>
<p>首先我们尝试DIY一个IFileCOnfig</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> IFileConfig
</span><span style="color: #008080;">2</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">3</span>         <span style="color: #0000ff;">string</span> FileName { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
</span><span style="color: #008080;">4</span>         <span style="color: #0000ff;">bool</span> IsAsync { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
</span><span style="color: #008080;">5</span>     }</pre>
</div>
<p>&nbsp;创建文件配置类CreateFileConfig，用于添加文件一些配置设置，实现添加文件的操作</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CreateFileConfig : IFileConfig
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 3</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 4</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 文件名称
</span><span style="color: #008080;"> 5</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;"> 6</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> FileName { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
</span><span style="color: #008080;"> 7</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 8</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 是否异步
</span><span style="color: #008080;"> 9</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;">10</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">bool</span> IsAsync { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
</span><span style="color: #008080;">11</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;">12</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 创建文件所在Url
</span><span style="color: #008080;">13</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;">14</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> CreateUrl { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
</span><span style="color: #008080;">15</span>     }</pre>
</div>
<p>让我们定义一个文件流测试类：FileStreamTest来实现文件的操作。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span>     <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;">2</span>     <span style="color: #808080;">///</span><span style="color: #008000;"> 文件测试类
</span><span style="color: #008080;">3</span>     <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;">4</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> FileStreamTest</pre>
</div>
<p>在该类中实现一个简单的Create方法，用来同步或异步的实现添加文件，FileStream会根据配置类去选择相应的构造函数，实现异步或同步的添加方式</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 2</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 添加文件方法
</span><span style="color: #008080;"> 3</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;"> 4</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="config"&gt;&lt;/param&gt;</span>
<span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Create(IFileConfig config)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 7</span>             <span style="color: #0000ff;">lock</span><span style="color: #000000;"> (_lockObject)
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            {
</span><span style="color: #008080;"> 9</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">得到创建文件配置的对象</span>
<span style="color: #008080;">10</span>                 <span style="color: #0000ff;">var</span> createFileConfig = config <span style="color: #0000ff;">as</span><span style="color: #000000;"> CreateFileConfig;
</span><span style="color: #008080;">11</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">假设创建完文件后写入一段话，实际项目中无需这么做，这里只是演示</span>
<span style="color: #008080;">12</span>                 <span style="color: #0000ff;">char</span>[] insertContent = <span style="color: #800000;">"</span><span style="color: #800000;">HellowWord</span><span style="color: #800000;">"</span><span style="color: #000000;">.ToCharArray();
</span><span style="color: #008080;">13</span>                 <span style="color: #0000ff;">if</span> (createFileConfig == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">15</span>                     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">16</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">17</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">转化成byte[]</span>
<span style="color: #008080;">18</span>                 <span style="color: #0000ff;">byte</span>[] byteArrayContent = Encoding.Default.GetBytes(insertContent, <span style="color: #800080;">0</span><span style="color: #000000;">, insertContent.Length);
</span><span style="color: #008080;">19</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">根据传入的配置文件来决定是否同步或者异步实例化Stream对象</span>
<span style="color: #008080;">20</span>                 FileStream stream =<span style="color: #000000;"> createFileConfig.IsAsync
</span><span style="color: #008080;">21</span>                     ? <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStream(createFileConfig.CreateUrl, FileMode.Create, FileAccess.ReadWrite, FileShare.None,
</span><span style="color: #008080;">22</span>                         <span style="color: #800080;">4096</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">)
</span><span style="color: #008080;">23</span>                     : <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStream(createFileConfig.CreateUrl, FileMode.Create);
</span><span style="color: #008080;">24</span>                 <span style="color: #0000ff;">using</span><span style="color: #000000;"> (stream)
</span><span style="color: #008080;">25</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">26</span>                     <span style="color: #008000;">//</span><span style="color: #008000;">如果不注释下面代码会抛出异常，google上提示是WriteTimeOut只支持网络流
</span><span style="color: #008080;">27</span>                     <span style="color: #008000;">//</span><span style="color: #008000;">stream.WriteTimeout=READ_OR_WRITE_TIMEOUT;
</span><span style="color: #008080;">28</span>                     <span style="color: #008000;">//</span><span style="color: #008000;">如果流是同步并且可写</span>
<span style="color: #008080;">29</span>                     <span style="color: #0000ff;">if</span> (!stream.IsAsync &amp;&amp;<span style="color: #000000;"> stream.CanWrite)
</span><span style="color: #008080;">30</span> <span style="color: #000000;">                    {
</span><span style="color: #008080;">31</span>                         stream.Write(byteArrayContent, <span style="color: #800080;">0</span><span style="color: #000000;">, byteArrayContent.Length);
</span><span style="color: #008080;">32</span> <span style="color: #000000;">                    }
</span><span style="color: #008080;">33</span>                     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (stream.CanWrite)<span style="color: #008000;">//</span><span style="color: #008000;">异步可写</span>
<span style="color: #008080;">34</span> <span style="color: #000000;">                    {
</span><span style="color: #008080;">35</span>                         stream.BeginWrite(byteArrayContent, <span style="color: #800080;">0</span><span style="color: #000000;">, byteArrayContent.Length, End_CreateFileCallBack, stream);
</span><span style="color: #008080;">36</span> <span style="color: #000000;">                    }
</span><span style="color: #008080;">37</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">38</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">39</span>         }</pre>
</div>
<p>如果采用异步的方式则最后会进入End_CreateFileCallBack回调方法，result AsyncState 对象就是上图stream.BeginWrite()方法的最后一个参数。还有一点必须注意的是每一次使用BeginWrite()方法都要带上EndWrite()方法，Read方法也一样</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 2</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 异步写文件callBack方法
</span><span style="color: #008080;"> 3</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;"> 4</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="result"&gt;&lt;/param&gt;</span>
<span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> End_CreateFileCallBack(IAsyncResult result)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 7</span>             <span style="color: #008000;">//</span><span style="color: #008000;">从IAsyncResult对象中得到原来的FileStream</span>
<span style="color: #008080;"> 8</span>             <span style="color: #0000ff;">var</span> stream = result.AsyncState <span style="color: #0000ff;">as</span><span style="color: #000000;"> FileStream;
</span><span style="color: #008080;"> 9</span>             <span style="color: #008000;">//</span><span style="color: #008000;">结束异步写</span>
<span style="color: #008080;">10</span>             <span style="color: #0000ff;">if</span> (stream != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">12</span>                 Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">异步创建文件地址{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, stream.Name);
</span><span style="color: #008080;">13</span> <span style="color: #000000;">                stream.EndWrite(result);
</span><span style="color: #008080;">14</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> <span style="color: #000000;">            Console.ReadKey();
</span><span style="color: #008080;">17</span>         }</pre>
</div>
<p>文件复制的方式思路比较相似，首先定义复制文件配置类，由于在异步回调中用到该配置类的属性，所以新增了文件流对象和相应的字节数组</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 2</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 异步读文件方法
</span><span style="color: #008080;"> 3</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;"> 4</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="result"&gt;&lt;/param&gt;</span>
<span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> End_ReadFileCallBack(IAsyncResult result)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 7</span>             <span style="color: #008000;">//</span><span style="color: #008000;">得到先前的配置文件</span>
<span style="color: #008080;"> 8</span>             <span style="color: #0000ff;">var</span> config = result.AsyncState <span style="color: #0000ff;">as</span><span style="color: #000000;"> CopyFileConfig;
</span><span style="color: #008080;"> 9</span>             <span style="color: #008000;">//</span><span style="color: #008000;">结束异步读</span>
<span style="color: #008080;">10</span>             config?<span style="color: #000000;">.OriginalFileStream.EndRead(result);
</span><span style="color: #008080;">11</span>             <span style="color: #008000;">//</span><span style="color: #008000;">异步读后立即写入新文件地址</span>
<span style="color: #008080;">12</span>             <span style="color: #0000ff;">if</span> (config != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">13</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">14</span>                 FileStream copyStream = <span style="color: #0000ff;">new</span> FileStream(config.DestinationFileUrl, FileMode.CreateNew, FileAccess.Write, FileShare.Write, <span style="color: #800080;">4096</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>                 <span style="color: #0000ff;">using</span><span style="color: #000000;"> (copyStream)
</span><span style="color: #008080;">16</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">17</span>                     Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">异步复制原文件地址：{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, config.OriginalFileStream.Name);
</span><span style="color: #008080;">18</span>                     Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">复制后的新文件地址：{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, config.DestinationFileUrl);
</span><span style="color: #008080;">19</span>                     <span style="color: #008000;">//</span><span style="color: #008000;">调用异步写方法callBack方法为End_CreateFileCallBack，参数是copyStream</span>
<span style="color: #008080;">20</span>                     copyStream.BeginWrite(config.OriginalFileBytes, <span style="color: #800080;">0</span><span style="color: #000000;">, config.OriginalFileBytes.Length,
</span><span style="color: #008080;">21</span> <span style="color: #000000;">                        End_CreateFileCallBack, copyStream);
</span><span style="color: #008080;">22</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">23</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">24</span>         }</pre>
</div>
<p>然后在FileStreamTest类中新增一个Copy方法实现文件的复制功能</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 2</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 复制文件
</span><span style="color: #008080;"> 3</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;"> 4</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="config"&gt;&lt;/param&gt;</span>
<span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Copy(IFileConfig config)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 7</span>             <span style="color: #0000ff;">lock</span><span style="color: #000000;"> (_lockObject)
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">            {
</span><span style="color: #008080;"> 9</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">得到CopyFileConfig对象</span>
<span style="color: #008080;">10</span>                 <span style="color: #0000ff;">var</span> copyFileConfig = config <span style="color: #0000ff;">as</span><span style="color: #000000;"> CopyFileConfig;
</span><span style="color: #008080;">11</span>                 <span style="color: #0000ff;">if</span> (copyFileConfig == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">12</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">13</span>                     <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">15</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">创建同步或异步流</span>
<span style="color: #008080;">16</span>                 FileStream stream =<span style="color: #000000;"> copyFileConfig.IsAsync
</span><span style="color: #008080;">17</span>                     ? <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStream(copyFileConfig.OriginalFileUrl, FileMode.Open, FileAccess.Read, FileShare.Read,
</span><span style="color: #008080;">18</span>                         <span style="color: #800080;">4096</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">)
</span><span style="color: #008080;">19</span>                     : <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStream(copyFileConfig.OriginalFileUrl, FileMode.Open);
</span><span style="color: #008080;">20</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">定义一个byte数组接收从原文件读取的byte数据</span>
<span style="color: #008080;">21</span>                 <span style="color: #0000ff;">byte</span>[] originalFileBytes = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span><span style="color: #000000;">[stream.Length];
</span><span style="color: #008080;">22</span>                 <span style="color: #0000ff;">using</span><span style="color: #000000;"> (stream)
</span><span style="color: #008080;">23</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">24</span>                     <span style="color: #008000;">//</span><span style="color: #008000;">如果异步流</span>
<span style="color: #008080;">25</span>                     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (stream.IsAsync)
</span><span style="color: #008080;">26</span> <span style="color: #000000;">                    {
</span><span style="color: #008080;">27</span>                         <span style="color: #008000;">//</span><span style="color: #008000;">将该流和流独处的byte[]数据放入配置类，在callback中可以使用</span>
<span style="color: #008080;">28</span>                         copyFileConfig.OriginalFileStream =<span style="color: #000000;"> stream;
</span><span style="color: #008080;">29</span>                         copyFileConfig.OriginalFileBytes =<span style="color: #000000;"> originalFileBytes;
</span><span style="color: #008080;">30</span>                         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (stream.CanRead)
</span><span style="color: #008080;">31</span> <span style="color: #000000;">                        {
</span><span style="color: #008080;">32</span>                             <span style="color: #008000;">//</span><span style="color: #008000;">异步开始读取，读取完后进入End_ReadFileCallBack方法，该方法接收copyFileConfig参数</span>
<span style="color: #008080;">33</span>                             stream.BeginRead(originalFileBytes, <span style="color: #800080;">0</span><span style="color: #000000;">, originalFileBytes.Length, End_ReadFileCallBack,
</span><span style="color: #008080;">34</span> <span style="color: #000000;">                                copyFileConfig);
</span><span style="color: #008080;">35</span> <span style="color: #000000;">                        }
</span><span style="color: #008080;">36</span>                         <span style="color: #0000ff;">else</span><span style="color: #008000;">//</span><span style="color: #008000;">否则同步读取</span>
<span style="color: #008080;">37</span> <span style="color: #000000;">                        {
</span><span style="color: #008080;">38</span>                             <span style="color: #0000ff;">if</span><span style="color: #000000;"> (stream.CanRead)
</span><span style="color: #008080;">39</span> <span style="color: #000000;">                            {
</span><span style="color: #008080;">40</span>                                 <span style="color: #008000;">//</span><span style="color: #008000;">读取原文件</span>
<span style="color: #008080;">41</span>                                 stream.Read(originalFileBytes, <span style="color: #800080;">0</span><span style="color: #000000;">, originalFileBytes.Length);
</span><span style="color: #008080;">42</span> <span style="color: #000000;">                            }
</span><span style="color: #008080;">43</span>                             <span style="color: #008000;">//</span><span style="color: #008000;">定义一个写流，在新位置中创建一个文件</span>
<span style="color: #008080;">44</span>                             FileStream copyStream = <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStream(copyFileConfig.DestinationFileUrl, FileMode.CreateNew);
</span><span style="color: #008080;">45</span>                             <span style="color: #0000ff;">using</span><span style="color: #000000;"> (copyStream)
</span><span style="color: #008080;">46</span> <span style="color: #000000;">                            {
</span><span style="color: #008080;">47</span>                                 <span style="color: #008000;">//</span><span style="color: #008000;">将原文件的内容写进新文件</span>
<span style="color: #008080;">48</span>                                 copyStream.Write(originalFileBytes, <span style="color: #800080;">0</span><span style="color: #000000;">, originalFileBytes.Length);
</span><span style="color: #008080;">49</span> <span style="color: #000000;">                            }
</span><span style="color: #008080;">50</span> <span style="color: #000000;">                        }
</span><span style="color: #008080;">51</span> 
<span style="color: #008080;">52</span> <span style="color: #000000;">                        Console.ReadLine();
</span><span style="color: #008080;">53</span> <span style="color: #000000;">                    }
</span><span style="color: #008080;">54</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">55</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">56</span>         }</pre>
</div>
<p>最后，如果采用异步的方式，则会进入End_ReadFileCallBack回调函数进行异步读取和异步写操作</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;summary&gt;</span>
<span style="color: #008080;"> 2</span>         <span style="color: #808080;">///</span><span style="color: #008000;"> 异步读文件方法
</span><span style="color: #008080;"> 3</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;/summary&gt;</span>
<span style="color: #008080;"> 4</span>         <span style="color: #808080;">///</span> <span style="color: #808080;">&lt;param name="result"&gt;&lt;/param&gt;</span>
<span style="color: #008080;"> 5</span>         <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> End_ReadFileCallBack(IAsyncResult result)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 7</span>             <span style="color: #008000;">//</span><span style="color: #008000;">得到先前的配置文件</span>
<span style="color: #008080;"> 8</span>             <span style="color: #0000ff;">var</span> config = result.AsyncState <span style="color: #0000ff;">as</span><span style="color: #000000;"> CopyFileConfig;
</span><span style="color: #008080;"> 9</span>             <span style="color: #008000;">//</span><span style="color: #008000;">结束异步读</span>
<span style="color: #008080;">10</span>             config?<span style="color: #000000;">.OriginalFileStream.EndRead(result);
</span><span style="color: #008080;">11</span>             <span style="color: #008000;">//</span><span style="color: #008000;">异步读后立即写入新文件地址</span>
<span style="color: #008080;">12</span>             <span style="color: #0000ff;">if</span> (config != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
</span><span style="color: #008080;">13</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">14</span>                 FileStream copyStream = <span style="color: #0000ff;">new</span> FileStream(config.DestinationFileUrl, FileMode.CreateNew, FileAccess.Write, FileShare.Write, <span style="color: #800080;">4096</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">15</span>                 <span style="color: #0000ff;">using</span><span style="color: #000000;"> (copyStream)
</span><span style="color: #008080;">16</span> <span style="color: #000000;">                {
</span><span style="color: #008080;">17</span>                     Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">异步复制原文件地址：{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, config.OriginalFileStream.Name);
</span><span style="color: #008080;">18</span>                     Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">复制后的新文件地址：{0}</span><span style="color: #800000;">"</span><span style="color: #000000;">, config.DestinationFileUrl);
</span><span style="color: #008080;">19</span>                     <span style="color: #008000;">//</span><span style="color: #008000;">调用异步写方法callBack方法为End_CreateFileCallBack，参数是copyStream</span>
<span style="color: #008080;">20</span>                     copyStream.BeginWrite(config.OriginalFileBytes, <span style="color: #800080;">0</span><span style="color: #000000;">, config.OriginalFileBytes.Length,
</span><span style="color: #008080;">21</span> <span style="color: #000000;">                        End_CreateFileCallBack, copyStream);
</span><span style="color: #008080;">22</span> <span style="color: #000000;">                }
</span><span style="color: #008080;">23</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">24</span>         }</pre>
</div>
<p>最有让我们在Main函数调用一下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 3</span>             <span style="color: #008000;">//</span><span style="color: #008000;">文件操作测试</span>
<span style="color: #008080;"> 4</span>             FileStreamTest test = <span style="color: #0000ff;">new</span><span style="color: #000000;"> FileStreamTest();
</span><span style="color: #008080;"> 5</span>             <span style="color: #008000;">//</span><span style="color: #008000;">创建文件配置类</span>
<span style="color: #008080;"> 6</span>             CreateFileConfig createFileConfig = <span style="color: #0000ff;">new</span><span style="color: #000000;"> CreateFileConfig
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">            {
</span><span style="color: #008080;"> 8</span>                 CreateUrl = <span style="color: #800000;">@"</span><span style="color: #800000;">E:\自己的\MyTest\Word\新建的.txt</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;"> 9</span>                 IsAsync = <span style="color: #0000ff;">true</span>
<span style="color: #008080;">10</span> <span style="color: #000000;">            };
</span><span style="color: #008080;">11</span>             <span style="color: #008000;">//</span><span style="color: #008000;">复制文件配置类</span>
<span style="color: #008080;">12</span>             CopyFileConfig copyFileConfig = <span style="color: #0000ff;">new</span><span style="color: #000000;"> CopyFileConfig
</span><span style="color: #008080;">13</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">14</span>                 OriginalFileUrl = <span style="color: #800000;">@"</span><span style="color: #800000;">E:\自己的\MyTest\Word\TextFile1.txt</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">15</span>                 DestinationFileUrl = <span style="color: #800000;">@"</span><span style="color: #800000;">E:\自己的\MyTest\Word\TextFile1-副本.txt</span><span style="color: #800000;">"</span><span style="color: #000000;">,
</span><span style="color: #008080;">16</span>                 IsAsync = <span style="color: #0000ff;">true</span>
<span style="color: #008080;">17</span> <span style="color: #000000;">            };
</span><span style="color: #008080;">18</span>             <span style="color: #008000;">//</span><span style="color: #008000;">test.Create(createFileConfig);</span>
<span style="color: #008080;">19</span> <span style="color: #000000;">            test.Copy(copyFileConfig);
</span><span style="color: #008080;">20</span> <span style="color: #000000;">            Console.ReadKey();
</span><span style="color: #008080;">21</span>         }</pre>
</div>
<p><strong>输出结果：</strong></p>
<p><img src="./images/【Stream—4】FileStream相关知识分享3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;好了，FileStream的相关知识就分享到这里了。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>