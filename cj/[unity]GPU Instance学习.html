<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[unity]GPU Instance学习' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[unity]GPU Instance学习</center></div><div class='banquan'>原文出处:本文由博客园博主杰克666提供。<br/>
原文连接:https://www.cnblogs.com/jieke666/p/10815284.html</div><br>
    <p>前言<br />我们之前研究过为什么Unity的UI可以合批，是因为使用了相同的材质进行渲染，UI上不同图片渲染是通过把图片打成一张图集后，使用Image组件对顶点填充了不同的UV值实现的。<br />那么有没有什么办法可以让3D的物体也像UI一样，使用相同材质，但是可以表现出不一样的样子呢（比如颜色/位置等）？<br />我们知道unity有两种传统的批处理的方式：静态批处理，动态批处理。其中动态批处理可以实现让物体使用相同的材质，拥有不同的位置信息。但是动态批处理的局限性很高（顶点数限制，PASS数限制等）。<br />Unity在5.4及以后的版本支持了一种新的批处理方式：GPU Instancing。通过这种方式，我们可以给同一材质传递一些不同的信息，进而渲染出不同的效果。<br />GPU Instancing官方文档<br /><br /><br />1.使用Unity的Standard材质<br />首先，为了避免动态批处理影响我们观察GPU Instance的结果，我们要先把动态批处理关掉（在Build Setting中的Player Setting中）：<br />关闭动态批处理<br />然后我们在unity中新建一个材质球，把面板上的GPU Instancing选项勾上，新建几个cube得到的结果是这样的：<br />16个cube的GPUInstancing<br /><br /><br /><br />WTF?16个cube居然有67个Batches?这哪里优化了，分明是负优化好吧。。。<br />这里我们读一下文档，文档中介绍说我们需要修改一下我们的shader以支持GPUInstancing<br /><br /><br />#pragma multi_compile_instancing<br />struct appdata<br />{<br />float4 vertex : POSITION;<br />UNITY_VERTEX_INPUT_INSTANCE_ID<br />};<br />因为我使用的是旧版本的unity，看了一下stanard材质中并没有相关的宏定义，以下是我使用的standard材质的shader：<br /><br /><br />#pragma shader_feature _NORMALMAP<br />#pragma shader_feature _ _ALPHATEST_ON _ALPHABLEND_ON _ALPHAPREMULTIPLY_ON<br />#pragma shader_feature _EMISSION<br />#pragma shader_feature _METALLICGLOSSMAP&nbsp;<br />#pragma shader_feature ___ _DETAIL_MULX2<br />#pragma shader_feature _PARALLAXMAP<br /><br />#pragma multi_compile_f***ase<br />#pragma multi_compile_fog<br /><br />#pragma vertex vertForwardBase<br />#pragma fragment fragForwardBase<br /><br />#include "UnityStandardCore.cginc"<br />ENDCG<br />2.使用文档提供的demo进行实验<br />文档中提供了一个shader和一个脚本作为例子，我们就用我们之前的cube们进行实验。<br /><br /><br /><br /><br /><br /><br />使用了demo中的shader后<br /><br /><br />在使用了文档中提供的例子后，cube们真的可以通过一个DC绘制出来了。<br /><br /><br /><br /><br /><br /><br />再通过脚本中对颜色的控制，实现了一个DC中绘制不同颜色的相同材质<br /><br /><br /><br /><br /><br />shader代码：<br /><br /><br />Shader "SimplestInstancedShader"<br />{<br />Properties<br />{<br />_Color("Color", Color) = (1, 1, 1, 1)<br />}<br /><br />SubShader<br />{<br />Tags{ "RenderType" = "Opaque" }<br />LOD 100<br /><br />Pass<br />{<br />CGPROGRAM<br />#pragma vertex vert<br />#pragma fragment frag<br />#pragma multi_compile_instancing<br />#include "UnityCG.cginc"<br /><br />struct appdata<br />{<br />float4 vertex : POSITION;<br />UNITY_VERTEX_INPUT_INSTANCE_ID<br />};<br /><br />struct v2f<br />{<br />float4 vertex : SV_POSITION;<br />UNITY_VERTEX_INPUT_INSTANCE_ID // necessary only if you want to access instanced properties in fragment Shader.<br />};<br /><br />UNITY_INSTANCING_BUFFER_START(Props)<br />UNITY_DEFINE_INSTANCED_PROP(float4, _Color)<br />UNITY_INSTANCING_BUFFER_END(Props)<br /><br />v2f vert(appdata v)<br />{<br />v2f o;<br /><br />UNITY_SETUP_INSTANCE_ID(v);<br />UNITY_TRANSFER_INSTANCE_ID(v, o); // necessary only if you want to access instanced properties in the fragment Shader.<br /><br />o.vertex = UnityObjectToClipPos(v.vertex);<br />return o;<br />}<br /><br />fixed4 frag(v2f i) : SV_Target<br />{<br />UNITY_SETUP_INSTANCE_ID(i); // necessary only if any instanced properties are going to be accessed in the fragment Shader.<br />return UNITY_ACCESS_INSTANCED_PROP(Props, _Color);<br />}<br />ENDCG<br />}<br />}<br />}<br /><br />C#中，使用同一个Block进行存储不同的颜色值，给相同的材质赋予同一个Block，才能进行批处理，其中除了可以存color类型，还可以存float，texture，Matrix等类型，以实现不同的需求。代码：<br /><br /><br />MaterialPropertyBlock props = new MaterialPropertyBlock();<br />MeshRenderer renderer;<br /><br />foreach (GameObject obj in objects)<br />{<br />float r = Random.Range(0.0f, 1.0f);<br />float g = Random.Range(0.0f, 1.0f);<br />float b = Random.Range(0.0f, 1.0f);<br />props.SetColor("_Color", new Color(r, g, b));<br /><br />renderer = obj.GetComponent&lt;MeshRenderer&gt;();<br />renderer.SetPropertyBlock(props);<br />}<br />更多unity2018的功能介绍请到paws3d学习中心查找。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>