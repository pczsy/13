<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Unity的UI究竟为什么可以合批' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Unity的UI究竟为什么可以合批</center></div><div class='banquan'>原文出处:本文由博客园博主杰克666提供。<br/>
原文连接:https://www.cnblogs.com/jieke666/p/10763009.html</div><br>
    <div id="post_content_125284574798" class="d_post_content j_d_post_content  clearfix">1.UI/Default代码研究<br />首先，我想到的是，既然是对图集纹理进行采样，而且又不能统一更改材质的纹理UV值，我们通常写的shader都是直接根据模型UV值对主纹理进行采样，那会不会是shader中对MainTexture进行了什么神奇的处理，让图片采样只根据指定的UV值进行采样呢？<br />我去官网下载了shader代码，找到了UI/Default的具体实现：<br /><br /><br />fixed4 _Color;<br />fixed4 _TextureSampleAdd;<br />float4 _ClipRect;<br /><br />v2f vert(appdata_t v)<br />{<br />v2f OUT;<br />UNITY_SETUP_INSTANCE_ID(v);<br />UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);<br />OUT.worldPosition = v.vertex;<br />OUT.vertex = UnityObjectToClipPos(OUT.worldPosition);<br /><br />OUT.texcoord = v.texcoord;<br /><br />OUT.color = v.color * _Color;<br />return OUT;<br />}<br /><br />sampler2D _MainTex;<br /><br />fixed4 frag(v2f IN) : SV_Target<br />{<br />half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;<br /><br />#ifdef UNITY_UI_CLIP_RECT<br />color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);<br />#endif<br /><br />#ifdef UNITY_UI_ALPHACLIP<br />clip (color.a - 0.001);<br />#endif<br /><br />return color;<br />}<br />看了上面的代码，我们可以基本确定，没有在shader中做什么特别神奇的MainTexture处理。但是我们还是可以发现一些不同的地方，这里上面的变量_Color，_TextureSampleAdd，_ClipRect并没有暴露在面板上，可以看出来这三个变量是通过某些脚本传递给shader的。<br />我们知道，伴随着Defalut材质的一般使用的是Image组件、Text组件。这两个组件会绘制顶点与三角形，然后使用指定的材质进行渲染。所以会不会是Image组件或Text组件中使用了什么算法，计算过图片UV值，并把上面三个变量填充好传给shader的呢？<br /><br /><br />2.Image组件代码研究<br />因为unity的ui代码已经开源了，所以我们很幸运的可以看到Image的源码是怎么实现的，因为Image组件代码很多，所以这里就只贴出比较主要的绘制顶点的函数：<br /><br /><br />/// &lt;summary&gt;<br />/// Update the UI renderer mesh.<br />/// &lt;/summary&gt;<br />protected override void OnPopulateMesh(VertexHelper toFill)<br />{<br />if (activeSprite == null)<br />{<br />base.OnPopulateMesh(toFill);<br />return;<br />}<br /><br />switch (type)<br />{<br />case Type.Simple:<br />if (!useSpriteMesh)<br />GenerateSimpleSprite(toFill, m_PreserveAspect);<br />else<br />GenerateSprite(toFill, m_PreserveAspect);<br />break;<br />case Type.Sliced:<br />GenerateSlicedSprite(toFill);<br />break;<br />case Type.Tiled:<br />GenerateTiledSprite(toFill);<br />break;<br />case Type.Filled:<br />GenerateFilledSprite(toFill, m_PreserveAspect);<br />break;<br />}<br />}<br /><br />我们可以看到，这个函数是用来刷新UI渲染的，unity对图片的四种类型分别进行了处理，这里我们就只看一下最简单的Simple模式的代码：<br /><br /><br />/// &lt;summary&gt;<br />/// Generate vertices for a simple Image.<br />/// &lt;/summary&gt;<br />void GenerateSimpleSprite(VertexHelper vh, bool lPreserveAspect)<br />{<br />Vector4 v = GetDrawingDimensions(lPreserveAspect);<br />var uv = (activeSprite != null) ? Sprites.DataUtility.GetOuterUV(activeSprite) : Vector4.zero;<br /><br />var color32 = color;<br />vh.Clear();<br />vh.AddVert(new Vector3(v.x, v.y), color32, new Vector2(uv.x, uv.y));<br />vh.AddVert(new Vector3(v.x, v.w), color32, new Vector2(uv.x, uv.w));<br />vh.AddVert(new Vector3(v.z, v.w), color32, new Vector2(uv.z, uv.w));<br />vh.AddVert(new Vector3(v.z, v.y), color32, new Vector2(uv.z, uv.y));<br /><br />vh.AddTriangle(0, 1, 2);<br />vh.AddTriangle(2, 3, 0);<br />}<br /><br />/// Image's dimensions used for drawing. X = left, Y = bottom, Z = right, W = top.<br />private Vector4 GetDrawingDimensions(bool shouldPreserveAspect)<br />{<br />var padding = activeSprite == null ? Vector4.zero : Sprites.DataUtility.GetPadding(activeSprite);<br />var size = activeSprite == null ? Vector2.zero : new Vector2(activeSprite.rect.width, activeSprite.rect.height);<br /><br />Rect r = GetPixelAdjustedRect();<br />// Debug.Log(string.Format("r:{2}, size:{0}, padding:{1}", size, padding, r));<br /><br />int spriteW = Mathf.RoundToInt(size.x);<br />int spriteH = Mathf.RoundToInt(size.y);<br /><br />var v = new Vector4(<br />padding.x / spriteW,<br />padding.y / spriteH,<br />(spriteW - padding.z) / spriteW,<br />(spriteH - padding.w) / spriteH);<br /><br />if (shouldPreserveAspect &amp;&amp; size.sqrMagnitude &gt; 0.0f)<br />{<br />PreserveSpriteAspectRatio(ref r, size);<br />}<br /><br />v = new Vector4(<br />r.x + r.width * v.x,<br />r.y + r.height * v.y,<br />r.x + r.width * v.z,<br />r.y + r.height * v.w<br />);<br /><br />return v;<br />}<br /><br />public void AddVert(Vector3 position, Color32 color, Vector2 uv0);<br />就是在这里了，首先拿到绘制的尺寸v，也就是四个顶点的位置，然后根据activeSprite拿到纹理的UV值。我们可以看到AddVert函数中，第三个值是绘制的顶点中填充的uv0也就是这个得到的UV值，而shader中也会根据这个uv值对MainTexture进行采样。<br /><br /><br />3.小实验<br />我们已经知道计算顶点与UV值的操作是在image中进行的，其实unity有一个组件可以自己控制采样的uv值，就是RawImage组件，相比Image组件，RawImage组件更为精简，因为没有处理Image中的四种图片样式。<br />其实Image组件中帮我们做的操作其实就相当于（是相当于，其实计算比这复杂的多）在RawImage中设置了不同的UV偏移值。这样就可以做到，每个组件使用的UV值不同，而不是改变统一使用材质上的UV值。<br /><br />修改RawImage中的UV值<br /><br />总结<br />我们最开始的想法是修改材质中的UV值，但是这样是不行的，因为改变了材质UV值后所有物体都会跟着改变。Unity使用了一个巧妙的办法，也就是在建模（绘制顶点/三角形）的时候，就把得到的图集中纹理的UV采样值填充到mesh的UV中。所以材质使用的都是同一个材质，也都是对MainTexture进行采样，只不过每个图片的mesh中存储的UV值都是不同的。<br /><br /><br />更多unity2018的功能介绍请到paws3d爪爪学院查找。</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>