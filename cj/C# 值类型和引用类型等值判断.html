<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C# 值类型和引用类型等值判断' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C# 值类型和引用类型等值判断</center></div><div class='banquan'>原文出处:本文由博客园博主拭不去の泪痕提供。<br/>
原文连接:https://www.cnblogs.com/schangxiang/p/11142973.html</div><br>
    <div class="cnblogs_Highlighter">
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 堆和栈
{
    class Program
    {
        static void Main(string[] args)
        {

            #region 引用类型

            // s : 对象的引用【存储在栈中】
            //new Student() 【对象存储在堆中】
            Student s = new Student();//引用类型
            s.Age = 88;
            Console.WriteLine("初始对象s的Age是:" + s.Age.ToString()); // 输出：88

            Student s2 = s;//给引用类型赋值的时候，其实只是赋值了对象的引用【即是在栈中赋值了对象的引用，s和s2的引用地址都指向同一个堆上的地址】
            s2.Age = 44;
            Console.WriteLine("引用类型赋值后对象s2的Age是:" + s2.Age.ToString());// 输出：44
            Console.WriteLine("引用类型赋值后对象s的Age是:" + s.Age.ToString());// 输出：44

            #endregion

            #region  值类型

            //局部变量 【存储在栈中】
            int aaa = 0;//值类型
            Console.WriteLine("初始aaa变量的值是：" + aaa.ToString()); // 输出：0
            int aaa2 = aaa;//给值类型变量赋值的时候，是创建了一个副本（即克隆，aaa2 和aaa没一毛钱关系）
            aaa2 = 99;

            Console.WriteLine("值类型赋值后aaa变量的值是：" + aaa.ToString()); // 输出：0
            Console.WriteLine("值类型赋值后aaa2变量的值是：" + aaa2.ToString()); // 输出：99

            #endregion

            #region 等值判断

            int i = 3;
            int j = 3;
            Console.WriteLine("值类型等值判断："+(i == j).ToString());// 输出:true ,值类型等值判断直接比较值本身

            Student a = new Student();
            a.Age = 3;
            Student b = new Student();
            b.Age = 3;
            Console.WriteLine("引用类型等值判断："+(a == b).ToString());// 输出:false ,引用类型等值判断的是栈中的地址，不是比较数据的本身

            //引用类型变量的赋值操作，复制的是引用，即内存地址，由于赋值后二者都指向同一内存地址，所以改变其中一个，另一个也会跟着改变，二者就像绑定在了一起。
            Student c = a;
            Console.WriteLine("引用类型等值判断：" + (a == c).ToString());// 输出:true ,引用类型等值判断的是栈中的地址，不是比较数据的本身

            #endregion


            Console.ReadKey();


        }
    }
}
</pre>
</div>
<p>　　<img src="./images/C# 值类型和引用类型等值判断0.png" alt="" /></p>
<p>运行结果：</p>
<p><img src="./images/C# 值类型和引用类型等值判断1.png" alt="" /></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>